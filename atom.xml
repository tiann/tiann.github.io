<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Weishu's Notes]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://weishu.me/"/>
  <updated>2021-01-25T03:35:53.166Z</updated>
  <id>http://weishu.me/</id>
  
  <author>
    <name><![CDATA[weishu]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[另一种黑科技保活方法]]></title>
    <link href="http://weishu.me/2021/01/25/another-keep-alive-method/"/>
    <id>http://weishu.me/2021/01/25/another-keep-alive-method/</id>
    <published>2021-01-25T03:34:46.000Z</published>
    <updated>2021-01-25T03:35:53.166Z</updated>
    <content type="html"><![CDATA[<p>几个月前，我写了一篇<a href="http://weishu.me/2020/01/16/a-keep-alive-method-on-android/">Android 黑科技保活实现原理揭秘</a>，当时我们提到，现在的进程保活基本上分为两类，一种是想尽办法提升进程的优先级，保证进程不会轻易被系统杀死；另一种是确保进程被杀死之后能通过各种方式复活。</p>
<p><a href="http://weishu.me/2020/01/16/a-keep-alive-method-on-android/">Android 黑科技保活实现原理揭秘</a> 中的进程永生术是第二种，它通过钻 Android 杀进程的空子实现了涅槃永生；不了解的同学可以参考一下 <a href="https://github.com/tiann/Leoric" target="_blank" rel="external">PoC</a>。归根结底，所谓的黑科技就是利用系统漏洞。那么，既然我们可以利用漏洞逃过追杀，那何不更进一步，利用系统漏洞提权？</p>
<a id="more"></a>
<p>实际上，在 Android 系统中，这样的漏洞广泛地存在着。Google 会在每个月初公布其更新的安全漏洞，这些漏洞各种各样。通常情况下，更受人关注的是那些 RCE 或者 EoP 类型的漏洞，它们要么可以远程控制系统，要么可以直接获取操作系统最高权限（Root）。不过，这种类型的漏洞利用起来往往比较困难，要稳定地运行不是一件容易事，而且由于他们危害大，往往很快就会被修复。</p>
<blockquote>
<p>太极的少阳模式实际上就是使用这种方法，通过利用 1 Day 漏洞（如水滴，CVE-2020-0423等）直接获取系统最高权限，然后进行注入和拦截，这种方式不需要解锁和刷机就能实现太极阳的完整功能。</p>
</blockquote>
<p>但是，如果想要实现保活，可以大大降低这个要求：只需要提权到 system 就可以为所欲为了。当然，我们也不一定要提权，比如说想办法让系统帮忙启动一个服务，比如骗系统帮我们提升进程优先级都是可以的。</p>
<p>接下来，我们介绍一下最近公布的有关 Android 前台服务的漏洞。他们的编号分别是 <a href="https://android.googlesource.com/platform/frameworks/base/+/45a53e6cb8d3276126cfe0e717ad7ed486d39b24" target="_blank" rel="external">CVE-2020-0108</a>，<a href="https://cs.android.com/android/_/android/platform/frameworks/base/+/b740ed72b93e4671ced674456b2eaac26fda5ab9:services/core/java/com/android/server/notification/NotificationManagerService.java;dlc=95dbff5e7817b1b7e36c7d518b4818be5c23dc32" target="_blank" rel="external">CVE-2020-0313</a>。</p>
<p>如果小伙伴们有印象的话，Android 上存在一个广为流传的灰色保活方法：创建两个 Service 来启动通知，最后可以创建一个没有通知栏的前台服务，从而提升进程的优先级。接下来要介绍的这个漏洞与此类似，实际上还有一个 CVE-2020-0313也是前台服务相关。。这块代码实在是写的稀烂，漏洞百出。好了回到正题，我们先介绍一下前台服务：</p>
<blockquote>
<p>前台服务执行一些用户能注意到的操作。例如，音频应用会使用前台服务来播放音频曲目。前台服务必须显示通知。即使用户停止与应用的交互，前台服务仍会继续运行。</p>
</blockquote>
<p>前台服务所在的进程优先级非常高，一般不会被系统轻易杀死；因此如果有条件创建一个前台服务，就可以实现保活。不过，Android 有一个很强的限制，那就是前台服务必须要显示一个通知；对那些既想要在后台偷偷地跑，又不想被人发现的 App 来说，这个限制实在是让人头大。有没有办法让系统既能启动一个前台服务，又不显示通知呢？</p>
<p>如果我们创建通知的时候，故意出错，系统会有什么反应？</p>
<p>以下是我们创建前台服务的样例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String CHANNEL_ID = <span class="string">"demo_channel"</span>;</span><br><span class="line">NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line">NotificationChannel Channel = <span class="keyword">new</span> NotificationChannel(CHANNEL_ID, getString(R.string.app_name), NotificationManager.IMPORTANCE_HIGH);</span><br><span class="line">Channel.setLockscreenVisibility(Notification.VISIBILITY_PUBLIC); <span class="comment">//设置锁屏可见 VISIBILITY_PUBLIC=可见</span></span><br><span class="line"><span class="keyword">if</span> (manager != <span class="keyword">null</span>) &#123;</span><br><span class="line">    manager.createNotificationChannel(Channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Notification notification = <span class="keyword">new</span> Notification.Builder(<span class="keyword">this</span>, CHANNEL_ID)</span><br><span class="line">        .setAutoCancel(<span class="keyword">false</span>)</span><br><span class="line">        .setContentTitle(getString(R.string.app_name))</span><br><span class="line">        .setContentText(<span class="string">"运行中..."</span>)</span><br><span class="line">        .setWhen(System.currentTimeMillis())</span><br><span class="line">        .setSmallIcon(R.mipmap.ic_launcher_round)</span><br><span class="line">        .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))</span><br><span class="line">        .build();</span><br><span class="line">startForeground(<span class="number">1</span>, notification);</span><br></pre></td></tr></table></figure>
<p>可以看到，我们创建前台服务的时候需要创建一个 NotificationChannel，如果我随便搞一个channel 或者干脆传递一个错误的或者压根不存在的 channel 给系统会咋样？我们简单跟踪一下系统的前台服务启动流程，在真正要创建通知的时候，是在 <a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/services/core/java/com/android/server/am/ServiceRecord.java#687" target="_blank" rel="external">ServiceRecord.postNotification</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽略..</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (nm.getNotificationChannel(localPackageName, appUid,</span><br><span class="line">            localForegroundNoti.getChannelId()) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> targetSdkVersion = Build.VERSION_CODES.O_MR1;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ApplicationInfo applicationInfo =</span><br><span class="line">                    ams.mContext.getPackageManager().getApplicationInfoAsUser(</span><br><span class="line">                            appInfo.packageName, <span class="number">0</span>, userId);</span><br><span class="line">            targetSdkVersion = applicationInfo.targetSdkVersion;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (targetSdkVersion &gt;= Build.VERSION_CODES.O_MR1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"invalid channel for service notification: "</span></span><br><span class="line">                            + foregroundNoti);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽略..</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    ams.setServiceForeground(name, ServiceRecord.<span class="keyword">this</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">    ams.crashApplication(appUid, appPid, localPackageName, -<span class="number">1</span>,</span><br><span class="line">            <span class="string">"Bad notification for startForeground: "</span> + e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里其实就知道，我们传递了一个不存在的 channel，系统<code>getNotificationChannel</code>会发现不对劲，然后直接抛出一个异常<code>invalid channel for service notification</code>，捕获了异常之后，系统会调用 <code>ams.crashApplication</code>，我们看一下这个 <code>ams.crashApplicaiton</code>，一路跟踪，我们会发现代码调用到了这里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleCrash</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Checking killedbyAm should keep it from showing the crash dialog if the process</span></span><br><span class="line">    <span class="comment">// was already dead for a good / normal reason.</span></span><br><span class="line">    <span class="keyword">if</span> (!killedByAm) &#123;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pid == Process.myPid()) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"scheduleCrash: trying to crash system process!"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.scheduleCrash(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="comment">// If it's already dead our work is done. If it's wedged just kill it.</span></span><br><span class="line">                <span class="comment">// We won't get the crash dialog or the error reporting.</span></span><br><span class="line">                kill(<span class="string">"scheduleCrash for '"</span> + message + <span class="string">"' failed"</span>, <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                Binder.restoreCallingIdentity(ident);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哇，我们的系统真的是太温柔了！系统要让咱们进程去死的时候，不是直接提刀把咱砍了，而是赐了一杯毒酒就不管了：爱卿，你自己去死吧。不过，要是咱们进程不听话，把毒就扔了不就逍遥法外了吗！！</p>
<p>这个过程就是 CVE-2020-0108 的原理：创建一个前台服务，但是在他需要前台通知的时候给它一个子虚乌有的 channel，这样前台服务实际上创建好了，不过系统发现不对劲会让咱去死，咱厚着脸皮不死，最终就拥有了一个<strong>没有通知的前台服务</strong>。</p>
<p>你以为到这就完了？No！这个前台服务代码 Bug 一堆，咱还有个别的姿势同样能达到目的。</p>
<p>我们的总体思路是创建前台服务的时候，给它传递非法的参数让系统创建失败；上面我们给了它一个不合法的 channel，我们实际上还可以在别的地方动手脚：创建通知的时候是可以自定义布局的，如果我们给系统一个错误的布局会咋样？废话不多说我们直接跟踪代码，最终会到这里:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNotificationError</span><span class="params">(<span class="keyword">int</span> callingUid, <span class="keyword">int</span> callingPid, String pkg, String tag, <span class="keyword">int</span> id,</span><br><span class="line">        <span class="keyword">int</span> uid, <span class="keyword">int</span> initialPid, String message, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    cancelNotification(callingUid, callingPid, pkg, tag, id, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">false</span>, userId,</span><br><span class="line">            REASON_ERROR, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就更搞笑了，通知创建失败了，系统就是单纯把通知取消了；后面服务该咋运行还是咋运行，系统压根就不管！</p>
<p>好了写到这里，有关前台服务的漏洞我们已经介绍完了。Google 已经在 8 月份的安全更新中修复了这个漏洞；简单看一下修复办法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">scheduleAppCrashLocked</span><span class="params">(<span class="keyword">int</span> uid, <span class="keyword">int</span> initialPid, String packageName, <span class="keyword">int</span> userId,</span><br><span class="line">-            String message)</span> </span>&#123;</span><br><span class="line">+            String message, <span class="keyword">boolean</span> force) &#123;</span><br><span class="line">         ProcessRecord proc = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// Figure out which process to kill.  We don't trust that initialPid</span></span><br><span class="line">@@ -<span class="number">374</span>,<span class="number">6</span> +<span class="number">378</span>,<span class="number">14</span> @@</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         proc.scheduleCrash(message);</span><br><span class="line">+        <span class="keyword">if</span> (force) &#123;</span><br><span class="line">+            <span class="comment">// If the app is responsive, the scheduled crash will happen as expected</span></span><br><span class="line">+            <span class="comment">// and then the delayed summary kill will be a no-op.</span></span><br><span class="line">+            <span class="keyword">final</span> ProcessRecord p = proc;</span><br><span class="line">+            mService.mHandler.postDelayed(</span><br><span class="line">+                    () -&gt; killAppImmediateLocked(p, <span class="string">"forced"</span>, <span class="string">"killed for invalid state"</span>),</span><br><span class="line">+                    <span class="number">5000L</span>);</span><br><span class="line">+        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>很好，系统现在在赐死之后，过了五秒钟回来看一下是不是真的死了，如果没有死了再自己动手砍一刀；这才是正常的赐死逻辑嘛，哈哈。</p>
<p>如果你是一个普通用户，很可能会觉得奇怪，使用这么广泛的 Android 系统竟然存在着这么多低级漏洞？是的，任何软件系统都不可能没有 BUG，这是没法避免的客观事实。我们唯一能做到的是：<strong>如果手机有安全性更新，一定要及时更新!!</strong>千万不要觉得旧系统不是挺好的嘛，越升级越难用；否则，如果这些公开的漏洞被人利用，后果不敢设想。另外， <strong>千万不要选择那些万年不更新安全补丁的辣鸡手机！！</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>几个月前，我写了一篇<a href="http://weishu.me/2020/01/16/a-keep-alive-method-on-android/">Android 黑科技保活实现原理揭秘</a>，当时我们提到，现在的进程保活基本上分为两类，一种是想尽办法提升进程的优先级，保证进程不会轻易被系统杀死；另一种是确保进程被杀死之后能通过各种方式复活。</p>
<p><a href="http://weishu.me/2020/01/16/a-keep-alive-method-on-android/">Android 黑科技保活实现原理揭秘</a> 中的进程永生术是第二种，它通过钻 Android 杀进程的空子实现了涅槃永生；不了解的同学可以参考一下 <a href="https://github.com/tiann/Leoric">PoC</a>。归根结底，所谓的黑科技就是利用系统漏洞。那么，既然我们可以利用漏洞逃过追杀，那何不更进一步，利用系统漏洞提权？</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[从一次日志丢失所想到的]]></title>
    <link href="http://weishu.me/2020/10/30/logcat-lose-message/"/>
    <id>http://weishu.me/2020/10/30/logcat-lose-message/</id>
    <published>2020-10-30T02:29:07.000Z</published>
    <updated>2020-10-30T03:33:59.722Z</updated>
    <content type="html"><![CDATA[<p>最近我在编写一个 Android 上的驱动程序，这个驱动程序的某些部分用到了 Unix domain socket，守护进程和客户端进程使用 C/S 模式进行通信。在调试程序的时候发现一个非常奇怪的问题：如果客户端开启若干个线程连上 socket，send/recv 若干消息之后立即退出进程，从日志上看，server 端有 10% 左右的概率无法正常回收资源。</p>
<p>一开始我以为是我自己程序写的有问题，毕竟这个驱动是使用纯 C 语言实现的，并且用到了 epoll 的 <a href="https://linux.die.net/man/7/epoll" target="_blank" rel="external">ET 模式</a>，这种非阻塞的编程模型的确有许多微妙的地方，一不小心就容易出错。我排查了很久都没有发现问题所在，更有趣的是，虽然看起来我的程序无法回收资源，但是在压力测试下他也能正常工作，完全没有资源泄漏的迹象；实在没办法，我就祭出了大杀器 <a href="https://linux.die.net/man/1/strace" target="_blank" rel="external">strace</a>。不看不知道，一看就好笑：strace 显示，我的程序逻辑是正常的，它正确地调用了相关的资源释放函数！但是，logcat 中没有相关的日志，在客户端退出之后 server 端的日志就戛然而止了。看起来，好像不是我程序的问题，而是系统的 logcat 丢失了日志？</p>
<a id="more"></a>
<p>出于好奇，我就去简单看了下 Android 上 logcat 的实现。原来，logcat 也用了 C/S 模式，有个 logd 的守护进程工作在 server 端，各个进程通过 Log.d 等方法输出日志的时候，实际上也是通过一个 socket 以异步的方式传递给了 logd，logd 再把日志输出到 logcat。当我看到客户端连接 logd 的代码的时候，就立马明白了。。我们看代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> LogListener::GetLogSocket() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> socketName[] = <span class="string">"logdw"</span>;</span><br><span class="line">    <span class="keyword">int</span> sock = android_get_control_socket(socketName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sock &lt; <span class="number">0</span>) &#123;  <span class="comment">// logd started up in init.sh</span></span><br><span class="line">        sock = socket_local_server(</span><br><span class="line">            socketName, ANDROID_SOCKET_NAMESPACE_RESERVED, SOCK_DGRAM);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (setsockopt(sock, SOL_SOCKET, SO_PASSCRED, &amp;on, <span class="keyword">sizeof</span>(on))) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上代码摘自 <a href="https://cs.android.com/android/platform/superproject/+/master:system/logging/logd/LogListener.cpp;l=129;bpv=0;bpt=1" target="_blank" rel="external">AOSP master 分支</a></p>
</blockquote>
<p>原来我们的 logcat 的 socket 使用的是 UDP ！</p>
<blockquote>
<p>UDP 是User Datagram Protocol的简称， 中文名是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768 [1]  是UDP的正式规范。UDP在IP报文的协议号是17。(摘自百度百科）</p>
</blockquote>
<p>与 TCP 不同，UDP 是不保证可靠传输的。我的程序用的 TCP，因此在 send/recv 完数据之后即使进程退出，内核也会保证数据能正确地发送到对端（在对端正常的情况下）；而 logcat 使用的 UDP，一旦进程退出，数据包是有可能无法送达 logd 的。顺便一提，除了这种丢日志的情形之外，还有一种更常见的情况，就是 logcat 觉得你的日志太频繁把你阉割了，这种情况下我们会在日志中看到 “chatty” 等字样，只需要<a href="https://stackoverflow.com/questions/37006087/can-we-turn-off-chatty-in-logcat" target="_blank" rel="external">设置 logcat 的相关属性</a>就可以解决了。</p>
<p>这不禁让我想起好几年前我在知乎上回答的一个问题： <a href="https://www.zhihu.com/question/41159482/answer/89836828" target="_blank" rel="external">JAVA中：String的equals方法会不会因为恶劣的环境（海啸地震、外星人入侵等）导致运行出错？</a></p>
<p>还有，我之前在写太极的时候，发现有个 App 无论如何也注入不进去；后来发现是因为这个 App 把应用的日志全部重定向到了 /dev/null，使得我们无法看到任何日志，然后误以为是程序逻辑没有执行。</p>
<p>实际上，除了代码之外，我们经常会遇到类似的问题。归根结底，就是我们眼睛看到的东西看起来跟“事实”不一致。很多时候，我们会无意识地相信眼睛看到的，毕竟，「眼见为实」嘛！不过，如果“亲眼所见” 最终得出荒谬结论的时候，一定要想想是不是“看到的”有问题。</p>
<p>真实世界中没有鬼，如果有，也只能代表眼睛看到了鬼。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近我在编写一个 Android 上的驱动程序，这个驱动程序的某些部分用到了 Unix domain socket，守护进程和客户端进程使用 C/S 模式进行通信。在调试程序的时候发现一个非常奇怪的问题：如果客户端开启若干个线程连上 socket，send/recv 若干消息之后立即退出进程，从日志上看，server 端有 10% 左右的概率无法正常回收资源。</p>
<p>一开始我以为是我自己程序写的有问题，毕竟这个驱动是使用纯 C 语言实现的，并且用到了 epoll 的 <a href="https://linux.die.net/man/7/epoll">ET 模式</a>，这种非阻塞的编程模型的确有许多微妙的地方，一不小心就容易出错。我排查了很久都没有发现问题所在，更有趣的是，虽然看起来我的程序无法回收资源，但是在压力测试下他也能正常工作，完全没有资源泄漏的迹象；实在没办法，我就祭出了大杀器 <a href="https://linux.die.net/man/1/strace">strace</a>。不看不知道，一看就好笑：strace 显示，我的程序逻辑是正常的，它正确地调用了相关的资源释放函数！但是，logcat 中没有相关的日志，在客户端退出之后 server 端的日志就戛然而止了。看起来，好像不是我程序的问题，而是系统的 logcat 丢失了日志？</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 黑科技保活实现原理揭秘]]></title>
    <link href="http://weishu.me/2020/01/16/a-keep-alive-method-on-android/"/>
    <id>http://weishu.me/2020/01/16/a-keep-alive-method-on-android/</id>
    <published>2020-01-16T10:05:54.000Z</published>
    <updated>2020-01-16T10:13:36.485Z</updated>
    <content type="html"><![CDATA[<p>一直以来，App 进程保活都是各大厂商，特别是头部应用开发商永恒的追求。毕竟<strong>App 进程死了，就什么也干不了了</strong>；一旦 App 进程死亡，那就再也无法在用户的手机上开展任何业务，所有的商业模型在用户侧都没有立足之地了。</p>
<p>早期的 Android 系统不完善，导致 App 侧有很多空子可以钻，因此它们有着有着各种各样的姿势进行保活。譬如说在 Android 5.0 以前，App 内部通过 native 方式 fork 出来的进程是不受系统管控的，系统在杀 App 进程的时候，只会去杀 App 启动的 Java 进程；因此诞生了一大批“毒瘤”，他们通过 fork native 进程，在 App 的 Java 进程被杀死的时候通过 <code>am</code>命令拉起自己从而实现永生。那时候的 Android 可谓是魑魅横行，群魔乱舞；系统根本管不住应用，因此长期以来被人诟病耗电、卡顿。同时，系统的软弱导致了 Xposed 框架、阻止运行、绿色守护、黑域、冰箱等一系列管制系统后台进程的框架和 App 出现。</p>
<p>不过，随着 Android 系统的发展，这一切都在往好的方向演变。</p>
<a id="more"></a>
<ul>
<li>Android 5.0 以上，系统杀进程以 <code>uid</code> 为标识，通过杀死整个进程组来杀进程，因此 native 进程也躲不过系统的法眼。</li>
<li>Android 6.0 引入了待机模式(doze)，一旦用户拔下设备的电源插头，并在屏幕关闭后的一段时间内使其保持不活动状态，设备会进入低电耗模式，在该模式下设备会尝试让系统保持休眠状态。</li>
<li>Android 7.0 加强了之前鸡肋的待机模式（不再要求设备静止状态），同时对开启了 Project Svelte，Project Svelte 是专门用来优化 Android 系统后台的项目，在 Android 7.0 上直接移除了一些隐式广播，App 无法再通过监听这些广播拉起自己。</li>
<li>Android 8.0 进一步加强了应用后台执行限制：一旦应用进入已缓存状态时，如果没有活动的组件，系统将解除应用具有的所有唤醒锁。另外，系统会限制未在前台运行的应用的某些行为，比如说应用的后台服务的访问受到限制，也无法使用 Mainifest 注册大部分隐式广播。</li>
<li>Android 9.0 进一步改进了省电模式的功能并加入了<strong>应用待机分组</strong>，长时间不用的 App 会被打入冷宫；另外，系统监测到应用消耗过多资源时，系统会通知并询问用户是否需要限制该应用的后台活动。</li>
</ul>
<p>然而，道高一尺，魔高一丈。系统在不断演进，保活方法也在不断发展。大约在 4 年前出现过一个 <a href="https://github.com/Marswin/MarsDaemon" target="_blank" rel="external">MarsDaemon</a>，这个库通过双进程守护的方式实现保活，一时间风头无两。不过好景不长，进入 Android 8.0 时代之后，这个库就逐渐消亡。</p>
<p>一般来说，Android 进程保活分为两个方面：</p>
<ol>
<li>保持进程不被系统杀死。</li>
<li>进程被系统杀死之后，可以重新复活。</li>
</ol>
<p>随着 Android 系统变得越来越完善，单单通过自己拉活自己逐渐变得不可能了；因此后面的所谓「保活」基本上是两条路：1. 提升自己进程的优先级，让系统不要轻易弄死自己；2. App 之间互相结盟，一个兄弟死了其他兄弟把它拉起来。</p>
<p>当然，还有一种终极方法，那就是跟各大系统厂商建立 PY 关系，把自己加入系统内存清理的白名单；比如说国民应用微信。当然这条路一般人是没有资格走的。</p>
<p>大约一年以前，大神 gityuan 在其<a href="http://gityuan.com/2018/02/24/process-keep-forever/" target="_blank" rel="external">博客</a>上公布了 TIM 使用的一种可以称之为「终极永生术」的保活方法；这种方法在当前 Android 内核的实现上可以大大提升进程的存活率。笔者研究了这种保活思路的实现原理，并且提供了一个参考实现 <a href="https://github.com/tiann/Leoric" target="_blank" rel="external">Leoric</a>。接下来就给大家分享一下这个终极保活黑科技的实现原理。</p>
<h2 id="保活的底层技术原理">保活的底层技术原理</h2><p>知己知彼，百战不殆。既然我们想要保活，那么首先得知道我们是怎么死的。一般来说，系统杀进程有两种方法，这两个方法都通过 ActivityManagerService 提供：</p>
<ol>
<li>killBackgroundProcesses</li>
<li>forceStopPackage</li>
</ol>
<p>在原生系统上，很多时候杀进程是通过第一种方式，除非用户主动在 App 的设置界面点击「强制停止」。不过国内各厂商以及一加三星等 ROM 现在一般使用第二种方法。第一种方法太过温柔，根本治不住想要搞事情的应用。第二种方法就比较强力了，一般来说被 force-stop 之后，App 就只能乖乖等死了。</p>
<p>因此，要实现保活，我们就得知道 force-stop 到底是如何运作的。既然如此，我们就跟踪一下系统的 <code>forceStopPackage</code> 这个方法的执行流程：</p>
<p>首先是 <code>ActivityManagerService</code>里面的 <code>forceStopPackage</code> 这方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forceStopPackage</span><span class="params">(<span class="keyword">final</span> String packageName, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// .. 权限检查，省略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> callingId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        IPackageManager pm = AppGlobals.getPackageManager();</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] users = userId == UserHandle.USER_ALL</span><br><span class="line">                    ? mUserController.getUsers() : <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; userId &#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> user : users) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 状态判断，省略..</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> pkgUid = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    pkgUid = pm.getPackageUid(packageName, MATCH_DEBUG_TRIAGED_MISSING,</span><br><span class="line">                            user);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pkgUid == -<span class="number">1</span>) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Invalid packageName: "</span> + packageName);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    pm.setPackageStoppedState(packageName, <span class="keyword">true</span>, user);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Failed trying to unstop package "</span></span><br><span class="line">                            + packageName + <span class="string">": "</span> + e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mUserController.isUserRunning(user, <span class="number">0</span>)) &#123;</span><br><span class="line">                	<span class="comment">// 根据 UID 和包名杀进程</span></span><br><span class="line">                    forceStopPackageLocked(packageName, pkgUid, <span class="string">"from pid "</span> + callingPid);</span><br><span class="line">                    finishForceStopPackageLocked(packageName, pkgUid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(callingId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们可以知道，系统是通过 <code>uid</code> 为单位 force-stop 进程的，因此不论你是 native 进程还是 Java 进程，force-stop 都会将你统统杀死。我们继续跟踪<code>forceStopPackageLocked</code> 这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">forceStopPackageLocked</span><span class="params">(String packageName, <span class="keyword">int</span> appId,</span><br><span class="line">        <span class="keyword">boolean</span> callerWillRestart, <span class="keyword">boolean</span> purgeCache, <span class="keyword">boolean</span> doit,</span><br><span class="line">        <span class="keyword">boolean</span> evenPersistent, <span class="keyword">boolean</span> uninstalling, <span class="keyword">int</span> userId, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// .. 状态判断，省略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> didSomething = mProcessList.killPackageProcessesLocked(packageName, appId, userId,</span><br><span class="line">            ProcessList.INVALID_ADJ, callerWillRestart, <span class="keyword">true</span> <span class="comment">/* allowRestart */</span>, doit,</span><br><span class="line">            evenPersistent, <span class="keyword">true</span> <span class="comment">/* setRemoved */</span>,</span><br><span class="line">            packageName == <span class="keyword">null</span> ? (<span class="string">"stop user "</span> + userId) : (<span class="string">"stop "</span> + packageName));</span><br><span class="line"></span><br><span class="line">    didSomething |=</span><br><span class="line">            mAtmInternal.onForceStopPackage(packageName, doit, evenPersistent, userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理 service</span></span><br><span class="line">    <span class="comment">// 清理 broadcastreceiver</span></span><br><span class="line">    <span class="comment">// 清理 providers</span></span><br><span class="line">    <span class="comment">// 清理其他</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法实现很清晰：先杀死这个 App 内部的所有进程，然后清理残留在 system_server 内的四大组件信息；我们关心进程是如何被杀死的，因此继续跟踪<code>killPackageProcessesLocked</code>，这个方法最终会调用到 <code>ProcessList</code> 内部的 <code>removeProcessLocked</code> 方法，<code>removeProcessLocked</code> 会调用 <code>ProcessRecord</code> 的 <code>kill</code> 方法，我们看看这个<code>kill</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kill</span><span class="params">(String reason, <span class="keyword">boolean</span> noisy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!killedByAm) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"kill"</span>);</span><br><span class="line">        <span class="keyword">if</span> (mService != <span class="keyword">null</span> &amp;&amp; (noisy || info.uid == mService.mCurOomAdjUid)) &#123;</span><br><span class="line">            mService.reportUidInfoMessageLocked(TAG,</span><br><span class="line">                    <span class="string">"Killing "</span> + toShortString() + <span class="string">" (adj "</span> + setAdj + <span class="string">"): "</span> + reason,</span><br><span class="line">                    info.uid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            EventLog.writeEvent(EventLogTags.AM_KILL, userId, pid, processName, setAdj, reason);</span><br><span class="line">            Process.killProcessQuiet(pid);</span><br><span class="line">            ProcessList.killProcessGroup(uid, pid);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pendingStart = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!mPersistent) &#123;</span><br><span class="line">            killed = <span class="keyword">true</span>;</span><br><span class="line">            killedByAm = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到，首先杀掉了目标进程，然后会以<code>uid</code>为单位杀掉目标进程组。如果只杀掉目标进程，那么我们可以通过双进程守护的方式实现保活；关键就在于这个<code>killProcessGroup</code>，继续跟踪之后发现这是一个 native 方法，它的最终实现在 <a href="http://www.aospxref.com/android-10.0.0_r2/xref/system/core/libprocessgroup/processgroup.cpp#390" target="_blank" rel="external">libprocessgroup</a>中，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">killProcessGroup</span><span class="params">(uid_t uid, <span class="keyword">int</span> initialPid, <span class="keyword">int</span> signal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> KillProcessGroup(uid, initialPid, signal, <span class="number">40</span> <span class="comment">/*retries*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里有个奇怪的数字：40。我们继续跟踪：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">KillProcessGroup</span><span class="params">(uid_t uid, <span class="keyword">int</span> initialPid, <span class="keyword">int</span> signal, <span class="keyword">int</span> retries)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> retry = retries;</span><br><span class="line">    <span class="keyword">int</span> processes;</span><br><span class="line">    <span class="keyword">while</span> ((processes = DoKillProcessGroupOnce(cgroup, uid, initialPid, signal)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOG(VERBOSE) &lt;&lt; <span class="string">"Killed "</span> &lt;&lt; processes &lt;&lt; <span class="string">" processes for processgroup "</span> &lt;&lt; initialPid;</span><br><span class="line">        <span class="keyword">if</span> (retry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">5</span>ms);</span><br><span class="line">            --retry;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>瞧瞧我们的系统做了什么骚操作？<strong>循环 40 遍不停滴杀进程，每次杀完之后等 5ms</strong>，循环完毕之后就算过去了。</p>
<p>看到这段代码，我想任何人都会蹦出一个疑问：假设经历连续 40 次的杀进程之后，如果 App 还有进程存在，那不就侥幸逃脱了吗？</p>
<h2 id="实现方法">实现方法</h2><p>那么，如何实现这个目的呢？我们看这个关键的 <strong>5ms</strong>。假设，App 进程在被杀掉之后，能够以足够快的速度（5ms 内）启动一堆新的进程，那么系统在一次循环杀掉老的所有进程之后，sleep 5ms 之后又会遇到一堆新的进程；如此循环 40 次，只要我们每次都能够拉起新的进程，那我们的 App 就能逃过系统的追杀，实现永生。是的，炼狱般的 200ms，只要我们熬过 200ms 就能渡劫成功，得道飞升。不知道大家有没有玩过打地鼠这个游戏，整个过程非常类似，按下去一个又冒出一个，只要每次都能足够快地冒出来，我们就赢了。</p>
<p>现在问题的关键就在于：<strong>如何在 5ms 内启动一堆新的进程</strong>？</p>
<p>再回过头来看原来的保活方式，它们拉起进程最开始通过<code>am</code>命令，这个命令实际上是一个 java 程序，它会经历启动一个进程然后启动一个 ART 虚拟机，接着获取 ams 的 binder 代理，然后与 ams 进行 binder 同步通信。这个过程实在是太慢了，在这与死神赛跑的 5ms 里，它的速度的确是不敢恭维。</p>
<p>后来，MarsDaemon 提出了一种新的方式，它用 binder 引用直接给 ams 发送 Parcel，这个过程相比 <code>am</code>命令快了很多，从而大大提高了成功率。其实这里还有改进的空间，毕竟这里还是在 Java 层调用，Java 语言在这种实时性要求极高的场合有一个非常令人诟病的特性：垃圾回收（GC）；虽然我们在这 5ms 内直接碰上 gc 引发停顿的可能性非常小，但是由于 GC 的存在，ART 中的 Java 代码存在非常多的 checkpoint；想象一下你现在是一个信使有重要军情要报告，但是在路上却碰到很多关隘，而且很可能被勒令暂时停止一下，这种情况是不可接受的。因此，最好的方法是通过 native code 给 ams 发送 binder 调用；当然，如果再底层一点，我们甚至可以通过 <code>ioctl</code> 直接给 binder 驱动发送数据进而完成调用，但是这种方法的兼容性比较差，没有用 native 方式省心。</p>
<p>通过在 native 层给 ams 发送 binder 消息拉起进程，我们算是解决了「快速拉起进程」这个问题。但是这个还是不够。还是回到打地鼠这个游戏，假设你摁下一个地鼠，会冒起一个新的地鼠，那么你每次都能摁下去最后获取胜利的概率还是比较高的；但如果你每次摁下一个地鼠，其他所有地鼠都能冒出来呢？这个难度系数可是要高多了。如果我们的进程能够在<strong>任意一个进程死亡之后，都能让把其他所有进程全部拉起</strong>，这样系统就很难杀死我们了。</p>
<p>新的黑科技保活中通过 2 个机制来保证进程之间的互相拉起：</p>
<ol>
<li>2 个进程通过互相监听文件锁的方式，来感知彼此的死亡。</li>
<li>通过 fork 产生子进程，fork 的进程同属一个进程组，一个被杀之后会触发另外一个进程被杀，从而被文件锁感知。</li>
</ol>
<p>具体来说，创建 2 个进程 p1, p2，这两个进程通过文件锁互相关联，一个被杀之后拉起另外一个；同时 p1 经过 2 次 fork 产生孤儿进程 c1，p2 经过 2 次 fork 产生孤儿进程 c2，c1 和 c2 之间建立文件锁关联。这样假设 p1 被杀，那么 p2 会立马感知到，然后 p1 和 c1 同属一个进程组，p1 被杀会触发 c1 被杀，c1 死后 c2 立马感受到从而拉起 p1，因此这四个进程三三之间形成了铁三角，从而保证了存活率。</p>
<p>分析到这里，这种方案的大致原理我们已经清晰了。基于以上原理，我写了一个简单的 PoC，代码在这里：<a href="https://github.com/tiann/Leoric" target="_blank" rel="external">https://github.com/tiann/Leoric</a> 有兴趣的可以看一下。</p>
<h2 id="改进空间">改进空间</h2><p>本方案的原理还是比较简单直观的，但是要实现稳定的保活，还需要很多细节要补充；特别是那与死神赛跑的 5ms，需要不计一切代价去优化才能提升成功率。具体来说，就是当前的实现是在 Java 层用 binder 调用的，我们应该在 native 层完成。笔者曾经实现过这个方案，但是这个库本质上是有损用户利益的，因此并不打算公开代码，这里简单提一下实现思路供大家学习：</p>
<h3 id="如何在_native_层进行_binder_通信？">如何在 native 层进行 binder 通信？</h3><p>libbinder 是 NDK 公开库，拿到对应头文件，动态链接即可。</p>
<p>难点：依赖繁多，剥离头文件是个体力活。</p>
<p>如何组织 binder 通信的数据？</p>
<p>通信的数据其实就是二进制流；具体表现就是 (C++/Java) Parcel 对象。native 层没有对应的 Intent Parcel，兼容性差。</p>
<p>方案：</p>
<ol>
<li>Java 层创建 Parcel （含 Intent），拿到 Parcel 对象的 mNativePtr(native peer)，传到 Native 层。</li>
<li>native 层直接把 mNativePtr 强转为结构体指针。</li>
<li>fork 子进程，建立管道，准备传输 parcel 数据。</li>
<li>子进程读管道，拿到二进制流，重组为 parcel。</li>
</ol>
<h2 id="如何应对？">如何应对？</h2><p>今天我把这个实现原理公开，并且提供 PoC 代码，并不是鼓励大家使用这种方式保活，而是希望各大系统厂商能感知到这种黑科技的存在，推动自己的系统彻底解决这个问题。</p>
<p>两年前我就知道了这个方案的存在，不过当时鲜为人知。最近一个月我发现很多 App 都使用了这种方案，把我的 Android 手机折腾的惨不忍睹；毕竟本人手机上安装了将近 800 个 App，假设每个 App 都用这个方案保活，那这系统就没法用了。</p>
<h3 id="系统如何应对？">系统如何应对？</h3><p>如果我们把系统杀进程比喻为斩首，那么这个保活方案的精髓在于能快速长出一个新的头；因此应对之法也很简单，只要我们在斩杀一个进程的时候，让别的进程老老实实呆着别搞事情就 OK 了。具体的实现方法多种多样，不赘述。</p>
<h3 id="用户如何应对？">用户如何应对？</h3><p>在厂商没有推出解决方案之前，用户可以有一些方案来缓解使用这个方案进行保活的流氓 App。这里推荐两个应用给大家：</p>
<ul>
<li><a href="https://www.coolapk.com/apk/com.catchingnow.icebox" target="_blank" rel="external">冰箱</a></li>
<li><a href="https://www.coolapk.com/apk/com.oasisfeng.island" target="_blank" rel="external">Island</a></li>
</ul>
<p>通过冰箱的冻结和 Island 的深度休眠可以彻底阻止 App 的这种保活行为。当然，如果你喜欢别的这种“冻结”类型的应用，比如<a href="https://www.coolapk.com/apk/web1n.stopapp" target="_blank" rel="external">小黑屋</a>或者<a href="https://www.coolapk.com/apk/me.weishu.exp" target="_blank" rel="external">太极</a>的阴阳之门也是可以的。</p>
<p>其他不是通过“冻结”这种机制来压制后台的应用理论上对这种保活方案的作用非常有限。</p>
<h2 id="总结">总结</h2><ol>
<li>对技术来说，黑科技没有什么黑的，不过是对系统底层原理的深入了解从而反过来对抗系统的一种手段。很多人会说，了解系统底层有什么用，本文应该可以给出一个答案：可以实现别人永远也无法实现的功能，通过技术推动产品，从而产生巨大的商业价值。</li>
<li>黑科技虽强，但是它不该存在于这世上。没有规矩，不成方圆。黑科技黑的了一时，黑不了一世。要提升产品的存活率，终归要落到产品本身上面来，尊重用户，提升体验方是正途。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>一直以来，App 进程保活都是各大厂商，特别是头部应用开发商永恒的追求。毕竟<strong>App 进程死了，就什么也干不了了</strong>；一旦 App 进程死亡，那就再也无法在用户的手机上开展任何业务，所有的商业模型在用户侧都没有立足之地了。</p>
<p>早期的 Android 系统不完善，导致 App 侧有很多空子可以钻，因此它们有着有着各种各样的姿势进行保活。譬如说在 Android 5.0 以前，App 内部通过 native 方式 fork 出来的进程是不受系统管控的，系统在杀 App 进程的时候，只会去杀 App 启动的 Java 进程；因此诞生了一大批“毒瘤”，他们通过 fork native 进程，在 App 的 Java 进程被杀死的时候通过 <code>am</code>命令拉起自己从而实现永生。那时候的 Android 可谓是魑魅横行，群魔乱舞；系统根本管不住应用，因此长期以来被人诟病耗电、卡顿。同时，系统的软弱导致了 Xposed 框架、阻止运行、绿色守护、黑域、冰箱等一系列管制系统后台进程的框架和 App 出现。</p>
<p>不过，随着 Android 系统的发展，这一切都在往好的方向演变。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://weishu.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[另一种绕过 Android P以上非公开API限制的办法]]></title>
    <link href="http://weishu.me/2019/03/16/another-free-reflection-above-android-p/"/>
    <id>http://weishu.me/2019/03/16/another-free-reflection-above-android-p/</id>
    <published>2019-03-16T08:34:45.000Z</published>
    <updated>2019-03-16T08:37:54.776Z</updated>
    <content type="html"><![CDATA[<p>去年发布的 Android P上引入了针对非公开API的限制，对开发者来说，这绝对是有史以来最重大的变化之一。前天 Google 发布了 Android Q 的 Beta 版，越来越多的 API 被加入了黑名单，而且 Google 要求下半年 APP 必须 target 28，这意味着现在的深灰名单也会生效；可以预见，在不久的将来，我们要跟大量的 API 说再见了。</p>
<p>去年我给出了<a href="http://weishu.me/2018/06/07/free-reflection-above-android-p/">一种绕过Android P对非SDK接口限制的简单方法</a>，经验证，这办法在 Android Q 的 Beta 版上依然能正常使用。虽然这个方法需要进行内存搜索，理论上有可能失败，但实际上它曾在 VirtualXposed 和 太极 中得到了较为广泛的验证，从未收到过由于反射失败而导致问题的反馈。而且据我所知，有若干用户量不少的 APP 在线上使用了我提供的 <a href="https://github.com/tiann/FreeReflection/" target="_blank" rel="external">FreeReflection</a> 库，想来应该也是没有问题的吧。</p>
<p>不过今天，我打算给出另外一种绕过限制的办法。这个办法目前来说是最优方案，我个人使用了一个多月，不存在任何问题。</p>
<a id="more"></a>
<p>上次<a href="http://weishu.me/2018/06/07/free-reflection-above-android-p/">分析系统是如何施加这个限制</a> 的时候，我们提到了几种方式，最终给出了一种修改 runtime flag 的办法；其中我们提到，系统有一个 <code>fn_caller_is_trusted</code> 条件：<strong>如果调用者是系统类，那么就允许被调用</strong>。这是显而易见的，毕竟这些私有 API 就是给系统用的，如果系统自己都被拒绝了，这是在玩锤子呢？</p>
<p>也就是说，如果我们能<strong>以系统类的身份去反射，那么就能畅通无阻</strong>。问题是，我们如何以「系统的身份去反射」呢？一种最常见的办法是，我们自己写一个类，然后通过某种途径把这个类的 ClassLoader 设置为系统的 ClassLoader，再借助这个类去反射其他类。但是这里的「通过某种途径」依然要使用一些黑科技才能实现，与修改 flags / inline hook 无本质区别。</p>
<p><strong>以系统类的身份去反射</strong> 有两个意思，1. 直接把我们自己变成系统类；2. 借助系统类去调用反射。我们一个个分析。</p>
<p>「直接把我们自己变成系统类」这个方式有童鞋可能觉得天方夜谭，APP 的类怎么可能成为系统类？但是，一定不要被自己的固有思维给局限，一切皆有可能！我们知道，对APP来说，所谓的系统类就是被 BootstrapClassLoader 加载的类，这个 ClassLoader 并非普通的 DexClassLoader，因此我们无法通过插入 dex path的方式注入类。但是，Android 的 ART 在 Android O 上引入了 JVMTI，JVMTI 提供了将某一个类转换为 BootstrapClassLoader 中的类的方法！具体来说，我们写一个类暴露反射相关的接口，然后通过 JVMTI 提供的 <code>AddToBootstrapClassLoaderSearch</code>将此类加入 BootstrapClassLoader 就实现目的了。不过，JVMTI 要在 release 版本的 APP 上运行依然需要 Hack，所以这种途径与其他的黑科技无本质区别。 </p>
<p>第二种方法，「借助系统的类去反射」也就是说，如果系统有一个方法<code>systemMethod</code>，这个<code>systemMethod</code> 去调用反射相反的方法，那么<code>systemMethod</code>毋庸置疑会反射成功。但是，我们从哪去找到这么一个方法给我们用？事实上，我们不仅能找到这样的方法，而且这个方法能帮助我们调用任意的函数，那就是<strong>反射本身！</strong>可能你已经绕晕了，我解释一下：</p>
<ol>
<li>首先，我们通过反射 API 拿到 <code>getDeclaredMethod</code> 方法。<code>getDeclaredMethod</code> 是 public 的，不存在问题；这个通过反射拿到的方法我们称之为<strong>元反射方法</strong>。</li>
<li>然后，我们通过刚刚反射拿到<strong>元反射方法</strong>去反射调用 <code>getDeclardMethod</code>。这里我们就实现了<strong>以系统身份去反射</strong>的目的——反射相关的 API 都是系统类，因此我们的元反射方法也是被系统类加载的方法；所以我们的元反射方法调用的 <code>getDeclardMethod</code> 会被认为是系统调用的，可以反射任意的方法。</li>
</ol>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Method metaGetDeclaredMethod =</span><br><span class="line">        Class.class.getDeclaredMethod(<span class="string">"getDeclardMethod"</span>); <span class="comment">// 公开API，无问题</span></span><br><span class="line">Method hiddenMethod = metaGetDeclaredMethod.invoke(hiddenClass,</span><br><span class="line">        <span class="string">"hiddenMethod"</span>, <span class="string">"hiddenMethod参数列表"</span>); <span class="comment">// 系统类通过反射使用隐藏 API，检查直接通过。</span></span><br><span class="line">hiddenMethod.invoke <span class="comment">// 正确找到 Method 直接反射调用</span></span><br></pre></td></tr></table></figure>
<p>到这里，我们已经能通过「元反射」的方式去任意获取隐藏方法或者隐藏 Field 了。但是，如果我们所有使用的隐藏方法都要这么干，那还有点小麻烦。在 <a href="http://weishu.me/2018/06/07/free-reflection-above-android-p">上文</a>中，我们后来发现，隐藏 API 调用还有「豁免」条件，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldWarn || action == kDeny) &#123;</span><br><span class="line">    <span class="keyword">if</span> (member_signature.IsExempted(runtime-&gt;GetHiddenApiExemptions())) &#123;</span><br><span class="line">      action = kAllow;</span><br><span class="line">      <span class="comment">// Avoid re-examining the exemption list next time.</span></span><br><span class="line">      <span class="comment">// Note this results in no warning for the member, which seems like what one would expect.</span></span><br><span class="line">      <span class="comment">// Exemptions effectively adds new members to the whitelist.</span></span><br><span class="line">      MaybeWhitelistMember(runtime, member);</span><br><span class="line">      <span class="keyword">return</span> kAllow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 略    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要 <code>IsExempted</code> 方法返回 true，就算这个方法在黑名单中，依然会被放行然后允许被调用。我们再观察一下<code>IsExempted</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool MemberSignature::IsExempted(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; exemptions) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> std::string&amp; exemption : exemptions) &#123;</span><br><span class="line">    <span class="keyword">if</span> (DoesPrefixMatch(exemption)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续跟踪传递进来的参数 <code>runtime-&gt;GetHiddenApiExemptions()</code> 发现这玩意儿也是 runtime 里面的一个参数，既然如此，我们可以一不做二不休，仿照修改 runtime flag 的方式直接修改 <code>hidden_api_exemptions_</code> 也能绕过去。但如果我们继续跟踪下去，会有个有趣的发现：这个API 竟然是暴露到 Java 层的，有一个对应的 <a href="http://androidxref.com/9.0.0_r3/xref/libcore/libart/src/main/java/dalvik/system/VMRuntime.java#278" target="_blank" rel="external">VMRuntime.setHiddenApiExemptions</a>  Java方法；也就是说，只要我们通过 <code>VMRuntime.setHiddenApiExemptions</code> 设置下豁免条件，我们就能愉快滴使用反射了。</p>
<p>再结合上面这个方法，我们只需要通过 「元反射」来反射调用 <code>VMRuntime.setHiddenApiExemptions</code> 就能将我们自己要使用的隐藏 API 全部都豁免掉了。更进一步，如果我们再观察下上面的 <code>IsExempted</code> 方法里面调用的 <code>DoesPrefixMatch</code>，发现这玩意儿在对方法签名进行前缀匹配；童鞋们，我们所有Java方法类的签名都是以 <strong>L</strong>开头啊！如果我们把直接传个 <code>L</code>进去，所有的隐藏API全部被赦免了！</p>
<p>详细代码在这里：<a href="https://github.com/tiann/FreeReflection" target="_blank" rel="external">https://github.com/tiann/FreeReflection</a></p>
<p>理论上讲，这个方案不存在兼容性问题。即使 ROM 删掉了 <code>setHiddenApiExemptions</code> 方法，我们依然可以用「元反射」的方式去反射隐藏API，并且所有的代码加起来不超过30行！当然，如果 Google 继续改进验证隐藏API调用的方法，这个方式可能会失效；但是目前的机制没有问题。</p>
<p>文章的最后，我想说的是，本文的目的不是刻意去绕过限制。不给思维设限、不给人生设限，才会有更多可能。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>去年发布的 Android P上引入了针对非公开API的限制，对开发者来说，这绝对是有史以来最重大的变化之一。前天 Google 发布了 Android Q 的 Beta 版，越来越多的 API 被加入了黑名单，而且 Google 要求下半年 APP 必须 target 28，这意味着现在的深灰名单也会生效；可以预见，在不久的将来，我们要跟大量的 API 说再见了。</p>
<p>去年我给出了<a href="http://weishu.me/2018/06/07/free-reflection-above-android-p/">一种绕过Android P对非SDK接口限制的简单方法</a>，经验证，这办法在 Android Q 的 Beta 版上依然能正常使用。虽然这个方法需要进行内存搜索，理论上有可能失败，但实际上它曾在 VirtualXposed 和 太极 中得到了较为广泛的验证，从未收到过由于反射失败而导致问题的反馈。而且据我所知，有若干用户量不少的 APP 在线上使用了我提供的 <a href="https://github.com/tiann/FreeReflection/">FreeReflection</a> 库，想来应该也是没有问题的吧。</p>
<p>不过今天，我打算给出另外一种绕过限制的办法。这个办法目前来说是最优方案，我个人使用了一个多月，不存在任何问题。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://weishu.me/tags/Android/"/>
    
      <category term="Framework" scheme="http://weishu.me/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android插件化原理解析——剧终]]></title>
    <link href="http://weishu.me/2018/08/27/understand-plugin-framework-book/"/>
    <id>http://weishu.me/2018/08/27/understand-plugin-framework-book/</id>
    <published>2018-08-27T04:59:21.000Z</published>
    <updated>2019-01-30T04:06:02.854Z</updated>
    <content type="html"><![CDATA[<p>从我写下 <a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">Android插件化原理解析</a> 系列第一篇文章至今，已经过去了两年时间。这期间，插件化技术也得到了长足的发展；与此同时，React Native，PWA，App Bundle，以及最近的Flutter也如火如荼。由于实现插件化需要太多的黑科技，它给项目的维护成本和稳定性增加了诸多不确定性；我个人认为，2017年手淘Atlas插件化项目的开源标志着插件化的落幕，2018年Android 9.0上私有API的限制几乎称得上是盖棺定论了——曾经波澜壮阔的插件化进程必将要退出历史主流。如今的插件化技术朝两个方向发展：其一，插件化的工程特性：模块化/解耦被抽离，逐渐演进为稳定、务实的的组件化方案；其二，插件化的黑科技特性被进一步发掘，inline hook/method hook大行其道，走向双开，虚拟环境等等。</p>
<p>虽然插件化终将落幕，但是它背后的技术原理包罗万象，值得每一个希望深入Android的小伙伴们学习。</p>
<p>很遗憾曾经的系列文章没有写完，现在已经没机会甚至可以说不可能去把它完结了；不过幸运的是，我的良师益友包老师（我习惯称呼他为包哥）写了一本关于插件化的书——《Android插件化开发指南》，书中讲述了过去数年浩浩荡荡的插件化历程以及插件技术的方方面面；有兴趣的小伙伴可以买一本看看。</p>
<a id="more"></a>
<p><a href="https://item.m.jd.com/product/31188356430.html?utm_source=iosapp&amp;utm_medium=appshare&amp;utm_campaign=t_335139774&amp;utm_term=Wxfriends" target="_blank" rel="external"><img src="http://weishu.dimensionalzone.com/201605/1535348090511.png" alt="点击购买"></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>从我写下 <a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">Android插件化原理解析</a> 系列第一篇文章至今，已经过去了两年时间。这期间，插件化技术也得到了长足的发展；与此同时，React Native，PWA，App Bundle，以及最近的Flutter也如火如荼。由于实现插件化需要太多的黑科技，它给项目的维护成本和稳定性增加了诸多不确定性；我个人认为，2017年手淘Atlas插件化项目的开源标志着插件化的落幕，2018年Android 9.0上私有API的限制几乎称得上是盖棺定论了——曾经波澜壮阔的插件化进程必将要退出历史主流。如今的插件化技术朝两个方向发展：其一，插件化的工程特性：模块化/解耦被抽离，逐渐演进为稳定、务实的的组件化方案；其二，插件化的黑科技特性被进一步发掘，inline hook/method hook大行其道，走向双开，虚拟环境等等。</p>
<p>虽然插件化终将落幕，但是它背后的技术原理包罗万象，值得每一个希望深入Android的小伙伴们学习。</p>
<p>很遗憾曾经的系列文章没有写完，现在已经没机会甚至可以说不可能去把它完结了；不过幸运的是，我的良师益友包老师（我习惯称呼他为包哥）写了一本关于插件化的书——《Android插件化开发指南》，书中讲述了过去数年浩浩荡荡的插件化历程以及插件技术的方方面面；有兴趣的小伙伴可以买一本看看。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[一种绕过Android P对非SDK接口限制的简单方法]]></title>
    <link href="http://weishu.me/2018/06/07/free-reflection-above-android-p/"/>
    <id>http://weishu.me/2018/06/07/free-reflection-above-android-p/</id>
    <published>2018-06-07T13:14:29.000Z</published>
    <updated>2019-01-30T04:06:02.840Z</updated>
    <content type="html"><![CDATA[<p>众所周知，Android P 引入了<a href="https://developer.android.com/preview/restrictions-non-sdk-interfaces?hl=zh-cn" target="_blank" rel="external">针对非 SDK 接口（俗称为隐藏API）的使用限制</a>。这是继 Android N上<a href="https://developer.android.com/about/versions/nougat/android-7.0-changes?hl=zh-cn" target="_blank" rel="external">针对 NDK 中私有库的链接限制</a>之后的又一次重大调整。从今以后，不论是native层的NDK还是 Java层的SDK，我们只能使用Google提供的、公开的标准接口。这对开发者以及用户乃至整个Android生态，当然是一件好事。但这也同时意味着Android上的各种黑科技有可能会逐渐走向消亡。</p>
<p>作为一个有追求的开发者，我们既要尊重并遵守规则，也要有能力在必要的时候突破规则的束缚，带着镣铐跳舞。恰好最近有人反馈 <a href="https://github.com/android-hacker/VirtualXposed/issues/115" target="_blank" rel="external">VirtualXposed 在 Android P上无法运行</a>，那么今天就来探讨一下，如何突破Android P上针对非SDK接口调用的限制。</p>
<a id="more"></a>
<h2 id="系统是如何实现这个限制的？">系统是如何实现这个限制的？</h2><p>知己知彼，百战不殆。既然我们想要突破这个限制，自然先得弄清楚，系统是如何给我们施加这个限制的。</p>
<p><a href="https://developer.android.com/preview/restrictions-non-sdk-interfaces?hl=zh-cn" target="_blank" rel="external">文档</a> 中说，通过反射或者JNI访问非公开接口时会触发警告/异常等，那么不妨跟踪一下反射的流程，看看系统到底在哪一步做的限制（以下的源码分析大可以走马观花的看一下，需要的时候自己再仔细看）。我们从 <code>java.lang.Class.getDeclaredMethod(String)</code> 看起，这个方法在Java层<a href="https://android.googlesource.com/platform/libcore/+/android-p-preview-2/ojluni/src/main/java/java/lang/Class.java" target="_blank" rel="external">最终调用到</a>了 <code>getDeclaredMethodInternal</code> 这个native方法，看一下这个方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">Class_getDeclaredMethodInternal</span><span class="params">(JNIEnv* env, jobject javaThis,</span><br><span class="line">                                               jstring name, jobjectArray args)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedFastNativeObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">  StackHandleScope&lt;<span class="number">1</span>&gt; hs(soa.Self());</span><br><span class="line">  DCHECK_EQ(Runtime::Current()-&gt;GetClassLinker()-&gt;GetImagePointerSize(), kRuntimePointerSize);</span><br><span class="line">  DCHECK(!Runtime::Current()-&gt;IsActiveTransaction());</span><br><span class="line">  Handle&lt;mirror::Method&gt; result = hs.NewHandle(</span><br><span class="line">      mirror::Class::GetDeclaredMethodInternal&lt;kRuntimePointerSize, <span class="keyword">false</span>&gt;(</span><br><span class="line">          soa.Self(),</span><br><span class="line">          DecodeClass(soa, javaThis),</span><br><span class="line">          soa.Decode&lt;mirror::String&gt;(name),</span><br><span class="line">          soa.Decode&lt;mirror::ObjectArray&lt;mirror::Class&gt;&gt;(args)));</span><br><span class="line">  <span class="keyword">if</span> (result == nullptr || ShouldBlockAccessToMember(result-&gt;GetArtMethod(), soa.Self())) &#123;</span><br><span class="line">    <span class="keyword">return</span> nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> soa.AddLocalReference&lt;jobject&gt;(result.Get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意那个 <strong>ShouldBlockAccessToMember</strong> 调用了吗？如果它返回false，那么直接返回<code>nullptr</code>，上层就会抛 <code>NoSuchMethodXXX</code> 异常；也就触发系统的限制了。于是我们继续跟踪这个方法，这个方法的实现在 <a href="https://android.googlesource.com/platform/art/+/master/runtime/native/java_lang_Class.cc" target="_blank" rel="external">java_lang_Class.cc</a>，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ALWAYS_INLINE <span class="keyword">static</span> bool <span class="title">ShouldBlockAccessToMember</span><span class="params">(T* member, Thread* self)</span></span><br><span class="line">    <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  hiddenapi::Action action = hiddenapi::GetMemberAction(</span><br><span class="line">      member, self, IsCallerTrusted, hiddenapi::kReflection);</span><br><span class="line">  <span class="keyword">if</span> (action != hiddenapi::kAllow) &#123;</span><br><span class="line">    hiddenapi::NotifyHiddenApiListener(member);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> action == hiddenapi::kDeny;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>毫无疑问，我们应该继续看 <a href="https://android.googlesource.com/platform/art/+/master/runtime/hidden_api.cc" target="_blank" rel="external">hidden_api.cc</a> 里面的 <code>GetMemberAction</code>方法 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="function">inline Action <span class="title">GetMemberAction</span><span class="params">(T* member,</span><br><span class="line">                              Thread* self,</span><br><span class="line">                              std::function&lt;bool(Thread*)</span>&gt; fn_caller_is_trusted,</span><br><span class="line">                              AccessMethod access_method)</span><br><span class="line">    <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  DCHECK(member != nullptr);</span><br><span class="line">  <span class="comment">// Decode hidden API access flags.</span></span><br><span class="line">  <span class="comment">// NB Multiple threads might try to access (and overwrite) these simultaneously,</span></span><br><span class="line">  <span class="comment">// causing a race. We only do that if access has not been denied, so the race</span></span><br><span class="line">  <span class="comment">// cannot change Java semantics. We should, however, decode the access flags</span></span><br><span class="line">  <span class="comment">// once and use it throughout this function, otherwise we may get inconsistent</span></span><br><span class="line">  <span class="comment">// results, e.g. print whitelist warnings (b/78327881).</span></span><br><span class="line">  HiddenApiAccessFlags::ApiList api_list = member-&gt;GetHiddenApiAccessFlags();</span><br><span class="line">  Action action = GetActionFromAccessFlags(member-&gt;GetHiddenApiAccessFlags());</span><br><span class="line">  <span class="keyword">if</span> (action == kAllow) &#123;</span><br><span class="line">    <span class="comment">// Nothing to do.</span></span><br><span class="line">    <span class="keyword">return</span> action;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Member is hidden. Invoke `fn_caller_in_platform` and find the origin of the access.</span></span><br><span class="line">  <span class="comment">// This can be *very* expensive. Save it for last.</span></span><br><span class="line">  <span class="keyword">if</span> (fn_caller_is_trusted(self)) &#123;</span><br><span class="line">    <span class="comment">// Caller is trusted. Exit.</span></span><br><span class="line">    <span class="keyword">return</span> kAllow;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Member is hidden and caller is not in the platform.</span></span><br><span class="line">  <span class="keyword">return</span> detail::GetMemberActionImpl(member, api_list, action, access_method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，关键来了。此方法有三个return语句，如果我们能干涉这几个语句的返回值，那么就能影响到系统对隐藏API的判断；进而欺骗系统，绕过限制。</p>
<h2 id="应对之策">应对之策</h2><p>在分析这三个条件之前，我们再思考一下，在调用一个方法/获取一个成员的时候，除了反射(JNI也算)就没有别的办法了吗？看起来系统只是把反射这条路堵死了，那如果我不走这条路呢？</p>
<p>首先，很显然，除了反射，我们还能直接调用。打个比方，我们要调用 ActivityThread.currentActivityThread()这个方法，除了使用反射；我们还可以把 Android 源码中的 ActivityThread 这个类copy到我们的项目中，然后使用 provided 依赖，这样就能像系统一样直接调用了。至此，我们得到了第一个信息：public类的public方法，可以通过直接调用的方式访问；当然，private的就都不行了。</p>
<p>其次，我们要访问一个类的成员，除了直接访问，反射调用/JNI就没有别的方法了吗？当然不是。如果你了解ART的实现原理，知道对象布局，那么这个问题就太简单了。所有的Java对象在内存中其实就是一个结构体，这份内存在 native 层和Java层是对应的，因此如果我们拿到这份内存的头指针，<strong>直接通过偏移量就能访问成员</strong>。你问我方法怎么访问？ART的对象模型采用的类似Java的 klass-oop方式，方法是存储在 <code>java.lang.Class</code>对象中的，它们是<strong>Class对象的成员</strong>，因此访问方法最终就是访问成员。（后续我会专门介绍ART的对象模型，解释 ArtMethod/java.lang.Method/jmethodId之间的关系）。</p>
<p>思考完毕，我们会到反射调用的流程；仔细分析一下这三个条件。</p>
<h3 id="第一个条件">第一个条件</h3><p>先看第一个return语句，<code>GetActionFromAccessFlags</code>，看方法名貌似是根据 Method/Field 的 <code>access_flag</code> 来判断，具体看下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">inline Action <span class="title">GetActionFromAccessFlags</span><span class="params">(HiddenApiAccessFlags::ApiList api_list)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (api_list == HiddenApiAccessFlags::kWhitelist) &#123;</span><br><span class="line">    <span class="keyword">return</span> kAllow;</span><br><span class="line">  &#125;</span><br><span class="line">  EnforcementPolicy policy = Runtime::Current()-&gt;GetHiddenApiEnforcementPolicy();</span><br><span class="line">  <span class="keyword">if</span> (policy == EnforcementPolicy::kNoChecks) &#123;</span><br><span class="line">    <span class="comment">// Exit early. Nothing to enforce.</span></span><br><span class="line">    <span class="keyword">return</span> kAllow;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if policy is "just warn", always warn. We returned above for whitelist APIs.</span></span><br><span class="line">  <span class="keyword">if</span> (policy == EnforcementPolicy::kJustWarn) &#123;</span><br><span class="line">    <span class="keyword">return</span> kAllowButWarn;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 略。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，如果 Method/Field 是白名单，那么直接允许访问。我们再往前看，发现这个 <code>api_list</code> 其实是存储在 Method/Field 的 <code>access_flag</code>中的。</p>
<p>也就是说，所有的Method/Field的access_flag 中存储了hidden_api 的信息，如果有办法把这个flag直接设置为 kAllow，那么系统就认为它不是隐藏API了。但是，如果要修改 Method/Field 的 <code>access_flag</code>这个成员变量，我们首先得拿到这个 Method/Field 的引用，然而 Android P上就是限制了我们拿这个引用的过程，似乎死循环了；前面我们提到可以通过偏移量的方式修改，但实际上这个场景还有别限制（比如压根拿不到Class对象）；因此这个条件看似可以达到，实际上比较麻烦，于是我们暂且放下。</p>
<p>继续观察这个方法，接下来 调用了 <code>GetHiddenApiEnforcementPolicy</code> 方法获取限制策略，如果是 <code>kNoChecks</code> 直接允许；那 GetHiddenApiEnforcementPolicy 这个方法是啥样呢？在 <a href="https://android.googlesource.com/platform/art/+/master/runtime/runtime.h" target="_blank" rel="external">runtime.h</a> 中，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hiddenapi::<span class="function">EnforcementPolicy <span class="title">GetHiddenApiEnforcementPolicy</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hidden_api_policy_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，返回的是 runtime 这个对象的一个成员。<strong>如果我们直接修改内存，把这个成员设置为 kNoChecks</strong>，那么不就达到目标了吗？</p>
<h4 id="获取runtime指针">获取runtime指针</h4><p>既然需要修改runtime对象的内存，那么首先得拿到runtime对象的指针。本来这个过程需要去分析 ART runtime的启动过程，但如果完全写出来那就又是几篇文章了；这里直接给出结论：</p>
<p>在JNI中，我们可以通过 JNIEnv指针拿到 JavaVM指针，这个JavaVM指针实际上是一个 <code>JavaVMExt</code>对象，runtime是 JavaVMExt结构体的成员。说起来比较绕，实际上你看看代码就明白了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JavaVM *javaVM;</span><br><span class="line">env-&gt;GetJavaVM(&amp;javaVM);</span><br><span class="line">JavaVMExt *javaVMExt = (JavaVMExt *) javaVM;</span><br><span class="line"><span class="keyword">void</span> *runtime = javaVMExt-&gt;runtime;</span><br></pre></td></tr></table></figure>
<p>感兴趣的可以自己去分析为什么可以这么做。</p>
<h4 id="搜索内存">搜索内存</h4><p>我们已经拿到了 runtime指针，也就是这个对象的起始位置；如果要修改对象的成员，必须要知道偏移量。如何知道这个偏移量呢？直接硬编码写死也是可行的，但是一旦厂商做一点修改，那就完蛋了；你程序的结果就没法预期。因此，我们采用一种<strong>动态搜索</strong>的办法。</p>
<p>runtime是一个很大的结构体，里面的成员不计其数；如果我们要精准定位里面的某一个成员，需要找一些参照物；然后通过这些参照物进一步定位。我们先来观察一下这个结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Runtime &#123;</span><br><span class="line">	<span class="comment">// 64 bit so that we can share the same asm offsets for both 32 and 64 bits.</span></span><br><span class="line">	<span class="keyword">uint64_t</span> callee_save_methods_[kCalleeSaveSize];</span><br><span class="line">	<span class="comment">// Pre-allocated exceptions (see Runtime::Init).</span></span><br><span class="line">	GcRoot&lt;mirror::Throwable&gt; pre_allocated_OutOfMemoryError_when_throwing_exception_;</span><br><span class="line">	GcRoot&lt;mirror::Throwable&gt; pre_allocated_OutOfMemoryError_when_throwing_oome_;</span><br><span class="line">	GcRoot&lt;mirror::Throwable&gt; pre_allocated_OutOfMemoryError_when_handling_stack_overflow_;</span><br><span class="line">	GcRoot&lt;mirror::Throwable&gt; pre_allocated_NoClassDefFoundError_;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... （省略大量成员)</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::unique_ptr&lt;JavaVMExt&gt; java_vm_;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... （省略大量成员)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Specifies target SDK version to allow workarounds for certain API levels.</span></span><br><span class="line">  	<span class="keyword">int32_t</span> target_sdk_version_;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// ... （省略大量成员)</span></span><br><span class="line"></span><br><span class="line">		  <span class="keyword">bool</span> is_low_memory_mode_;</span><br><span class="line">	<span class="comment">// Whether or not we use MADV_RANDOM on files that are thought to have random access patterns.</span></span><br><span class="line">	<span class="comment">// This is beneficial for low RAM devices since it reduces page cache thrashing.</span></span><br><span class="line">	<span class="keyword">bool</span> madvise_random_access_;</span><br><span class="line">	<span class="comment">// Whether the application should run in safe mode, that is, interpreter only.</span></span><br><span class="line">	<span class="keyword">bool</span> safe_mode_;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... （省略大量成员)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构体非常大，可以直接去看源码 <a href="https://android.googlesource.com/platform/art/+/master/runtime/runtime.cc" target="_blank" rel="external">runtime.h</a>，上面我们挑出了一些我们能够使用的参照物，辅助进行内存定位：</p>
<ul>
<li>java<em>vm</em> ：我们很熟悉的JavaVM对象，上面我们已经通过 JNIEnv 获取了，是个已知值。</li>
<li>target_sdk_version: 这个是我们APP的 targetSdkVersion，我们可以提前知道。</li>
<li>safe_mode：safe_mode 是 AndroidManifest 中的配置，已知值。</li>
</ul>
<p>因此结合这三个条件，我们对runtime指针执行线性搜索，首先找到 JavaVM指针，然后找到target_sdk_version，最后直达目标；顺便用 safe_mode, java_debuggable 等成员验证正确性。</p>
<p>找到目标 <code>hidden_api_policy_</code>之后，直接修改内存，就能达到目的。用伪代码表示就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">nt <span class="title">unseal</span><span class="params">(JNIEnv *env, jint targetSdkVersion)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    JavaVM *javaVM;</span><br><span class="line">    env-&gt;GetJavaVM(&amp;javaVM);</span><br><span class="line">    JavaVMExt *javaVMExt = (JavaVMExt *) javaVM;</span><br><span class="line">    <span class="keyword">void</span> *runtime = javaVMExt-&gt;runtime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">int</span> offsetOfVmExt = findOffset(runtime, <span class="number">0</span>, MAX, (<span class="keyword">size_t</span>) javaVMExt);</span><br><span class="line">    <span class="keyword">int</span> targetSdkVersionOffset = findOffset(runtime, offsetOfVmExt, MAX, targetSdkVersion);</span><br><span class="line">    PartialRuntime *partialRuntime = (PartialRuntime *) ((<span class="keyword">char</span> *) runtime + targetSdkVersionOffset);</span><br><span class="line">    EnforcementPolicy policy = partialRuntime-&gt;hidden_api_policy_;</span><br><span class="line">    partialRuntime-&gt;hidden_api_policy_ = EnforcementPolicy::kNoChecks;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码我已经放到 github 上了：<a href="https://github.com/tiann/FreeReflection" target="_blank" rel="external">FreeReflection</a>，使用起来非常简单，添加依赖；一步调用即可。觉得好用别忘了 star 哦～</p>
<p>看起来我们已经达到目标了，但是不要慌；还有2个条件呢，我们继续，说不定有新发现。</p>
<h3 id="第二个条件">第二个条件</h3><p>然后看第二个return语句，<code>fn_caller_is_trusted</code>，这里面的代码我就不分析了，直接给结论：这个方法通过回溯调用栈，通过调用者的Class来判断是否是系统代码的调用（所有系统的代码都通过BootClassLoader加载，判断ClassLoader即可），如果是系统代码，那么就允许调用（系统自己的API肯定得让它调）。这里我们又发现一个判断条件：<code>caller.classloader == BootClassLoader</code>。因此，如果能把这个调用类的ClassLoader修改为 BootClassLoader，那么问题不就解决了吗？</p>
<p>那么问题来了，如何修改Class的classloader？我们看看Class 类的结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,</span><br><span class="line">                              <span class="title">GenericDeclaration</span>,</span><br><span class="line">                              <span class="title">Type</span>,</span><br><span class="line">                              <span class="title">AnnotatedElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** defining class loader, or null for the "bootstrap" system loader. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ClassLoader classLoader;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 略 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>classloader实际上是Class类的第一个成员，而这个<code>java.lang.Class</code>我们肯定是能拿到的，因此我们可以通过上面提到的<strong>修改偏移的方式直接修改ClassLoader</strong>，进而绕过限制。</p>
<p>但是需要注意一下这个偏移量。虽然 Class 声明没有继承任何东西，但实际上它继承自 Object。我们看下 <code>java.lang.Object</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Class&lt;?&gt; shadow$_klass_;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> shadow$_monitor_;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，Class对象在内存中实际上是这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Class &#123;</span><br><span class="line">    Class&lt;?&gt; shadow$_klass_;</span><br><span class="line">    <span class="keyword">int</span> shadow$_monitor_;</span><br><span class="line">    ClassLoader classLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JVM规范中，一个int占4字节；在ART实现中，一个Java对象的引用占用4字节（不论是32位还是64位），因此 <strong>classloader的偏移量为8</strong>；我们拿到调用者的Class对象，在JNI层拿到对象的内存表示，直接把偏移量为8处置空（BootClassLoader在为null）即可。当然，如果你不想用JNI，Unsafe也能满足这个需求。</p>
<p>看起来我们已经有好几种办法达到目的了，别着急；我们继续看第三个条件。</p>
<h3 id="第三个条件">第三个条件</h3><p>当代码流程走到这里，那个action已经不可能是 kAllow了；不要放弃治疗，说不定还能复活。观察代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldWarn || action == kDeny) &#123;</span><br><span class="line">    <span class="keyword">if</span> (member_signature.IsExempted(runtime-&gt;GetHiddenApiExemptions())) &#123;</span><br><span class="line">      action = kAllow;</span><br><span class="line">      <span class="comment">// Avoid re-examining the exemption list next time.</span></span><br><span class="line">      <span class="comment">// Note this results in no warning for the member, which seems like what one would expect.</span></span><br><span class="line">      <span class="comment">// Exemptions effectively adds new members to the whitelist.</span></span><br><span class="line">      MaybeWhitelistMember(runtime, member);</span><br><span class="line">      <span class="keyword">return</span> kAllow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 略    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>果然有“豁免”条件：GetHiddenApiExemptions()。跟踪这个方法之后，你会发现解决办法跟上面两种是一样的。要么去修改 runtime 的内存，要么修改signature；我就不赘述啦。</p>
<h3 id="剑走偏锋">剑走偏锋</h3><p>上面我们分析了系统的源代码，结合各种条件来实现绕过对非SDK API调用的检测；但实际上所有这些方式我们的目的都是一样的—— <strong>通过某种方式修改函数的执行流程</strong>；而达到这个目标最直接的方法就是 <strong>inline hook</strong>！！由于inline hook太强大，你只需要找到一个关键的执行流程，hook其中的某个函数，修改他的返回值就OK了；这里我也没啥好分析的，只能给大家推荐一个 inline hook 库了，名字叫 <a href="https://github.com/jmpews/HookZz" target="_blank" rel="external">HookZz</a>，代码非常优秀，值得一看。</p>
<h2 id="后记">后记</h2><p>本来真的只是打算介绍那个简单方法的，结果一不小心全写完啦 ：）</p>
<p>文章可能有疏漏，也可能有更优秀的办法；欢迎交流讨论～</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>众所周知，Android P 引入了<a href="https://developer.android.com/preview/restrictions-non-sdk-interfaces?hl=zh-cn">针对非 SDK 接口（俗称为隐藏API）的使用限制</a>。这是继 Android N上<a href="https://developer.android.com/about/versions/nougat/android-7.0-changes?hl=zh-cn">针对 NDK 中私有库的链接限制</a>之后的又一次重大调整。从今以后，不论是native层的NDK还是 Java层的SDK，我们只能使用Google提供的、公开的标准接口。这对开发者以及用户乃至整个Android生态，当然是一件好事。但这也同时意味着Android上的各种黑科技有可能会逐渐走向消亡。</p>
<p>作为一个有追求的开发者，我们既要尊重并遵守规则，也要有能力在必要的时候突破规则的束缚，带着镣铐跳舞。恰好最近有人反馈 <a href="https://github.com/android-hacker/VirtualXposed/issues/115">VirtualXposed 在 Android P上无法运行</a>，那么今天就来探讨一下，如何突破Android P上针对非SDK接口调用的限制。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="hook" scheme="http://weishu.me/tags/hook/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[无需Root也能使用Xposed！]]></title>
    <link href="http://weishu.me/2017/12/02/non-root-xposed/"/>
    <id>http://weishu.me/2017/12/02/non-root-xposed/</id>
    <published>2017-12-01T20:12:59.000Z</published>
    <updated>2019-01-30T04:06:02.844Z</updated>
    <content type="html"><![CDATA[<p>Xposed是Android系统上久负盛名的一个框架，它给了普通用户任意 DIY 系统的能力；比如典型的微信防撤回、自动抢红包、修改主题字体，以及模拟位置等等等等。不过，使用Xposed的前提条件之一就是需要Root。随着Android系统的演进，这一条件达成越来越难了；那么，<strong>能不能不用Root就可以享用Xposed的功能呢？</strong></p>
<p>我们想一下，Xposed为什么需要Root？从现在的实现来看，因为Xposed需要修改系统文件，而这些文件只有root权限才能修改；但是这只是当前实现的特性（修改系统分区文件），而非根本原因。Xposed要实现的最终目的是在任意App进程启动之前能任意加载 <strong>特定Xposed模块</strong> 的代码；这些特定的Xposed模块中能在App进程启动之前有机会执行特定代码，从而控制任意进程的行为。归根结底，Xposed需要控制别的进程，而没有高级权限（Root），越俎代庖是不行的。</p>
<p>有没有别的实现方式？</p>
<a id="more"></a>
<p>虽然没有办法控制别的进程，但是在本进程内，几乎是可以为所欲为的；如果换个方式，<strong>把别的App放在自己的进程里面运行，然后Hook自己</strong> 不就打到目的了嘛？「把别的App放在自己的进程里面运行」这种机制是容器，或者通俗点叫双开；「Hook自己」这是典型的Dexposed的思路，不过Dexposed不支持ART——但前不久 epic 的出现完成了这最后一块拼图。（关于epic在ART上实现AOP Hook可以参考 <a href="http://weishu.me/2017/11/23/dexposed-on-art/">我为Dexposed续一秒——论ART上运行时 Method AOP实现</a></p>
<p>双开的典型实现是lody的 <a href="https://github.com/asLody/VirtualApp" target="_blank" rel="external">VirtualApp</a>，那么我们来一看 <code>VirtualApp</code> 与 <code>epic</code> 结合会产生什么样奇妙的化学反应。</p>
<p>我们的思路很清晰：用 VirtualApp 去启动别的App，在启动过程中通过 epic Hook本进程，从而控制被启动的App。同时，由于Xposed模块已经比较成熟，而且有成千上万的插件生态，最好能够直接复用Xposed 的模块，使得在双开环境下，Xposed模块就跟运行在Root手机中的Xposed环境中一样。为此，我写了一个 双开环境下的Xposed兼容层：<a href="https://github.com/android-hacker/exposed" target="_blank" rel="external">Exposed</a>；同时，修改了 VirtualApp 的部分实现，使得它能够在进程的启动的时候加载 Exposed 这个兼容层，代码在这：<a href="https://github.com/android-hacker/VAExposed" target="_blank" rel="external">VAExposed</a>。这样，在双开环境中，可以直接加载已有的Xposed模块进而实现非Root模式下的Xposed的功能。更有趣的是，你还可以直接使用 XposedInstaller 安装和管理任意的Xposed模块，就跟你使用真正的Xposed一样！</p>
<p>具体的代码就不详细讲了，可以直接去看源码<a href="https://github.com/android-hacker/exposed" target="_blank" rel="external">Exposed</a>，<a href="https://github.com/android-hacker/VAExposed" target="_blank" rel="external">VAExposed</a> 我们以微信防撤回为例，看看具体的效果：</p>
<p>首先安装VAExposed这个修改版的双开APK，你可以clone源码直接build，也可以使用我编译好的版本 <a href="https://raw.githubusercontent.com/android-hacker/VAExposed/master/VirtualApp/VAExposed_0.1.5.apk" target="_blank" rel="external">Github下载</a> 百度网盘: <a href="https://pan.baidu.com/s/1qXB9qtY" target="_blank" rel="external">https://pan.baidu.com/s/1qXB9qtY</a> 密码: i45e</p>
<p>然后安装微信防撤回模块：微信巫师，发布的主页在这：<a href="http://xposed.appkg.com/2558.html" target="_blank" rel="external">WeChat Magician（微信巫师）</a>；直接下载 <a href="http://dl-xda.xposed.info/modules/com.gh0u1l5.wechatmagician_v30_1387ce.apk" target="_blank" rel="external">链接</a></p>
<p>接下来需要确保你手机上的微信是微信巫师所支持的，目前支持微信的版本为 6.5.8~6.5.16；如果不是的话需要去下载一个支持的版本，比如 <a href="https://down.shouji.com.cn/wap/wdown/softversion?id=188561&amp;package=com.tencent.mm" target="_blank" rel="external">微信_6.5.8.apk</a>。</p>
<p>最后，你需要打开VAExposed这个双开软件，添加微信和微信巫师为双开模块，如下图：</p>
<p><img src="http://weishu.dimensionalzone.com/201605/1512158544505.png" width="180px"></p>
<p>这样，使用双开中的微信，就能享受Xposed模块的防撤回功能了！</p>
<p><img src="http://weishu.dimensionalzone.com/201605/1512158469933.png" width="180px"></p>
<p>另外，你还可以直接在双开中使用 XposedInstaller，然后就可以方便滴下载和管理Xposed模块了：</p>
<p><img src="http://weishu.dimensionalzone.com/201605/1512158377339.png" width="180px"><br><img src="http://weishu.dimensionalzone.com/201605/1512158575155.png" width="180px"><br><img src="http://weishu.dimensionalzone.com/201605/1512158598212.png" width="180px"></p>
<p>就这样，我们在非Root手机下，就能享用Xposed模块的功能，Have Fun ：）</p>
<p>不过，在实现完这个功能之后，我不寒而栗：千万不要在Root环境或者双开环境下运行关键App，不然你的微信登录密码，支付宝支付密码，银行卡账号，很有可能被尽收眼底。</p>
<p>PS：目前 Exposed 层的实现处于初级阶段，个人精力非常有限（一般都是凌晨写代码）；如果你对 <strong>实现非Root模式下的Xposed</strong> 感兴趣，非常欢迎跟我一起组队 :) 项目地址在这：<a href="https://github.com/android-hacker/exposed。" target="_blank" rel="external">https://github.com/android-hacker/exposed。</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Xposed是Android系统上久负盛名的一个框架，它给了普通用户任意 DIY 系统的能力；比如典型的微信防撤回、自动抢红包、修改主题字体，以及模拟位置等等等等。不过，使用Xposed的前提条件之一就是需要Root。随着Android系统的演进，这一条件达成越来越难了；那么，<strong>能不能不用Root就可以享用Xposed的功能呢？</strong></p>
<p>我们想一下，Xposed为什么需要Root？从现在的实现来看，因为Xposed需要修改系统文件，而这些文件只有root权限才能修改；但是这只是当前实现的特性（修改系统分区文件），而非根本原因。Xposed要实现的最终目的是在任意App进程启动之前能任意加载 <strong>特定Xposed模块</strong> 的代码；这些特定的Xposed模块中能在App进程启动之前有机会执行特定代码，从而控制任意进程的行为。归根结底，Xposed需要控制别的进程，而没有高级权限（Root），越俎代庖是不行的。</p>
<p>有没有别的实现方式？</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="epic" scheme="http://weishu.me/tags/epic/"/>
    
      <category term="root" scheme="http://weishu.me/tags/root/"/>
    
      <category term="xposed" scheme="http://weishu.me/tags/xposed/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我为Dexposed续一秒——论ART上运行时 Method AOP实现]]></title>
    <link href="http://weishu.me/2017/11/23/dexposed-on-art/"/>
    <id>http://weishu.me/2017/11/23/dexposed-on-art/</id>
    <published>2017-11-22T17:30:10.000Z</published>
    <updated>2019-01-30T04:06:02.836Z</updated>
    <content type="html"><![CDATA[<p>两年前阿里开源了<a href="https://github.com/alibaba/dexposed" target="_blank" rel="external">Dexposed</a> 项目，它能够在Dalvik上无侵入地实现运行时方法拦截，正如其介绍「enable ‘god’ mode for single android application」所言，能在非root情况下掌控自己进程空间内的任意Java方法调用，给我们带来了很大的想象空间。比如能实现运行时AOP，在线热修复，做性能分析工具（拦截线程、IO等资源的创建和销毁）等等。然而，随着ART取代Dalvik成为Android的运行时，一切都似乎戛然而止。</p>
<p>今天，我在ART上重新实现了Dexposed，在它能支持的平台（Android 5.0 ~ 7.1 Thumb2/ARM64)上，有着与Dexposed完全相同的能力和API；项目地址在这里 <a href="https://github.com/tiann/epic" target="_blank" rel="external">epic</a>，感兴趣的可以先试用下:) 然后我们聊一聊ART上运行时Method AOP的故事。</p>
<a id="more"></a>
<h2 id="ART有什么特别的？">ART有什么特别的？</h2><p>为什么Dexposed能够在Dalvik上为所欲为，到ART时代就不行了呢？排除其他非技术因素来讲，ART确实比Dalvik复杂太多；更要命的是，从Android L到Android O，每一个Android版本中的ART变化都是天翻地覆的，大致列举一下：</p>
<ul>
<li>Android L(5.0/5.1) 上的ART是在Dalvik上的JIT编译器魔改过来的，名为quick（虽然有个portable编译器，但是从未启用过）；这个编译器会做一定程度的方法内联，因此很多基于入口替换的Hook方式一上来就跪了。</li>
<li>Android M(6.0) 上的ART编译器完全重新实现了：Optimizing。且不说之前在Android L上的Hook实现要在M上重新做一遍，这个编译器的寄存器分配比quick好太多，结果就是hook实现的时候你要是乱在栈或者寄存器上放东西，代码很容易就跑飞。 </li>
<li>Android N(7.0/7.1) N 开始采用了混合编译的方式，既有AOT也有JIT，还伴随着解释执行；混合模式对Hook影响是巨大的，以至于<a href="https://www.xda-developers.com/official-xposed-framework-android-nougat/" target="_blank" rel="external">Xposed直到今年才正式支持Android N</a>。首先JIT的出现导致方法入口不固定，跑着跑着入口就变了，更麻烦的是还会有OSR（栈上替换），不仅入口变了，正在运行时方法的汇编代码都可能发生变化；其次，JIT的引入带来了更深度的运行时方法内联，这些都使得虚拟机层面的Hook更为复杂。</li>
<li>Android O(8.0) Android O的Runtime做了很多优化，传统Java VM有的一些优化手段都已经实现，比如类层次分析，循环优化，向量化等；除此之外，DexCache被删除，跨dex方法内联以及Concurrent compacting GC的引入，使得Hook技术变的扑朔迷离。</li>
</ul>
<p>可以看出，ART不仅复杂，而且还爱折腾；一言不合就魔改，甚至重写。再加上Android的碎片化，这使得实现一个稳定的虚拟机层面上运行时Java Method AOP几无可能。</p>
<p>说到这里也许你会问，那substrate，frida等hook机制不是挺成熟了吗？跟这里说的ART Hook有什么联系与区别？事实上，substrate/frida 主要处理native层面的Hook，可以实现任意C/C++ 函数甚至地址处的调用拦截；而ART Java Method Hook/AOP 更多地是在虚拟机层面，用来Hook和拦截Java方法，虚拟机层面的Hook底层会使用于substrate等类似的Hook技术，但是还要处理虚拟机独有的特点，如GC/JNI/JIT等。</p>
<h2 id="已有的一些方案">已有的一些方案</h2><p>虽然ART上的运行时Java Method AOP实现较为困难，但还是有很多先驱者和探索者。最有名的莫过于AndFix（虽然它不能实现AOP）；在学术界，还有两篇研究ART Hook的论文，一篇实现了Callee side dynamic rewrite，另一篇基于虚函数调用原理实现了vtable hook。另外，除了在讲epic之前，我们先看看这些已有的方案。</p>
<p>首先简单介绍下ART上的方法调用原理（本文不讨论解释模式，所有entrypoint均指compiled_code_entry_point)。在ART中，每一个Java方法在虚拟机（注：ART与虚拟机虽有细微差别，但本文不作区分，两者含义相同，下同）内部都由一个ArtMethod对象表示（native层，实际上是一个C++对象），这个native 的 ArtMethod对象包含了此Java方法的所有信息，比如名字，参数类型，方法本身代码的入口地址（entrypoint)等；暂时放下trampoline以及interpreter和jit不谈，一个Java方法的执行非常简单：</p>
<ol>
<li>想办法拿到这个Java方法所代表的ArtMethod对象</li>
<li>取出其entrypoint，然后跳转到此处开始执行</li>
</ol>
<p><img src="http://weishu.dimensionalzone.com/201605/1511369316918.png" alt=""></p>
<h3 id="entrypoint_replacement">entrypoint replacement</h3><p>从上面讲述的ART方法调用原理可以得到一种很自然的Hook办法————直接替换entrypoint。通过把原方法对应的ArtMethod对象的entrypoint替换为目标方法的entrypoint，可以使得原方法被调用过程中取entrypoint的时候拿到的是目标方法的entry，进而直接跳转到目标方法的code段；从而达到Hook的目的。</p>
<p>AndFix就是基于这个原理来做热修复的，<a href="https://yq.aliyun.com/articles/74598?t=t1#" target="_blank" rel="external">Sophix</a> 对这个方案做了一些改进，也即整体替换，不过原理上都一样。二者在替换方法之后把原方法直接丢弃，因此无法实现AOP。<a href="https://github.com/panhongwei/AndroidMethodHook" target="_blank" rel="external">AndroidMethodHook</a> 基于Sophix的原理，用dexmaker动态生成类，将原方法保存下来，从而实现了AOP。</p>
<p>不过这种方案能够生效有一个前提：方法调用必须是先拿到ArtMethod，再去取entrypoint然后跳转实现调用。但是很多情况下，第一步是不必要的；系统知道你要调用的这个方法的entrypoint是什么，直接写死在汇编代码里，这样方法调用的时候就不会有取ArtMethod这个动作，从而不会去拿被替换的entrypoint，导致Hook失效。这种调用很典型的例子就是系统函数，我们看一下Android 5.0上 调用<code>TextView.setText(Charsequence)</code> 这个函数的汇编代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callSetText</span><span class="params">(TextView textView)</span> </span>&#123;</span><br><span class="line">    textView.setText(<span class="string">"hehe"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OAT文件中的汇编代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00037e10: e92d40e0&#9;push    &#123;r5, r6, r7, lr&#125;&#10;0x00037e14: b088    &#9;sub     sp, sp, #32&#10;0x00037e16: 1c07    &#9;mov     r7, r0&#10;0x00037e18: 9000    &#9;str     r0, [sp, #0]&#10;0x00037e1a: 910d    &#9;str     r1, [sp, #52]&#10;0x00037e1c: 1c16    &#9;mov     r6, r2&#10;0x00037e1e: 6978    &#9;ldr     r0, [r7, #20]&#10;0x00037e20: f8d00ef0&#9;ldr.w   r0, [r0, #3824]&#10;0x00037e24: b198    &#9;cbz     r0, +38 (0x00037e4e)&#10;0x00037e26: 1c05    &#9;mov     r5, r0&#10;0x00037e28: f24a6e29&#9;movw    lr, #42537&#10;0x00037e2c: f2c73e87&#9;movt    lr, #29575&#10;0x00037e30: f24560b0&#9;movw    r0, #22192&#10;0x00037e34: f6c670b4&#9;movt    r0, #28596&#10;0x00037e38: 1c31    &#9;mov     r1, r6&#10;0x00037e3a: 1c2a    &#9;mov     r2, r5&#10;0x00037e3c: f8d1c000&#9;ldr.w   r12, [r1, #0]&#10;suspend point dex PC: 0x0002&#10;GC map objects:  v0 (r5), v1 ([sp + #52]), v2 (r6)&#10;0x00037e40: 47f0    &#9;blx     lr</span><br></pre></td></tr></table></figure>
<p>看这两句代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00037e28: f24a6e29&#9;movw    lr, #42537&#10;0x00037e2c: f2c73e87&#9;movt    lr, #29575</span><br></pre></td></tr></table></figure>
<p>什么意思呢？lr = 0x7387a629，然后接着就blx跳转过去了。事实上，这个地址 <code>0x7387a629</code> 就是TextView.setText(Charsequence)` 这个方法entrypoint的绝对地址；我们可以把系统编译好的oat代码弄出来看一看：</p>
<blockquote>
<p>adb shell oatdump –oat-file=/data/dalvik-cache/arm/system@framework@boot.oat</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">364</span>: <span class="keyword">void</span> android.widget.TextView.setText(java.lang.CharSequence) (dex_method_idx=<span class="number">28117</span>)</span><br><span class="line">  <span class="comment">// 略掉无关内容</span></span><br><span class="line">  QuickMethodFrameInfo</span><br><span class="line">    frame_size_in_bytes: <span class="number">48</span></span><br><span class="line">    core_spill_mask: <span class="number">0x000081e0</span> (r5, r6, r7, r8, r15)</span><br><span class="line">    fp_spill_mask: <span class="number">0x00000000</span></span><br><span class="line">  CODE: (code_offset=<span class="number">0x037d8629</span> size_offset=<span class="number">0x037d8624</span> size=<span class="number">64</span>).</span><br></pre></td></tr></table></figure>
<p>其中这个方法的code_offset = 0x037d8629; boot.oat的EXECUTABLE OFFSET 为0x02776000, boot.oat 在proc/<pid>/maps 中的基址如下：</pid></p>
<figure class="highlight"><figcaption><span>rw-p 00000000 103:1f 32773</span><a href="/data/dalvik-cache/arm/system@framework@boot.art">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">700a1000-72818000 r--p 00000000 103:1f 32772     /data/dalvik-cache/arm/system@framework@boot.oat&#10;72818000-74689000 r-xp 02777000 103:1f 32772     /data/dalvik-cache/arm/system@framework@boot.oat&#10;74689000-7468a000 rw-p 045e8000 103:1f 32772     /data/dalvik-cache/arm/system@framework@boot.oat</span><br></pre></td></tr></table></figure>
<p>其中 可执行段的地址为 0x72818000，因此算出来的 TextView.setText(CharSequence) 这个方法的地址为 <code>0x037d8629 - 0x02776000 + 0x72818000 = 0x7387a629</code>；丝毫不差。</p>
<p>为什么会这么干呢？因为boot.oat 这个文件在内存中的加载地址是固定的（如果发生变化，所有APP的oat文件会重新生成，于是又重新固定），因此里面的每一个函数的绝对地址也是固定的，如果你调用系统函数，ART编译器知道系统每一个函数入口的绝对地址，根本没有必要再去查找方法，因此生成的代码中没有任何查找过程。</p>
<p>所以，从原理上讲，如果要支持系统方法的Hook，这种方案在很多情况下是行不通的。当然如果你Hook自己App的代码，并且调用方和被调用方在不同的dex，在Android O之前是没什么问题的（在Android O之前跨dex一定会走方法查找）。</p>
<p>从上面的分析可以看出，就算不查找ArtMethod，这个ArtMethod的enntrypoint所指向代码是一定要用到的（废话，不然CPU执行什么，解释执行在暂不讨论）。既然替换入口的方式无法达到Hook所有类型方法的目的，那么如果不替换入口，而是直接修改入口里面指向的代码呢？（这种方式有个高大上的学名：callee side dynamic rewriting) </p>
<h3 id="dynamic_callee-side_rewriting">dynamic callee-side rewriting</h3><p>第一次学到这个词是在 Wißfeld, Marvin 的论文 <a href="http://publications.cispa.saarland/143/" target="_blank" rel="external">ArtHook: Callee-side Method Hook Injection on the New Android Runtime ART</a>上。这篇文章很精彩，讲述了各种Hook的原理，并且他还在ART上实现了 dynamic callee-side rewriting 的Hook技术，代码在github上：<a href="https://github.com/mar-v-in/ArtHook" target="_blank" rel="external">ArtHook</a></p>
<p>通俗地讲，dynamic callee-side rewriting其实就是修改entrypoint 所指向的代码。但是有个基本问题：Hook函数和原函数的代码长度基本上是不一样的，而且为了实现AOP，Hook函数通常比原函数长很多。如果直接把Hook函数的代码段copy到原函数entrypoint所指向的代码段，很可能没地儿放。因此，通常的做法是写一段trampoline。也就是把原函数entrypoint所指向代码的开始几个字节修改为一小段固定的代码，这段代码的唯一作用就是跳转到新的位置开始执行，如果这个「新的位置」就是Hook函数，那么基本上就实现了Hook；这种跳板代码我们一般称之为trampoline/stub，比如Android源码中的 art_quick_invoke_stub/art_quick_resolution_trampoline等。</p>
<p>这篇论文基本上指明了ART上Method Hook的方向，而且Wißfeld 本人的项目 ArtHook也差不多达到了这个目的。不过他的Hook实现中，被用来替换的方法必须写死在代码中，因此无法达到某种程度上的动态Hook。比如，我想知道所有线程的创建和销毁，因此选择拦截Thread.class 的run方法；但是Thread子类实现的run方法不一定会调用 Thread 的run，所以可能会漏掉一些线程。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do not call super</span></span><br><span class="line">        Log.i(TAG, <span class="string">"dang dang dang.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"I am started.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start(); <span class="comment">// Thread1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// super.run();</span></span><br><span class="line">        <span class="comment">// do not call super.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start(); <span class="comment">// Thread 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> MyThread().start();<span class="comment">// Thread 3</span></span><br></pre></td></tr></table></figure>
<p>上述例子中，如果仅仅Hook Thread.class 的run方法，只有 Thread1能被发现，其他两个都是漏网之鱼。既然如此，我们可以Hook线程的构造函数（子类必定调用父类），从而知道有哪些自定义的线程类被创建，然后直接Hook这些在运行时才发现的类，就能知道所有Java线程的创建和销毁。</p>
<p>要解决「不写死Hook方法」这个问题有两种思路：其一，直接在运行时凭空创建出一个Method；其二，把Hook收拢到一个统一的方法，在这个方法中做分发处理。</p>
<p>第一种方式：凭空创建Method，并非new 一个Method对象就行了，这个方法必须要有你想执行的代码，以及必要的declaring_class, dex_method_index 等成员；要达到这个目的，可以使用运行时字节码生成技术，比如 <a href="https://github.com/linkedin/dexmaker" target="_blank" rel="external">dexmaker</a>。另外，Java本身的动态代理机制也可以也会动态生成代理类，在代理类中有全新创建的方法，如果合适处理，也能达到目的；不过这种方案貌似还无人实现，反倒是entrypoint replcement中有人这么做 :(</p>
<p>第二种方式：用一个函数来处理hook的分发逻辑，这是典型的xposed/dexposed 实现方式。不过Xposed支持Android N过程中直接修改了 libart.so，这种方式对进程内Hook是行不通的。dexposed的 <a href="https://github.com/alibaba/dexposed/tree/dev_art" target="_blank" rel="external">dev_art</a> 分支有尝试过实现，但是几乎不可用。</p>
<p>有趣地是，还有另外一个项目 <a href="https://github.com/rk700/YAHFA" target="_blank" rel="external">YAHFA</a> 也提出了一种Hook方案；不过他这种方案看起来是entrypoint replacement和dynamic callee-side rewriting的结合体：把entrypoint替换为自己的trampoline函数的地址，然后在trampoline继续处理跳转逻辑。作者的<a href="http://rk700.github.io/2017/06/30/hook-on-android-n/" target="_blank" rel="external">博客</a>值得一看。</p>
<h3 id="vtable_replacement">vtable replacement</h3><p>除了传统的类inline hook 的 dynamic callee-side rewriting 的Hook方式，也有基于虚拟机特定实现的Hook技术，比如vtable hook。ART中的这种Hook方式首先是在论文 <a href="http://ceur-ws.org/Vol-1575/paper_10.pdf" target="_blank" rel="external">ARTDroid: A Virtual-Method Hooking Framework on Android ART Runtime</a> 中提出的，作者的实现代码也在github上 <a href="https://github.com/tdr130/art-hooking-vtable" target="_blank" rel="external">art-hooking-vtable</a>。</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1511342723016.png" width="340"></p>
<p>这种Hook方式是基于invoke-virtual调用原理的；简单来讲，ART中调用一个virtual method的时候，会查相应Class类里面的一张表，如果修改这张表对应项的指向，就能达到Hook的目的。更详细的实现原理，作者的论文以及他的<a href="http://roptors.me/art/art-part-iii-arthook-framework/" target="_blank" rel="external">博客</a>讲的很详细，感兴趣的可以自行围观。</p>
<p>这种方式最大的缺点是只能Hook virtual方法，虽然根据作者提供的数据：</p>
<blockquote>
<p>59.2% of these methods are declared as virtual<br>1.0% are non-virtual<br>39.8% methods not found</p>
</blockquote>
<p>高达99%的方法都能被hook住，不管你信不信，反正我是不信。所以，这种Hook方式无法Hook所有的调用过程，只能作为一种补充手段使用。</p>
<h2 id="epic的实现">epic的实现</h2><h3 id="基本原理">基本原理</h3><p>了解到已有项目的一些实现原理以及当前的现状，我们可以知道，要实现一个较为通用的Hook技术，几乎只有一条路———基于dynamic dispatch的dynamic callee-side rewriting。epic正是使用这种方式实现的，它的基本原理如下图：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1511354138004.png" width="765"></p>
<p>在讲解这张图之前，有必要说明一下ART中的函数的调用约定。以Thumb2为例，子函数调用的参数传递是通过寄存器r0~r3 以及sp寄存器完成的。r0 ~ r3 依次传递第一个至第4个参数，同时 <em>sp, </em>(sp + 4), <em>(sp + 8), </em>(sp + 12) 也存放着r0~r3上对应的值；多余的参数通过 sp传递，比如 *(sp + 16)放第四个参数，以此类推。同时，函数的返回值放在r0寄存器。如果一个参数不能在一个寄存器中放下，那么会占用2个或多个寄存器。</p>
<p>在ART中，r0寄存器固定存放被调用方法的ArtMethod指针，如果是non-static 方法，r1寄存器存放方法的this对象；另外，只有long/double 占用8bytes，其余所有基本类型和对象类型都占用4bytes。不过这只是基本情形，不同的ART版本对这个调用约定有不同的处理，甚至不完全遵循。</p>
<p>好了我们回到epic。如上图所述，如果我们要Hook <code>android.util.Log.i</code> 这个方法，那么首先需要找到这个方法的entrypoint，可以通过这个方法的ArtMethod对象得到；然后我们直接修改内存，把这个函数的前8个字节：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e92d40e0  ; push    &#123;r5, r6, r7, lr&#125; &#10;b088      ; sub     sp, sp, #32 &#10;1c07      ; mov     r7, r0</span><br></pre></td></tr></table></figure>
<p>修改为一段跳转指令：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dff800f0  <span class="comment">; ldr pc, [pc]</span></span><br><span class="line"><span class="number">7f132450</span>  <span class="comment">; trampoline2 address</span></span><br></pre></td></tr></table></figure>
<p>这样，在执行<code>Log.i</code> 这个函数的时候，会通过这第一段跳板直接跳转到 0x7f132450 这个地址开始执行。这个地址是我们预先分配好的一段内存，也是一段跳转函数，我们姑且称之为二段跳板。在接下来的二段跳板中，我们开始准备分发逻辑：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldr </span><span class="literal">ip</span>, <span class="number">3</span>f  <span class="comment">; ip = source_method_address</span></span><br><span class="line"><span class="keyword">cmp </span><span class="literal">r0</span>, <span class="literal">ip</span>  <span class="comment">; r0 == ip ?</span></span><br><span class="line"><span class="keyword">bne.w </span><span class="number">5</span>f    <span class="comment">; if r0 != source_method_address, then jump to label5.</span></span><br></pre></td></tr></table></figure>
<p>这段代码是用来判断是否需要执行Hook的，如果不需要，跳转到原函数的控制流，进而达到调用原函数的目的。接下来就是一些参数准备：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">str </span><span class="literal">sp</span>, [<span class="literal">ip</span>, <span class="number">#0</span>]</span><br><span class="line"><span class="keyword">str </span><span class="literal">r2</span>, [<span class="literal">ip</span>, <span class="number">#4</span>]</span><br><span class="line"><span class="keyword">str </span><span class="literal">r3</span>, [<span class="literal">ip</span>, <span class="number">#8</span>]</span><br><span class="line"><span class="keyword">mov </span><span class="literal">r3</span>, <span class="literal">ip</span></span><br><span class="line"><span class="keyword">ldr </span><span class="literal">r2</span>, <span class="number">3</span>f</span><br><span class="line"><span class="keyword">str </span><span class="literal">r2</span>, [<span class="literal">ip</span>, <span class="number">#12</span>]</span><br><span class="line"><span class="keyword">mov </span><span class="literal">r2</span>, <span class="literal">r9</span></span><br><span class="line"><span class="keyword">ldr </span><span class="literal">pc</span>, <span class="number">2</span>f <span class="comment">; jump to target_method_entry</span></span><br></pre></td></tr></table></figure>
<p>在参数准备好之后，直接跳转到另外一个Java方法的入口开始执行，这个方法称之为bridge方法。bridge方法接管控制流之后我们就回到了Java世界，自此之后我们就可以开始处理AOP逻辑。</p>
<h3 id="一些问题">一些问题</h3><p>基本原理比较简单，但是在实现过程中会有很多问题，这里简单交代一下。</p>
<h4 id="bridge函数分发以及堆栈平衡">bridge函数分发以及堆栈平衡</h4><p>从上面的基本介绍我们可以知道，方法的AOP逻辑是交给一个Java的bridge函数统一处理的，那么这个统一的函数如何区分每一个被Hook的方法，进而调用对应的回调函数呢？</p>
<p>最直接的办法是把被Hook的方法通过额外参数直接传递给bridge函数，而传递参数可以通过寄存器和堆栈实现。用来传递参数的寄存器（如r0~r3)最好是不要<strong>直接</strong>改的，不然我们的处理函数可能就收到不到原函数对应的参数，进而无法完成调用原函数的逻辑。如果用堆栈传递参数的话，我们是直接在堆栈上分配内存吗？</p>
<p>事实证明这样做是不行的，如果我们在二段跳板代码里面开辟堆栈，进而修改了sp寄存器；那么在我们修改sp到调用bridge函数的这段时间里，堆栈结构与不Hook的时候是不一样的（虽然bridge函数执行完毕之后我们可以恢复正常）；在这段时间里如果虚拟机需要进行栈回溯，sp被修改的那一帧会由于回溯不到对应的函数引发致命错误，导致Runtime 直接Abort。什么时候会回溯堆栈？发生异常或者GC的时候。最直观的感受就是，如果bridge函数里面有任何异常抛出（即使被try..catch住）就会使虚拟机直接崩溃。dexposed的 dev_art 分支中的AOP实现就有这个问题。</p>
<p>既然无法分配新的堆栈，那么能否找到空闲的空间使用呢？上面我们在介绍Thumb2调用约定的时候提到，r0~r3传递第一至第四个参数，sp ~ sp + 12 也传递第一至第四个参数，看起来好像是重复了；我们能否把 sp ~ sp + 12 这段空间利用起来呢？</p>
<p>但是实际实现的过程中又发现，此路不通。你以为就你会耍这点小聪明吗？虚拟机本身也是知道 sp + 12 这段空间相当于是浪费的，因此他直接把这段空间当做类似寄存器使用了；如果你把额外的参数丢在这里，那么根本就收不到参数，因为函数调用一旦发生，ART很可能直接把这段内存直接使用了。</p>
<p>既然如此，我们只能把要传递的一个或者多个额外参数打包在一起（比如放在结构体），通过指针一块传递了。再此观察我们上面的二段跳板代码：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldr </span><span class="literal">ip</span>, <span class="number">4</span>f</span><br><span class="line"><span class="keyword">str </span><span class="literal">sp</span>, [<span class="literal">ip</span>, <span class="number">#0</span>]</span><br><span class="line"><span class="keyword">str </span><span class="literal">r2</span>, [<span class="literal">ip</span>, <span class="number">#4</span>]</span><br><span class="line"><span class="keyword">str </span><span class="literal">r3</span>, [<span class="literal">ip</span>, <span class="number">#8</span>]</span><br><span class="line"><span class="keyword">mov </span><span class="literal">r3</span>, <span class="literal">ip</span></span><br><span class="line"><span class="keyword">ldr </span><span class="literal">r2</span>, <span class="number">3</span>f</span><br><span class="line"><span class="keyword">str </span><span class="literal">r2</span>, [<span class="literal">ip</span>, <span class="number">#12</span>]</span><br></pre></td></tr></table></figure>
<p>其中，<code>4f</code> 处是我们预先分配好的一段16字节的内存(假设起始地址为base)；我们把 sp 放到 <em>(base)上，把r2寄存器（原第三个参数）放到 </em>(base + 4)，把r3（原第四个参数）放到 <em>(base + 8)，把 <code>3f</code>（被Hook函数的地址）放到 </em>(base + 12)；然后把这个base 的地址放在r3寄存器里面，这样根据调用约定，我们的bridge函数就可以在第四个参数上收到四个打包好的数据，然后通过相同的访问方式就可以把原始数据取出来。这些数据中就包括了被Hook的原函数地址，通过这个地址，我们可以区分不同的被Hook函数，进而触发各自对应的处理逻辑。</p>
<h4 id="入口重合的问题">入口重合的问题</h4><p>在二段跳板函数的开始处，有这么一段代码：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldr </span><span class="literal">ip</span>, <span class="number">3</span>f  <span class="comment">; ip = source_method_address</span></span><br><span class="line"><span class="keyword">cmp </span><span class="literal">r0</span>, <span class="literal">ip</span>  <span class="comment">; r0 == ip ?</span></span><br><span class="line"><span class="keyword">bne.w </span><span class="number">5</span>f    <span class="comment">; if r0 != source_method_address, then jump to label5.</span></span><br></pre></td></tr></table></figure>
<p>也许你会问，这个比较逻辑是有必要的吗？除了达到调用原函数的目的之外，这个逻辑还有一个更重要的用途：区分入口相同，但是实际上Java方法完全不同的处理逻辑。</p>
<p>什么时候不同的Java函数的入口会一样呢？至少有下面几种情况：</p>
<ol>
<li>所有ART版本上未被resolve的static函数</li>
<li>Android N 以上的未被编译的所有函数</li>
<li>代码逻辑一模一样的函数</li>
<li>JNI函数</li>
</ol>
<p>static函数是lazy resolve的，在方法没有被调用之前，static函数的入口地址是一个跳板函数，名为 art_quick_resolution_trampoline，这个跳转函数做的事情就是去resvole原始函数，然后进行真正的调用逻辑；因此没有被调用的static函数的entrypoint都是一样的。</p>
<p>Android N以上，APK安装的时候，默认是不会触发AOT编译的；因此如果刚安装完你去看apk生成的OAT文件，会发现里面的code都是空。在这些方法被resolve的时候，如果ART发现code是空，会把entrypoint设置为解释执行的入口；接下来如果此方法被执行会直接进入到解释器。所以，Android N上未被编译的所有方法入口地址都相同。</p>
<p>如果代码逻辑完全一样，那么AOT编译器会发现这完全可以用一个函数来代替，于是这些函数都有了同一个入口地址；而JNI函数由于函数体都是空（也即所有代码相同），理所当然会共享同一个入口。</p>
<p>如果没有这段处理逻辑，你会发现你Hook一个函数的时候，很可能莫名其妙滴Hook了一堆你压根都不知道是什么的函数。</p>
<h4 id="指针与对象转换">指针与对象转换</h4><p>在基本的bridge函数调用（从汇编进入Java世界）的问题搞定之后，我们会碰到一个新问题：在bridge函数中接受到的参数都是一些地址，但是原函数的参数明明是一些对象，怎么把地址还原成原始的参数呢？</p>
<p>如果传递的是基本类型，那么接受到的地址其实就是基本类型值的表示；但是如果传递的是对象，那接受到的 int/long 是个什么东西？</p>
<p>这个问题一言难尽，它的背后是ART的对象模型；这里我简单说明一下。一个最直观的问题就是：JNI中的 jobject，Java中的Object，ART 中的 art::mirror::Object 到底是个什么关系？</p>
<p>实际上，art::mirror::Object 是 Java的Object在Runtime中的表示，java.lang.Object的地址就是art::mirror::Object的地址；但是jobject略有不同，它并非地址，而是一个句柄（或者说透明引用）。为何如此？</p>
<p>因为JNI对于ART来说是外部环境，如果直接把ART中的对象地址交给JNI层（也就是jobject直接就是Object的地址），其一不是很安全，其二直接暴露内部实现不妥。就拿GC来说，虚拟机在GC过程中很可能移动对象，这样对象的地址就会发生变化，如果JNI直接使用地址，那么对GC的实现提出了很高要求。因此，典型的Java虚拟机对JNI的支持中，jobject都是句柄（或者称之为透明引用）；ART虚拟机内部可以在joject与 art::mirror::Object中自由转换，但是JNI层只能拿这个句柄去标志某个对象。</p>
<p>那么jobject与java.lang.Object如何转换呢？这个so easy，直接通过一次JNI调用，ART就自动完成了转换。</p>
<p>因此归根结底，我们需要找到一个函数，它能实现把 art::mirror::Object 转换为 jobject对象，这样我们可以通过JNI进而转化为Java对象。这样的函数确实有，那就是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">art::JavaVMExt::AddWeakGlobalReference(art::Thread*, art::mirror::Object*)</span><br></pre></td></tr></table></figure>
<p>此函数在 libart.so中，我们可以通过 <code>dlsym</code>拿到函数指针，然后直接调用。不过这个函数有一个art::Thread<em> 的参数，如何拿到这个参数呢？查阅 art::Thread 的源码发现，这个 art::Thread 与 java.lang.Thread 也有某种对应关系，它们是通过peer结合在一起的（JNI文档中有讲）。也就是说，java.lang.Thread类中的 nativePeer 成员代表的就是当前线程的 art::Thread</em>对象。这个问题迎刃而解。</p>
<h4 id="Android_N无法dlsym">Android N无法dlsym</h4><p>上文提到，为了实现对象和指针的转换，我们需要 <code>dlsym</code> 一个 libart.so 中的导出函数；但不幸地是，在Android N中，Google禁止了这种行为，如果你用 <code>dlsym</code> 去取符号，返回的结果是nullptr。怎么办呢？</p>
<p>libart.so 不过是一个加载在内存中的elf文件而已。我们通过读取 <code>/proc/self/maps</code> 拿到这个文件的加载基地址，然后直接解析ELF文件格式，查出这个符号在ELF文件中的偏移，再加上内存基址，就能得到这个符号真正的地址。不过这过程已经有人实现了，而且放在了github上：<a href="https://github.com/avs333/Nougat_dlfunctions" target="_blank" rel="external">Nougat_dlfunctions</a> 可以直接使用 :)</p>
<h4 id="Android_N_解释执行">Android N 解释执行</h4><p>Android N采用了混合编译的模式，既有解释执行，也有AOT和JIT；APK刚安装完毕是解释执行的，运行时JIT会收集方法调用信息，必要的时候直接编译此方法，甚至栈上替换；在设备空闲时，系统会根据收集到的信息执行AOT操作。</p>
<p>那么在APK刚装完然后使用的那么几次，方法都是解释执行的，我们要Hook掉解释执行的入口吗？这当然可以，但是如果解释执行到一半方法入口被替换为JIT编译好的机器码的入口，那么本次Hook就会失效；我们还需要把JIT编译的机器码入口也拦截住。但是问题是，我们何时知道JIT执行完成？</p>
<p>所以这种方式实行起来比较麻烦，<strong>还不如一开始就全部是机器码</strong> 这样我们只用Hook机器码的entrypoint就可以了。事实上，Android N可以手动触发AOT全量编译，如 <a href="https://source.android.com/devices/tech/dalvik/jit-compiler" target="_blank" rel="external">官方文档</a> 所述，可以通过如下命令手动执行AOT编译：</p>
<blockquote>
<p>adb shell cmd package compile -m speed -f <package-name></package-name></p>
</blockquote>
<p>这样一来，我们一般情况下就不用管解释器的事了。</p>
<p>虽然多这么一个步骤，勉强能解决问题，但还是有点小瑕疵；(毕竟要多这么一步嘛！何况如果这个投入线上使用，你指望用户给你主动编译？）在研究了一段时间的JIT代码之后，我发现<strong>可以主动调用JIT编译某个方法</strong>。这样，在Hook之前我们可以先请求JIT编译此方法，得到机器码的entrypoint，然后按照正常的流程Hook即可。具体如何调用JIT可以参阅epic的<a href="https://github.com/tiann/epic" target="_blank" rel="external">源码</a>。</p>
<h4 id="Android_N_JIT编译">Android N JIT编译</h4><p>上文提到Android N上开启了JIT编译器，即使我们手动触发全量AOT编译，在运行时这种机制依然存在；JIT的一个潜在隐患就是，他有可能动态修改代码，这使得在Android N上的Hook可能随机出现crash。</p>
<p>记得我在刚实现完Android N上的Hook之后，发现我的测试case偶尔会崩溃，崩溃过程完全没有规律，而且崩溃的错误几乎都是SIG 11。当时追查了一段时间，觉得这种随机崩溃可能跟2个原因有关：GC或者JIT；不过一直没有找到证据。</p>
<p>某天半夜我发现一个有趣的现象，如果我把测试case中的Logcat日志输出关掉，崩溃的概率会小很多——如果输出Logcat可能测试八九次就闪退了，但如果关掉日志，要数十次或者几乎不会闪退。当时我就怀疑是不是碰上了薛定谔猫。</p>
<p>理性分析了一番之后我觉得这种尺度不可能触发量子效应，于是我只能把锅摔倒Log头上。我在想是不是Log有IO操作导致hook过程太慢了使得这段时间别的线程有机会修改代码？于是我在Hook过程中Sleep 5s发现一点问题没有。实在没辙，我就一条条删Log，结果发现一个神奇的现象：Log越多越容易崩。然后我就写个循环输出日志100次，结果几乎是毕现闪退。</p>
<p>事情到这里我就瞬间明白了：调用Log的过程中很有可能由于Log函数调用次数过多进而达到JIT编译的阈值从而触发了JIT，这时候JIT线程修改了被执行函数的代码，而Hook的过程也会修改代码，这导致内存中的值不可预期，从而引发随机crash。</p>
<p>按照这种情况推测的话，JIT的存在导致Android N上的Hook几乎是毕现闪退的。因为我的测试demo代码量很少，一个稍微有点规模的App很容易触发JIT编译，一旦在JIT过程中执行Hook，那么必崩无疑。</p>
<p>因此比较好的做法是，在Hook的过程中暂停所有其他线程，不让它们有机会修改代码；在Hook完毕之后在恢复执行。那么问题来了，如何暂停/恢复所有线程？Google了一番发现有人通过ptrace实现：开一个linux task然后挨个ptrace本进程内的所有子线程，这样就是实现了暂停。这种方式很重而且不是特别稳定，于是我就放弃了。ART虚拟机内部一定也有暂停线程的需求（比如GC），因此我可以选择直接调用ART的内部函数。</p>
<p>在源码里面捞了一番之后果然在thread_list.cc 中找到了这样的函数 resumeAll/suspendAll；不过遗憾的是这两个函数是ThreadList类的成员函数，要调用他们必须拿到ThreadList的指针；一般情况下是没有比较稳定的方式拿到这个对象的。不过好在Android 源码通过RAII机制对 suspendAll/resumeAll做了一个封装，名为 <code>ScopedSuspendAll</code> 这类的构造函数里面执行暂停操作，析构函数执行恢复操作，在栈上分配变量此类型的变量之后，在这个变量的作用域内可以自动实现暂停和恢复。因此我只需要用 <code>dlsym</code> 拿到构造函数和析构函数的符号之后，直接调用就能实现暂停恢复功能。详细实现见 epic <a href="https://github.com/tiann/epic" target="_blank" rel="external">源码</a></p>
<p>写了这么多，实际上还有很多想写的没有写完；比如Android M Optimizing编译器上的寄存器分配问题，long/double参数的处理细节，不同ART版本的调用约定 与 ATPCS/AAPCS之间不同等；不过来日方长，这些问题以后在慢慢道来吧 :)</p>
<h2 id="使用">使用</h2><p>扯了这么久的实现原理，我们来看看这玩意儿具体怎么用吧。只需要在你的项目中加入epic的依赖即可(jcenter 仓库)：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">'me.weishu:epic:0.1.2@aar'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以在你的项目中做AOP Hook，比如说要拦截所有Java线程的创建，我们可以用如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadMethodHook</span> <span class="keyword">extends</span> <span class="title">XC_MethodHook</span></span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.beforeHookedMethod(param);</span><br><span class="line">        Thread t = (Thread) param.thisObject;</span><br><span class="line">        Log.i(TAG, <span class="string">"thread:"</span> + t + <span class="string">", started.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.afterHookedMethod(param);</span><br><span class="line">        Thread t = (Thread) param.thisObject;</span><br><span class="line">        Log.i(TAG, <span class="string">"thread:"</span> + t + <span class="string">", exit.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DexposedBridge.hookAllConstructors(Thread.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.afterHookedMethod(param);</span><br><span class="line">        Thread thread = (Thread) param.thisObject;</span><br><span class="line">        Class&lt;?&gt; clazz = thread.getClass();</span><br><span class="line">        <span class="keyword">if</span> (clazz != Thread.class) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"found class extend Thread:"</span> + clazz);</span><br><span class="line">            DexposedBridge.findAndHookMethod(clazz, <span class="string">"run"</span>, <span class="keyword">new</span> ThreadMethodHook());</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(TAG, <span class="string">"Thread: "</span> + thread.getName() + <span class="string">" class:"</span> + thread.getClass() +  <span class="string">" is created."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">DexposedBridge.findAndHookMethod(Thread.class, <span class="string">"run"</span>, <span class="keyword">new</span> ThreadMethodHook());</span><br></pre></td></tr></table></figure>
<p>这里有2个AOP点，其一是 Thread.class 的run方法，拦截这个方法，我们可以知道所有通过Thread类本身创建的线程；其二是Thread的构造函数，这个Hook点我们可以知道运行时具体有哪些类继承了Thread.class类，在找到这样的子类之后，直接hook掉这个类的run方法，从而达到了拦截所有线程创建的目的。</p>
<p>当然，还有很多有趣的AOP点等待你去挖掘，这一切取决于您的想象力 :)</p>
<h2 id="局限">局限</h2><p>上文提到，「要在ART上实现一个完善而稳定的Hook机制，几无可能」，epic也不例外：它也有它自己的缺点，有些是先天的，有些是后天的，还有一些我没有发现的 ~_~；比如说：</p>
<ol>
<li>受限于dynamic callee-side rewrite机制，如果被Hook函数的code段太短以至于一个简单的trampoline跳转都放不下，那么epic无能为力。</li>
<li>如果ART中有深度内联，直接把本函数的代码内联到调用者，那么epic也搞不定。</li>
<li>Android O(8.0)还没有去研究和实现。</li>
<li>当前仅支持thumb2/arm64指令集，arm32/x86/mips还没有支持。 </li>
<li>在支持硬浮点的cpu架构，比如(armeabi-v7a, arm64-v8a)上，带有double/float参数的函数Hook可能有问题，没有充分测试。</li>
<li>还有一些其他机型上的，或者我没有发现的闪退。</li>
</ol>
<p>我本人只在Android 5.0, 5.1, 6.0, 7.0, 7.1 的个别机型，以及这些机型的thumb2指令集，和6.0/7.1 的arm64指令集做过测试；其他的机型均未测试，因此这么长的文章还读到最后的你，不妨拿出你手头的手机帮我测试一下，在下感激不尽 :)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>两年前阿里开源了<a href="https://github.com/alibaba/dexposed">Dexposed</a> 项目，它能够在Dalvik上无侵入地实现运行时方法拦截，正如其介绍「enable ‘god’ mode for single android application」所言，能在非root情况下掌控自己进程空间内的任意Java方法调用，给我们带来了很大的想象空间。比如能实现运行时AOP，在线热修复，做性能分析工具（拦截线程、IO等资源的创建和销毁）等等。然而，随着ART取代Dalvik成为Android的运行时，一切都似乎戛然而止。</p>
<p>今天，我在ART上重新实现了Dexposed，在它能支持的平台（Android 5.0 ~ 7.1 Thumb2/ARM64)上，有着与Dexposed完全相同的能力和API；项目地址在这里 <a href="https://github.com/tiann/epic">epic</a>，感兴趣的可以先试用下:) 然后我们聊一聊ART上运行时Method AOP的故事。</p>]]>
    
    </summary>
    
      <category term="AOP" scheme="http://weishu.me/tags/AOP/"/>
    
      <category term="ART" scheme="http://weishu.me/tags/ART/"/>
    
      <category term="Dexposed" scheme="http://weishu.me/tags/Dexposed/"/>
    
      <category term="Hook" scheme="http://weishu.me/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ART深度探索开篇：从Method Hook谈起]]></title>
    <link href="http://weishu.me/2017/03/20/dive-into-art-hello-world/"/>
    <id>http://weishu.me/2017/03/20/dive-into-art-hello-world/</id>
    <published>2017-03-20T15:37:08.000Z</published>
    <updated>2019-01-30T04:06:02.838Z</updated>
    <content type="html"><![CDATA[<p>Android上的热修复框架 AndFix 想必已经是耳熟能详，它的原理实际上很简单：方法替换——Java层的每一个方法在虚拟机实现里面都对应着一个ArtMethod的结构体，只要把原方法的结构体内容替换成新的结构体的内容，在调用原方法的时候，真正执行的指令会是新方法的指令；这样就能实现热修复，详细代码见 <a href="https://github.com/alibaba/AndFix" target="_blank" rel="external">AndFix</a>。</p>
<p>为什么可以这么做呢？那得从 Android 虚拟机的方法调用过程说起。作为一个系列的开篇，本文不打算展开讲虚拟机原理等内容，首先给大家一道开胃菜；后续我们再深入探索ART。</p>
<p>众所周知，AndFix是一种 native 的hotfix方案，它的替换过程是用 c 在 native层完成的，但其实，我们也可以用纯Java实现它！而且，代码还非常精简，且看——</p>
<a id="more"></a>
<h2 id="方法替换原理">方法替换原理</h2><p>既然我们知道 AndFix 的原理是方法替换，那么为什么直接替换Java里面的 <code>java.lang.reflect.Method</code> 有什么问题吗？直接这样貌似很难下结论，那我们换个思路。我们实现方法替换的结果，就是调用原方法的时候最终是调用被替换的方法。因此，我们可以看看 <code>java.lang.reflect.Method</code>类的 <code>invoke</code> 方法。（这里有个疑问，Foo.bar()这种直接调用与反射调用Foo.class.getDeclaredMethod(“bar”).invoke(null) 有什么区别吗？这个问题后续再谈）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> Object <span class="title">invoke</span><span class="params">(Object receiver, Object[] args, <span class="keyword">boolean</span> accessible)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span>;</span><br></pre></td></tr></table></figure>
<p>这个invoke是一个native方法，它的native实现在 <code>art/runtime/native/java_lang_reflect_Method.cc</code> 里面，这个jni方法最终调用了 <code>art/runtime/reflection.cc</code> 的 <code>InvokeMethod</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">object <span class="title">InvokeMethod</span><span class="params">(<span class="keyword">const</span> ScopedObjectAccessAlreadyRunnable&amp; soa, jobject javaMethod,</span><br><span class="line">                     jobject javaReceiver, jobject javaArgs, <span class="keyword">bool</span> accessible)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 略...</span></span><br><span class="line"></span><br><span class="line">  mirror::ArtMethod* m = mirror::ArtMethod::FromReflectedMethod(soa, javaMethod);</span><br><span class="line"></span><br><span class="line">  mirror::Class* declaring_class = m-&gt;GetDeclaringClass();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按需初始化类，略。。</span></span><br><span class="line"></span><br><span class="line">  mirror::Object* receiver = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (!m-&gt;IsStatic()) &#123;</span><br><span class="line">    <span class="comment">// Check that the receiver is non-null and an instance of the field's declaring class.</span></span><br><span class="line">    receiver = soa.Decode&lt;mirror::Object*&gt;(javaReceiver);</span><br><span class="line">    <span class="keyword">if</span> (!VerifyObjectIsClass(receiver, declaring_class)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the actual implementation of the virtual method.</span></span><br><span class="line">    m = receiver-&gt;GetClass()-&gt;FindVirtualMethodForVirtualOrInterface(m);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 略..</span></span><br><span class="line">  InvokeWithArgArray(soa, m, &amp;arg_array, &amp;result, shorty);</span><br><span class="line">  <span class="comment">// 略 。。</span></span><br><span class="line">  <span class="comment">// Box if necessary and return.</span></span><br><span class="line">  <span class="keyword">return</span> soa.AddLocalReference&lt;jobject&gt;(BoxPrimitive(mh.GetReturnType()-&gt;GetPrimitiveType(),</span><br><span class="line">                                                     result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面函数 InvokeMethod 的第二个参数 <code>javaMethod</code> 就是Java层我们进行反射调用的那个Method对象，在jni层反映为一个jobject；InvokeMethod这个native方法首先通过 <code>mirror::ArtMethod::FromReflectedMethod</code> 获取了Java对象的在native层的 ArtMethod指针，我们跟进去看看是怎么实现的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArtMethod* ArtMethod::FromReflectedMethod(<span class="keyword">const</span> ScopedObjectAccessAlreadyRunnable&amp; soa,</span><br><span class="line">                                          jobject jlr_method) &#123;</span><br><span class="line">  mirror::ArtField* f =</span><br><span class="line">      soa.DecodeField(WellKnownClasses::java_lang_reflect_AbstractMethod_artMethod);</span><br><span class="line">  mirror::ArtMethod* method = f-&gt;GetObject(soa.Decode&lt;mirror::Object*&gt;(jlr_method))-&gt;AsArtMethod();</span><br><span class="line">  DCHECK(method != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">return</span> method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在这里看到了一点端倪，获取到了Java层那个Method对象的一个叫做 <code>artMethod</code>的字段，然后强转成了ArtMethod指针（这里的说法不是很准确，但是要搞明白这里面的细节一两篇文章讲不清楚 ~_~，我们暂且这么认为吧。）</p>
<p>AndFix的实现里面，也正是使用这个 <code>FromReflectedMethod</code> 方法拿到Java层Method对应native层的ArtMethod指针，然后执行替换的。</p>
<p>上面我们也看到了，我们在native层替换的那个 ArtMethod 不是在 Java 层也有对应的东西么？我们直接替换掉 Java 层的这个artMethod 字段不就OK了？但是我们要注意的是，在Java里面除了基本类型，其他东西都是引用。要实现类似C++里面那种替换引用所指向内容的机智，需要一些黑科技。</p>
<h2 id="Unsafe_和_Memory">Unsafe 和 Memory</h2><p>要在Java层操作内容，也不是没有办法做到；JDK给我们留了一个后门：<code>sun.misc.Unsafe</code> 类；在OpenJDK里面这个类灰常强大，从内存操作到CAS到锁机制，无所不能（可惜的是据说JDK8要去掉？）但是在Android 平台还有一点点不一样，在 Android N之前，Android的JDK实现是 Apache Harmony，这个实现里面的Unsafe就有点鸡肋了，没法写内存；好在Android 又开了一个后门：<code>Memory</code> 类。</p>
<p>有了这两个类，我们就能在Java层进行简单的内存操作了！！由于这两个类是隐藏类，我写了一个wrapper，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// libcode.io.Memory#peekByte</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">peekByte</span><span class="params">(<span class="keyword">long</span> address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Byte) Reflection.call(<span class="keyword">null</span>, <span class="string">"libcore.io.Memory"</span>, <span class="string">"peekByte"</span>, <span class="keyword">null</span>, <span class="keyword">new</span> Class[]&#123;<span class="keyword">long</span>.class&#125;, <span class="keyword">new</span> Object[]&#123;address&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pokeByte</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">byte</span> value)</span> </span>&#123;</span><br><span class="line">        Reflection.call(<span class="keyword">null</span>, <span class="string">"libcore.io.Memory"</span>, <span class="string">"pokeByte"</span>, <span class="keyword">null</span>, <span class="keyword">new</span> Class[]&#123;<span class="keyword">long</span>.class, <span class="keyword">byte</span>.class&#125;, <span class="keyword">new</span> Object[]&#123;address, value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">memcpy</span><span class="params">(<span class="keyword">long</span> dst, <span class="keyword">long</span> src, <span class="keyword">long</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            pokeByte(dst, peekByte(src));</span><br><span class="line">            dst++;</span><br><span class="line">            src++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String UNSAFE_CLASS = <span class="string">"sun.misc.Unsafe"</span>;</span><br><span class="line">    <span class="keyword">static</span> Object THE_UNSAFE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> is64Bit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        THE_UNSAFE = Reflection.get(<span class="keyword">null</span>, UNSAFE_CLASS, <span class="string">"THE_ONE"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Object runtime = Reflection.call(<span class="keyword">null</span>, <span class="string">"dalvik.system.VMRuntime"</span>, <span class="string">"getRuntime"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        is64Bit = (Boolean) Reflection.call(<span class="keyword">null</span>, <span class="string">"dalvik.system.VMRuntime"</span>, <span class="string">"is64Bit"</span>, runtime, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getObjectAddress</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Object[] objects = &#123;o&#125;;</span><br><span class="line">        Integer baseOffset = (Integer) Reflection.call(<span class="keyword">null</span>, UNSAFE_CLASS,</span><br><span class="line">                <span class="string">"arrayBaseOffset"</span>, THE_UNSAFE, <span class="keyword">new</span> Class[]&#123;Class.class&#125;, <span class="keyword">new</span> Object[]&#123;Object[].class&#125;);</span><br><span class="line">        <span class="keyword">return</span> ((Number) Reflection.call(<span class="keyword">null</span>, UNSAFE_CLASS, is64Bit ? <span class="string">"getLong"</span> : <span class="string">"getInt"</span>, THE_UNSAFE,</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;Object.class, <span class="keyword">long</span>.class&#125;, <span class="keyword">new</span> Object[]&#123;objects, baseOffset.longValue()&#125;)).longValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="具体实现">具体实现</h2><p>接下来思路就很简单了呀，用伪代码表示就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memcopy(originArtMethod, replaceArtMethod);</span><br></pre></td></tr></table></figure>
<p>但是还有一个问题，我们要整个把 originMethod 的 artMethod 所在的内存直接替换为 replaceMethod 的artMethod 所在的内存（上面我们已经知道，Java层Method类的artMethod实际上就是native层的指针表示，在Android N上更明显，这玩意儿直接就是一个long），现在我们已经知道这两个地址是什么，那么我们把 replaceArtMethod 代表的内存复制到 originArtMethod 的区域，应该还需要知道一个 artMethod 有多大。</p>
<p>但是事情没有一个 sizeof 那么简单。你看AndFix的实现是在每个Android版本把ArtMethod这个结构体复制一份的；要想用sizeof还得把这个类所有的引用复制过来，及其麻烦。更何况在Java里面 sizeof都没有。不过也不是没有办法，既然我们已经能在Java层拿到对象的地址，只需要创建一个数组，丢两个ArtMethod，把两个数组元素的起始地址相减不就得到一个 artMethod的大小了吗？(此方法来自<a href="https://yq.aliyun.com/articles/74598?t=t1" target="_blank" rel="external">Android热修复升级探索——追寻极致的代码热替换</a>)</p>
<p>不过，既然我们实现了方法替换；还有最后一个问题，如果我们需要在替换后的方法里面调用原函数呢？这个也很简单，我们只需要把原函数copy一份保存起来，需要调用原函数的时候调用那个copy的函数不就行了？不过在具体实现的时候，会遇到一个问题，就是 Java的非static 非private的方法默认是虚方法，在调用这个方法的时候会有一个类似查找虚函数表的过程，这个在上面的代码 <code>InvokeMethod</code> 里面可以看到：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mirror::Object* receiver = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (!m-&gt;IsStatic()) &#123;</span><br><span class="line">  <span class="comment">// Check that the receiver is non-null and an instance of the field's declaring class.</span></span><br><span class="line">  receiver = soa.Decode&lt;mirror::Object*&gt;(javaReceiver);</span><br><span class="line">  <span class="keyword">if</span> (!VerifyObjectIsClass(receiver, declaring_class)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find the actual implementation of the virtual method.</span></span><br><span class="line">  m = receiver-&gt;GetClass()-&gt;FindVirtualMethodForVirtualOrInterface(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用的时候，如果不是static的方法，会去查找这个方法的真正实现；我们直接把原方法做了备份之后，去调用备份的那个方法，如果此方法是public的，则会查找到原来的那个函数，于是就无限循环了；我们只需要阻止这个过程，查看 FindVirtualMethodForVirtualOrInterface 这个方法的实现就知道，只要方法是 invoke-direct 进行调用的，就会直接返回原方法，这些方法包括：构造函数，private的方法( 见 <a href="https://source.android.com/devices/tech/dalvik/dalvik-bytecode.html" target="_blank" rel="external">https://source.android.com/devices/tech/dalvik/dalvik-bytecode.html</a>) 因此，我们手动把这个备份的方法属性修改为private即可解决这个问题。</p>
<p>详细代码见：<a href="https://github.com/tiann/epic" target="_blank" rel="external">github/epic</a></p>
<p>至此，我们就用纯Java实现了一个 AndFix，代码只有200行不到！！是不是很神奇？当然，这里面包含了很多黑科技，接下来我们将以这个为引子，深入探索Android ART的方方面面，揭开虚拟机底层的神秘面纱，敬请期待～～</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Android上的热修复框架 AndFix 想必已经是耳熟能详，它的原理实际上很简单：方法替换——Java层的每一个方法在虚拟机实现里面都对应着一个ArtMethod的结构体，只要把原方法的结构体内容替换成新的结构体的内容，在调用原方法的时候，真正执行的指令会是新方法的指令；这样就能实现热修复，详细代码见 <a href="https://github.com/alibaba/AndFix">AndFix</a>。</p>
<p>为什么可以这么做呢？那得从 Android 虚拟机的方法调用过程说起。作为一个系列的开篇，本文不打算展开讲虚拟机原理等内容，首先给大家一道开胃菜；后续我们再深入探索ART。</p>
<p>众所周知，AndFix是一种 native 的hotfix方案，它的替换过程是用 c 在 native层完成的，但其实，我们也可以用纯Java实现它！而且，代码还非常精简，且看——</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="art" scheme="http://weishu.me/tags/art/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何调试Android Native Framework]]></title>
    <link href="http://weishu.me/2017/01/14/how-to-debug-android-native-framework-source/"/>
    <id>http://weishu.me/2017/01/14/how-to-debug-android-native-framework-source/</id>
    <published>2017-01-14T09:02:03.000Z</published>
    <updated>2019-01-30T04:06:02.842Z</updated>
    <content type="html"><![CDATA[<p>半年前写了一篇文章，介绍 <a href="http://weishu.me/2016/05/30/how-to-debug-android-framework/">如何调试Android Framework</a>，但是只提到了Framework中Java代码的调试办法，但实际上有很多代码都是用C++实现的；无奈当时并并没有趁手的native调试工具，无法做到像Java调试那样简单直观（gdb+eclipse/ida之流虽然可以但是不完美），于是就搁置下了。</p>
<p>Android Studio 2.2版本带来了全新的对Android Native代码的开发以及调试支持，另外LLDB的Android调试插件也日渐成熟，我终于可以把这篇文章继续下去了！本文将带来Android Framework中native代码的调试方法。</p>
<p>在正式介绍如何调试之前，必须先说明一些基本的概念。调试器在调试一个可执行文件的时候，必须知道一些调试信息才能进行调试，这个调试信息可多可少（也可以没有）。最直观的比如行号信息，如果调试器知道行号信息，那么在进行调试的时候就能知道当前执行到了源代码的哪一行，如果调试器还知道对应代码的源文件在哪，那么现代IDE的调试器一般就能顺着源码带你飞了，这就是所谓的源码调试。相反，如果没有行号和源码信息，那么只能进行更低级别的调试了，调试器只能告诉你一些寄存器的值；而当前运行的代码也只是PC寄存器所指向的二进制数据，这些数据要么是虚拟机指令，要么是汇编指令；这就是所谓的无源码调试。显然无源码调试相比源码级别的调试要麻烦的多；接下来将围绕这两个方面分别介绍。</p>
<a id="more"></a>
<h2 id="用Android_Studio进行源码调试">用Android Studio进行源码调试</h2><p>如上文所述，如果需要实现源码调试，必须知道足够的调试信息；在native调试中就是所谓的「调试符号」。但是release版本的动态链接库或者可执行文件一般并不会包含我们需要的调试信息，在Android系统中，<code>/system/lib/*</code> 目录下的那些系统so并没有足够的调试信息，因此如果要进行源码调试，必须自己编译Android源代码，才能获取调试信息，进而让调试器协助我们调试。</p>
<p>Android源码编译是个麻烦事儿，我写过一篇文章介绍 <a href="https://zhuanlan.zhihu.com/p/24633328?refer=weishu" target="_blank" rel="external">如何使用Docker调试</a> ；但是，Android版本众多，如果真的需要调试各个版本，在本地进行编译几乎是不可能的——一个版本约占60G空间，如果每个版本都编译，你的Mac还有空间可用吗？因此比较推荐使用云服务进行源码编译；比如使用阿里云的ECS，20M的网速15分钟就能下载完源码；编译速度还勉强，4核8G两个半小时。扯远了 :) 如果你没有精力编译Android源码，我这个 <a href="https://github.com/tiann/android-native-debug" target="_blank" rel="external">Demo工程</a> 可以让你尝尝鲜，里面包含一些调试的必要文件，可以体会一下Native调试的感觉。</p>
<p>如果我们已经拥有了调试符号，那么还需要保证你的符号文件和设备上真正运行的动态链接库或者可执行文件是对应的，不然就是鸡同鸭讲了。最简单的办法就是使用模拟器。我们编译完源码之后，一个主要的编译产物就是 <code>system.img</code>，这个 <code>system.img</code>会在启动之后挂载到设备的 /system 分区，而system分区包含了Android系统运行时的绝大部分可执行文件和动态链接库，而这些文件就是我们的编译输出，正好可以与编译得到的调试符号进行配合调试。模拟器有一个 <code>-system</code>选项用来指定模拟器使用的 system.img文件；于是这个问题也解决了。</p>
<p>最后一个问题就是，既然是源码调试，当然需要源码了；我们可以在 <a href="https://android.googlesource.com/" target="_blank" rel="external">AOSP</a> 上下载需要的源码即可；需要注意的是，在check分支的时候，必须保证你的分支和编译源码时候的分支是一致的。</p>
<p>需要说明的是，虽然我们使用Android Studio调试，但是其背后的支撑技术实际上是 <a href="http://lldb.llvm.org/" target="_blank" rel="external">LLDB</a>。LLDB是一个相当强大的调试器，如果你现在还不知道它为何物，那真的是孤陋寡闻了！建议先简单学习一下 <a href="http://lldb.llvm.org/index.html" target="_blank" rel="external">教程</a></p>
<p>万事俱备，Let’s go!</p>
<h3 id="建立Android_Studio工程">建立Android Studio工程</h3><p>实际上任何Android Studio工程都可以进行native源码调试，但是为了方便还是新建一个工程；这个工程是一个空工程，没有任何实际用途；为了体验方便，你可以使用我的这个 <a href="https://github.com/tiann/android-native-debug" target="_blank" rel="external">Demo</a> 工程，里面包含了调试符号以及模拟器需要使用的system.img。一定要注意Android Studio的版本必须是2.2以上（我的是2.2.3稳定版)。</p>
<h3 id="下载需要调试模块的源码">下载需要调试模块的源码</h3><p>如果你本地编译了Android源码，那么就不需要这一步了；但是更多的时候我们只是想调试某一个模块，那么只需要下载这个模块的源码就够了。我这里演示的是调试 ART 运行时，因此直接下载ART模块的源码即可，我编译的Android源码版本是 <code>android-5.1.1_r9</code>，因此需要check这个分支的源码，地址在这里：<a href="https://android.googlesource.com/platform/art/+/android-5.1.1_r9" target="_blank" rel="external">ART-android-5.1.1_r9</a></p>
<h3 id="运行模拟器">运行模拟器</h3><p>由于我们的调试符号需要与运行时的动态链接库对应，因此我们需要借助模拟器；首先创建一个编译出来的调试符号对应的API版本的模拟器，我这里提供的是5.1.1也就是API 22；然后使用编译出来的 system.img 启动模拟器（[Demo]工程的image目录有我编译出来的文件，可以直接使用。）：</p>
<blockquote>
<p>emulator -avd 22 -verbose -no-boot-anim -system /path/to/system.img</p>
</blockquote>
<p>这个过程灰常灰常长！！我启动这个模拟器花了半个多小时，也是醉。现在是2017年，已经是Android创建的第十个年头，ARM模拟器还是烂的一塌糊涂，无力吐槽。一个能让它快一点的诀窍是创建一个小一点的SD card；我设置的是10M。</p>
<h3 id="开始调试">开始调试</h3><h4 id="选择native调试模式">选择native调试模式</h4><p>首先我们对调试的宿主工程设置一下，选择native调试功能。点击运行下面的按钮 <code>Edit Configuration</code>：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1484287940736.png" width="232"></p>
<p>然后在debugger栏选择Native：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1484288018710.png" width="400"></p>
<p>然后我们点击旁边的 <code>Debug</code>小按钮运行调试程序：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1484288078862.png" width="183"></p>
<h4 id="设置调试符号以及关联源码">设置调试符号以及关联源码</h4><p>在运行程序之后，我们可以在Android Studio的状态栏看到，LLDB调试插件自动帮我们完成了so查找路径的过程，这一点比gdb方便多了！在Android Studio的Debug窗口会自动弹出来，如下：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1484288380978.png" width="474"></p>
<p>我们点击那个 <code>pause program</code> 按钮，可以让程序暂停运行：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1484288440156.png" width="615"></p>
<p>上图左边是正在运行的线程的堆栈信息，右边有两个tab，一个用来显示变量的值；一个是lldb交互式调试窗口！我们先切换到lldb窗口，输入如下命令设置一个断点：</p>
<blockquote>
<p>(lldb) br s -n CollectGarbageInternal<br>Breakpoint 2: where = libart.so`art::gc::Heap::CollectGarbageInternal(art::gc::collector::GcType, art::gc::GcCause, bool), address = 0xb4648c20</p>
</blockquote>
<p>可以看到，断点已经成功设置；这个断点在libart.so中，不过现在还没有调试符号信息以及源码信息，我们只知道它的地址。接下来我们设置调试符号以及关联源码。</p>
<p>接下来我们把编译得到的符号文件 libart.so 告诉调试器（符号文件和真正的动态链接库这两个文件名字相同，只不过一个在编译输出的symbols目录) ；在lldb窗口执行：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lldb<span class="function">)</span><span class="instruction"> add-dsym </span>/Users/weishu/dev/github/Android-native-debug/app/symbols/libart.so</span><br><span class="line">symbol file '/Users/weishu/dev/github/Android-native-debug/app/symbols/libart.so' \</span><br><span class="line">has been added to '/Users/weishu/.lldb/module_cache/remote-android/.cache/C51E51E5-0000-0000-0000-000000000000/libart.so'</span><br></pre></td></tr></table></figure>
<p>注意后面那个目录你的机器上与我的可能不同，需要修改一下。我们再看看有什么变化，看一下刚刚的断点：</p>
<blockquote>
<p>(lldb) br list 2<br>2: name = ‘CollectGarbageInternal’, locations = 1, resolved = 1, hit count = 0<br>  2.1: where = libart.so`art::gc::Heap::CollectGarbageInternal(art::gc::collector::GcType, art::gc::GcCause, bool) <strong>at heap.cc:2124</strong>, address = 0xb4648c20, resolved, hit count = 0 </p>
</blockquote>
<p>行号信息已经加载出来了！！在 <code>heap.cc</code> 这个文件的第2124行。不过如果这时候断点命中，依然无法关联到源码。我们看一下调试器所所知道的源码信息：</p>
<blockquote>
<p>(lldb) source info<br>Lines found in module `libart.so<br>[0xb4648c20-0xb4648c28): <strong>/Volumes/Android/android-5.1.1_r9/art/runtime/gc/heap.cc</strong>:2124</p>
</blockquote>
<p>纳尼？？这个目录是个什么鬼，根本没有这个目录好伐？难道是调试器搞错了？</p>
<p>在继续介绍之前我们需要了解一些关于「调试符号」的知识；我们拿到的调试符号文件其实是一个DWARF文件，只不过这个文件被嵌入到了ELF文件格式之中，而其中的调试符号则在一些名为 <code>.debug_*</code> 的段之中，我们可以用 <code>readelf -S libart.so</code> 查看一下：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1484289374465.png" width="616"></p>
<p>编译器在编译libart.so的时候，记录下了<strong>编译时候</strong>源代码与代码偏移之间的对应关系，因此调试器可以从调试符号文件中获取到源码行号信息；如下：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1484289826696.png" width="486"></p>
<p>这下我们明白了上面那个莫名其妙的目录是什么了；原来是在编译<code>libart.so</code>的那个机器上存在源码。那么问题来了，我们绝大多数情况下是使用另外一台机器上的源码进行调试的——比如我提供的那个 <a href="https://github.com/tiann/android-native-debug" target="_blank" rel="external">Demo工程</a> 包含的带符号libart.so里面保存的源文件信息的目录实际上是我编译的电脑上的目录，而你调试的时候需要使用自己电脑上的目录。知道了问题所在，解决就很简单了，我们需要映射一下；在Android Studio的Debug 窗口的lldb 那个tab执行如下命令：</p>
<blockquote>
<p>(lldb) settings set target.source-map /Volumes/Android/android-5.1.1_r9/ /Users/weishu/dev/github/Android-native-debug/app/source/</p>
</blockquote>
<p>第一个参数的意思是编译时候的目录信息，第二个参数是你机器上的源码存放路径；设置成自己的即可。</p>
<p>这时候，我们再触发断点（点击demo项目的Debug按钮），看看发生了什么？！</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1484290490320.png" width="1191"></p>
<p>至此，我们已经成功滴完成了在Android Studio中Native代码的源码调试。你可以像调试Java代码一样调试Native代码，step/in/out/over，条件断点，watch point任你飞。你可以借助这个工具去探究Android底层运行原理，比如垃圾回收机制，对象分配机制，Binder通信等等，完全不在话下！</p>
<h2 id="无源码调试">无源码调试</h2><p>接下来再介绍一下操作简单但是使用门槛高的「无源码调试」方式；本来打算继续使用Android Studio的，但是无奈现阶段还有BUG，给官方提了issue但是响应很慢：<a href="https://code.google.com/p/android/issues/detail?id=231116。因此我们直接使用" target="_blank" rel="external">https://code.google.com/p/android/issues/detail?id=231116。因此我们直接使用</a> LLDB 调试；当然，用gdb也能进行无源码调试，但是使用lldb比gdb的步骤要简单得多；不信你可以看下文。</p>
<h3 id="安装Android_LLDB工具">安装Android LLDB工具</h3><p>要使用lldb进行调试，首先需要在调试设备上运行一个lldb-server，这个lldb-server attach到我们需要调试的进程，然后我们的开发机与这个server进行通信，就可以进行调试了。熟悉gdb调试的同学应该很清楚这一点。我们可以用Android Studio直接下载这个工具，打开SDK Manager：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1484280931189.png" width="720"></p>
<p>如上图，勾选这个即可；下载的内容会存放到你的 $ANDROID_SDK/lldb 目录下。</p>
<h3 id="使用步骤">使用步骤</h3><p>安装好必要的工具之后，就可以开始调试了；整体步骤比较简单：把lldb-server推送到调试设备并运行这个server，在开发机上连上这个server即可；以下是详细步骤。</p>
<h4 id="在手机端运行lldb-server">在手机端运行lldb-server</h4><p>如果你的调试设备是root的，那么相对来说比较简单；毕竟我们的调试进程lldb-server要attach到被调试的进程是需要一定权限的，如果是root权限那么没有限制；如果没有root，那么我们只能借助<code>run-as</code>命令来调试自己的进程；另外，被调试的进程必须是debuggable，不赘述。以下以root的设备为例（比如模拟器）</p>
<ol>
<li><p>首先把lldb-server push到调试设备。lldb-sever这个文件可以在 `$ANDROID_SDK/lldb/&lt;版本号数字&gt;/android/ 目录下找到，确认你被调试设备的CPU构架之后选择你需要的那个文件，比如大多数是arm构架，那么执行：</p>
<blockquote>
<p>adb push lldb-server /data/local/tmp/</p>
</blockquote>
</li>
<li><p>在调试设备上运行lldb-server。</p>
<blockquote>
<p>adb shell /data/local/tmp/lldb-server platform \<br>–server –listen unix-abstract:///data/local/tmp/debug.sock</p>
</blockquote>
<p>如果提示 /data/local/tmp/lldb-server: can’t execute: Permission denied，那么给这个文件加上可执行权限之后再执行上述命令：</p>
<blockquote>
<p>adb shell chmod 777 /data/local/tmp/lldb-server</p>
</blockquote>
<p>这样，调试server就在设备上运行起来了，注意要这么做需要设备拥有root权限，不然后面无法attach进程进行调试；没有root权限另有办法。另外，这个命令执行之后所在终端会进入阻塞状态，不要管它，如下进行的所有操作需要重新打开一个新的终端。</p>
</li>
</ol>
<h4 id="连接到lldb-server开始调试">连接到lldb-server开始调试</h4><p>首先打开终端执行lldb（Mac开发者工具自带这个，Windows不支持）,会进入一个交互式的环境，如下图：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1484282196260.png" width="462"></p>
<ol>
<li><p>选择使用Android调试插件。执行如下命令：</p>
<blockquote>
<p>platform select remote-android</p>
</blockquote>
<p>如果提示没有Android，那么你可能需要升级一下你的XCode；只有新版本的lldb才支持Android插件。</p>
</li>
<li><p>连接到lldb-server</p>
<p>这一步比较简单，但是没有任何官方文档有说明；使用办法是我查阅Android Studio的源码学习到的。如下：</p>
<blockquote>
<p>platform connect unix-abstract-connect:///data/local/tmp/debug.sock</p>
</blockquote>
<p>正常情况下你执行lldb-server的那个终端应该有了输出：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1484282509260.png" width="430"></p>
</li>
<li><p>attach到调试进程。首先你需要查出你要调试的那个进程的pid，直接用ps即可；打开一个新的终端执行：</p>
<blockquote>
<p>~ adb shell ps | grep lldbtest<br>u0_a53    2242  724   787496 33084 ffffffff b6e0c474 S com.example.weishu.lldbtest</p>
</blockquote>
<p>我要调试的那个进程pid是 <code>2242</code>，接下来回到lldb的那个交互式窗口执行：</p>
<blockquote>
<p>process attach -p 2242</p>
</blockquote>
<p>如果你的设备没有root，那么这一步就会失败——没有权限去调试一个别的进程；非root设备的调试方法见下文。</p>
<p>至此，调试环境就建立起来了。不需要像gdb那样设置端口转发，lldb的Android调试插件自动帮我们处理好了这些问题。虽然说了这么多，但是你熟练之后真正的步骤只有两步，灰常简单。</p>
</li>
<li><p>断点调试</p>
<p> 调试环境建立之后自然就可以进行调试了，如果进行需要学习lldb的使用方法；我这里先演示一下，不关心的可以略过。</p>
<ol>
<li><p>首先下一个断点：</p>
<blockquote>
<p>(lldb) br s -n CollectGarbageInternal<br>  Breakpoint 1: where = libart.so`art::gc::Heap::CollectGarbageInternal(art::gc::collector::GcType, art::gc::GcCause, bool), address = 0xb4648c20</p>
</blockquote>
</li>
<li><p>触发断点之后，查看当前堆栈：</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) bt</span><br><span class="line">* thread #<span class="number">8</span>: tid = <span class="number">2254</span>, <span class="number">0xb4648c20</span> libart.so`art::gc::Heap::CollectGarbageInternal(art::gc::collector::GcType, art::gc::GcCause, <span class="keyword">bool</span>), name = <span class="string">'GCDaemon</span>', stop reason = breakpoint <span class="number">1.1</span></span><br><span class="line">* frame #<span class="number">0</span>: <span class="number">0xb4648c20</span> libart.so`art::gc::Heap::CollectGarbageInternal(art::gc::collector::GcType, art::gc::GcCause, <span class="keyword">bool</span>)</span><br><span class="line">frame #<span class="number">1</span>: <span class="number">0xb464a550</span> libart.so`art::gc::Heap::ConcurrentGC(art::Thread*) + <span class="number">52</span></span><br><span class="line">frame #<span class="number">2</span>: <span class="number">0x72b17161</span> com.example.weishu.lldbtest</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看寄存器的值</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	(lldb) reg read</span><br><span class="line">General Purpose Registers:</span><br><span class="line">   r0 = <span class="number">0xb4889600</span></span><br><span class="line">   r1 = <span class="number">0x00000001</span></span><br><span class="line">   r2 = <span class="number">0x00000001</span></span><br><span class="line">   r3 = <span class="number">0x00000000</span></span><br><span class="line">   r4 = <span class="number">0xb4889600</span></span><br><span class="line">   r5 = <span class="number">0xb4835000</span></span><br><span class="line">   r6 = <span class="number">0xb47fcfe4</span>  libart.so`art::Runtime::instance_</span><br><span class="line">   r7 = <span class="number">0xa6714380</span></span><br><span class="line">   r8 = <span class="number">0xa6714398</span></span><br><span class="line">   r9 = <span class="number">0xb4835000</span></span><br><span class="line">   r10 = <span class="number">0x00000000</span></span><br><span class="line">   r11 = <span class="number">0xa6714360</span></span><br><span class="line">   r12 = <span class="number">0xb47fbb28</span>  libart.so`art::Locks::logging_lock_</span><br><span class="line">   sp = <span class="number">0xa6714310</span></span><br><span class="line">   lr = <span class="number">0xb464a551</span>  libart.so`art::gc::Heap::ConcurrentGC(art::Thread*) + <span class="number">53</span></span><br><span class="line">   pc = <span class="number">0xb4648c20</span>  libart.so`art::gc::Heap::CollectGarbageInternal(art::gc::collector::GcType, art::gc::GcCause, <span class="keyword">bool</span>)</span><br><span class="line"> 	cpsr = <span class="number">0x20000030</span></span><br></pre></td></tr></table></figure>
<p> 我们可以看到寄存器 <code>r0</code>的值为 <code>0xb4889600</code>，这个值就是 `CollectGarbageInternal<br> 函数的第一个参数，this指针，也就是当前Heap对象的地址。在ARM下，r0~r4存放函数的参数，超过四个的参数放在栈上，具体如何利用这些寄存器的信息需要了解一些ARM汇编知识。</p>
</li>
<li><p>查看运行的汇编代码</p>
 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) di -p</span><br><span class="line">	libart.so`art::gc::Heap::CollectGarbageInternal:</span><br><span class="line">-&gt;  <span class="number">0xb4648c20</span> &lt;+<span class="number">0</span>&gt;:  <span class="keyword">push.w </span>&#123;<span class="literal">r4</span>, <span class="literal">r5</span>, <span class="literal">r6</span>, <span class="literal">r7</span>, <span class="literal">r8</span>, <span class="literal">r9</span>, <span class="literal">r10</span>, <span class="literal">r11</span>, <span class="literal">lr</span>&#125;</span><br><span class="line">	<span class="number">0xb4648c24</span> &lt;+<span class="number">4</span>&gt;:  <span class="keyword">subw </span>  <span class="literal">sp</span>, <span class="literal">sp</span>, <span class="number">#0x52c</span></span><br><span class="line">	<span class="number">0xb4648c28</span> &lt;+<span class="number">8</span>&gt;:  <span class="keyword">ldr.w </span> <span class="literal">r9</span>, [<span class="literal">pc</span>, <span class="number">#0xa9c</span>]</span><br><span class="line">	<span class="number">0xb4648c2c</span> &lt;+<span class="number">12</span>&gt;: <span class="keyword">add </span>   <span class="literal">r4</span>, <span class="literal">sp</span>, <span class="number">#0x84</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h4 id="没有root设备的调试办法">没有root设备的调试办法</h4><p>如果没有root权限，那么我可以借助run-as命令。run-as可以让我们以某一个app的身份执行命令——如果我们以被调试的那个app的身份进行attach，自然是可以成功的。</p>
<p>假设被调试的app包名为 <code>com.example.lldb</code>，那么首先想办法把 <code>lldb-server</code>这个文件推送到这个app自身的目录：</p>
<ol>
<li><p><code>adb push</code>直接这么做不太方便（还需要知道userid)，我们先push到 /data/local/tmp/</p>
<blockquote>
<p>adb push lldb-server /data/local/tmp/</p>
</blockquote>
</li>
<li><p>然后执行adb shell，连接到Android shell，执行</p>
<blockquote>
<p>run-as com.example.lldb`</p>
</blockquote>
</li>
<li><p>拷贝这个文件到本App的目录，并修改权限；（由于有的手机没有cp命令，改用cat)</p>
<blockquote>
<p>cat /data/local/tmp/lldb-server &gt; lldb-server<br>chmod 777 lldb-server</p>
</blockquote>
</li>
<li><p>运行lldb-server</p>
<blockquote>
<p>lldb-server platform –listen unix-abstract:///data/local/tmp/debug.sock</p>
</blockquote>
</li>
</ol>
<p>接下来的步骤就与上面root设备的调试过程完全一样了 :)</p>
<h2 id="后记">后记</h2><p>终于完成了Android调试这一系列的文章，时间跨度长达一年；从Java到C/C++再到汇编级别的调试，从有源码到无源码，从Application层到Framework层，任何代码都可以进行调试。借助强大的IDE以及调试器，我们不仅可以快速定位和解决问题，还可以深入学习任何一个复杂的模块。尤记得用探索用lldb进行native调试的过程，网上没有任何android方面的教程，唯一的学习资料就是Android Studio调试模块的源码以及LLDB Android插件的源码；这其中碰的壁和踩过的坑不计其数。好在最后终于一一解决，可以睡个安稳觉了 ~_~</p>
<ol>
<li><a href="http://weishu.me/2015/12/21/android-studio-debug-tips-you-may-not-know/">Android Studio你不知道的调试技巧</a></li>
<li><a href="http://weishu.me/2016/05/30/how-to-debug-android-framework/">如何调试Android Framework</a></li>
<li><a href="#">如何调试Android Framework Native</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>半年前写了一篇文章，介绍 <a href="http://weishu.me/2016/05/30/how-to-debug-android-framework/">如何调试Android Framework</a>，但是只提到了Framework中Java代码的调试办法，但实际上有很多代码都是用C++实现的；无奈当时并并没有趁手的native调试工具，无法做到像Java调试那样简单直观（gdb+eclipse/ida之流虽然可以但是不完美），于是就搁置下了。</p>
<p>Android Studio 2.2版本带来了全新的对Android Native代码的开发以及调试支持，另外LLDB的Android调试插件也日渐成熟，我终于可以把这篇文章继续下去了！本文将带来Android Framework中native代码的调试方法。</p>
<p>在正式介绍如何调试之前，必须先说明一些基本的概念。调试器在调试一个可执行文件的时候，必须知道一些调试信息才能进行调试，这个调试信息可多可少（也可以没有）。最直观的比如行号信息，如果调试器知道行号信息，那么在进行调试的时候就能知道当前执行到了源代码的哪一行，如果调试器还知道对应代码的源文件在哪，那么现代IDE的调试器一般就能顺着源码带你飞了，这就是所谓的源码调试。相反，如果没有行号和源码信息，那么只能进行更低级别的调试了，调试器只能告诉你一些寄存器的值；而当前运行的代码也只是PC寄存器所指向的二进制数据，这些数据要么是虚拟机指令，要么是汇编指令；这就是所谓的无源码调试。显然无源码调试相比源码级别的调试要麻烦的多；接下来将围绕这两个方面分别介绍。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="debug" scheme="http://weishu.me/tags/debug/"/>
    
      <category term="framework" scheme="http://weishu.me/tags/framework/"/>
    
      <category term="native" scheme="http://weishu.me/tags/native/"/>
    
      <category term="source" scheme="http://weishu.me/tags/source/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[史上最简单Android源码编译环境搭建方法]]></title>
    <link href="http://weishu.me/2016/12/30/simple-way-to-compile-android-source/"/>
    <id>http://weishu.me/2016/12/30/simple-way-to-compile-android-source/</id>
    <published>2016-12-29T17:08:41.000Z</published>
    <updated>2019-01-30T04:06:02.849Z</updated>
    <content type="html"><![CDATA[<p>有史以来，Android源码编译环境的搭建始终是一件麻烦事儿。网上有数不清的文章介绍如何编译Android源代码，但是他们要么方法复杂、步骤太多；要么自称解决了一些编译问题（需要修改头文件，系统配置等），让人对其可信度产生质疑。有的童鞋硬着头皮照做了，但是由于伟大的GFW，大部分都死在了第一步——repo脚本都下载不下来，就算下载过了过不了gerrit那一关。另外，就算你具备科学上网的能力，下载时间又成为了拦路虎；普通的VPN通常需要下载七八个小时，简直就是痛不欲生。久而久之，很多人对下载编译Android源码望而却步。</p>
<p>今天，我给大家提供一个极其简单、稳定的方案，来解决Android源码的下载编译问题。</p>
<p>首先，下载问题可以通过镜像解决；<a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="external">清华镜像</a> 和 <a href="https://lug.ustc.edu.cn/wiki/mirrors/help/aosp" target="_blank" rel="external">科大镜像</a> 都是非常不错的选择，正常情况下一到两个小时即可下载完一个Android源码分支。</p>
<p>然后就是编译环境问题。由于Android源码庞大，依赖复杂；一旦使用的编译工具链有细微的不同就可能引发编译失败。<a href="https://source.android.com/source/initializing.html" target="_blank" rel="external">官方文档</a> 推荐使用Ubuntu 14.04进行编译。如果我们用Windows或者Mac系统，传统方式是使用虚拟机；但是在今天，我们完全可以使用 <strong>Docker</strong> 替代！！借助Docker，我们可以不用担心编译环境问题；不论我们的开发机是什么系统，可以使用Docker创建Ubuntu Image，并且直接在这个Ubuntu系统环境中创建编译所需要的工具链（JDK，ubuntu系统的依赖库等等）；而且，Docker运行的Ubuntu的系统开销比虚拟机低得多，这样下载以及编译速度就有了质的提升。更重要的是，这个环境可以作为一个Image打包发布！这样，你在不同的开发机，还有你与你的同事之间有了同一套编译环境，这会省去很多不必要的麻烦。关于Docker的更多内容，见 <a href="http://www.docker.com/" target="_blank" rel="external">Docker官网</a></p>
<a id="more"></a>
<p>当然，这个伟大的创举并不是我完成的，而是 <a href="https://github.com/kylemanna/docker-aosp" target="_blank" rel="external">kylemanna/docker-aosp</a>！我针对Docker以及天朝的网络环境做了一部分修改，fork了一份 <a href="https://github.com/tiann/docker-aosp" target="_blank" rel="external">tiann/docker-aosp</a>。</p>
<p>废话不多说，我们看看具体如何使用，以及怎么个简单法。</p>
<h2 id="使用步骤">使用步骤</h2><h3 id="安装Docker">安装Docker</h3><p>Docker的下载地址见 <a href="https://www.docker.com/products/overview" target="_blank" rel="external">Docker下载</a> ；下载完毕安装即可。</p>
<h3 id="准备工作">准备工作</h3><p>如果你不是Mac系统，可以直接略过这一步。</p>
<p>Mac的文件系统默认不区分大小写，这不满足Android源码编译系统的要求（编译的时候直接Error）；因此需要单独创建一个大小写敏感的磁盘映像。步骤如下：</p>
<ol>
<li>打开Mac的系统软件：<strong>磁盘工具</strong></li>
<li><p>CMD + N，创建新的磁盘映像，参数设置如下图：</p>
<p> <img src="http://weishu.dimensionalzone.com/201601/1483019239159.png" width="430"></p>
<p> 其中磁盘大小设置为 50~100G合适，<strong>格式一定要选择带区分大小写标志的。</strong></p>
</li>
</ol>
<h3 id="开始下载编译">开始下载编译</h3><p>真正的下载编译过程相当简单，脚本会自动完成；步骤如下：</p>
<ol>
<li><p>设置Android源码下载存放的目录；如果是Mac系统，这一步必须设置为一个大小写敏感的目录；不然后面编译的时候会失败。如果不设置这一步，那么源码会下载到 <code>~/aosp-root</code> 目录；设置过程如下：</p>
<p> <code>export AOSP_VOL=/Volume/Android/</code></p>
</li>
<li><p>下载wrapper脚本；如果需要下载其他系统版本，直接修改下载完毕后的build-nougat.sh文件的 android-4.4.4_r2.0.1改成你需要的分支即可，分支的信息见 <a href="https://source.android.com/source/build-numbers.html#source-code-tags-and-builds" target="_blank" rel="external">分支列表</a></p>
<p> <code>curl -O https://raw.githubusercontent.com/kylemanna/docker-aosp/master/tests/build-nougat.sh</code></p>
</li>
<li><p>运行脚本，开始自动下载安装过程；Windows系统可以使用 <a href="https://msdn.microsoft.com/en-us/commandline/wsl/about" target="_blank" rel="external">Bash for Windows</a> 或者cygwin。</p>
<p> <code>bash ./build-nougat.sh</code></p>
</li>
</ol>
<p>这样，所有的工作就都做完了。只需静静等待即可；时间视下载速度而定，清华的镜像速度还可以，笔者使用不到2小时就完成了下载编译过程。</p>
<p>三步完成，是不是灰常简单？赶紧下载编译安装属于你的Android系统吧 ^_^</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有史以来，Android源码编译环境的搭建始终是一件麻烦事儿。网上有数不清的文章介绍如何编译Android源代码，但是他们要么方法复杂、步骤太多；要么自称解决了一些编译问题（需要修改头文件，系统配置等），让人对其可信度产生质疑。有的童鞋硬着头皮照做了，但是由于伟大的GFW，大部分都死在了第一步——repo脚本都下载不下来，就算下载过了过不了gerrit那一关。另外，就算你具备科学上网的能力，下载时间又成为了拦路虎；普通的VPN通常需要下载七八个小时，简直就是痛不欲生。久而久之，很多人对下载编译Android源码望而却步。</p>
<p>今天，我给大家提供一个极其简单、稳定的方案，来解决Android源码的下载编译问题。</p>
<p>首先，下载问题可以通过镜像解决；<a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/">清华镜像</a> 和 <a href="https://lug.ustc.edu.cn/wiki/mirrors/help/aosp">科大镜像</a> 都是非常不错的选择，正常情况下一到两个小时即可下载完一个Android源码分支。</p>
<p>然后就是编译环境问题。由于Android源码庞大，依赖复杂；一旦使用的编译工具链有细微的不同就可能引发编译失败。<a href="https://source.android.com/source/initializing.html">官方文档</a> 推荐使用Ubuntu 14.04进行编译。如果我们用Windows或者Mac系统，传统方式是使用虚拟机；但是在今天，我们完全可以使用 <strong>Docker</strong> 替代！！借助Docker，我们可以不用担心编译环境问题；不论我们的开发机是什么系统，可以使用Docker创建Ubuntu Image，并且直接在这个Ubuntu系统环境中创建编译所需要的工具链（JDK，ubuntu系统的依赖库等等）；而且，Docker运行的Ubuntu的系统开销比虚拟机低得多，这样下载以及编译速度就有了质的提升。更重要的是，这个环境可以作为一个Image打包发布！这样，你在不同的开发机，还有你与你的同事之间有了同一套编译环境，这会省去很多不必要的麻烦。关于Docker的更多内容，见 <a href="http://www.docker.com/">Docker官网</a></p>]]>
    
    </summary>
    
      <category term="android source" scheme="http://weishu.me/tags/android-source/"/>
    
      <category term="compile" scheme="http://weishu.me/tags/compile/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化之虚拟机调优]]></title>
    <link href="http://weishu.me/2016/12/23/dive-into-android-optimize-vm-heap/"/>
    <id>http://weishu.me/2016/12/23/dive-into-android-optimize-vm-heap/</id>
    <published>2016-12-23T14:53:09.000Z</published>
    <updated>2019-01-30T04:06:02.837Z</updated>
    <content type="html"><![CDATA[<p>介绍完 <a href="https://zhuanlan.zhihu.com/p/24414378" target="_blank" rel="external">深入学习Android：虚拟机&amp;运行时</a> 之后，很多小伙伴问我，你描述的这些知识结构看起来艰深晦涩高大上，实际工作中能有多大用途呢？今天我就简单举个例子。</p>
<p>众所周知，我们的Android App运行在Java虚拟机之上，而Java是一门带GC的语言。在虚拟机进行垃圾回收的时候，要做一件很形象的事叫做STW（stop the world）；也就是说，为了回收那些不再使用的对象，虚拟机必须要停止所有的线程来进行必要的工作。虽说这一点在ART运行时上得到了很大的改善，但是GC的存在对App运行时的性能始终有着微妙的影响。如果你观察过手机输入的日志，一定会看到类似如下的内容：</p>
<blockquote>
<p>12-23 18:46:07.300 28643-28658/? I/art: Background sticky concurrent mark sweep GC freed 15442(1400KB) AllocSpace objects, 8(128KB) LOS objects, 4% free, 32MB/33MB, paused 10.356ms total 53.023ms at GCDaemon thread CareAboutPauseTimes 1<br>12-23 18:46:12.250 28643-28658/? I/art: Background partial concurrent mark sweep GC freed 28723(1856KB) AllocSpace objects, 6(92KB) LOS objects, 11% free, 31MB/35MB, paused 2.380ms <strong>total 108.502ms</strong> at GCDaemon thread CareAboutPauseTimes 1</p>
</blockquote>
<p>上面的日志反映一个事实：GC是有代价的。有很多有关性能优化的文章提到GC，会花长篇大论讲述垃圾回收的过程以及原理，但所做的策略无非就是「不要创建不必要的对象」，「避免内存泄漏」最终就提到MAT，LeakCanary等工具的使用上去了；我只能说这很苍白无力——写出这样的代码、学会使用工具应该是基本要求。</p>
<a id="more"></a>
<p>虽说Android也支持NDK开发，但是我们不可能把所有代码全用C++重写吧？那么，我们有没有办法能<strong>影响GC的策略</strong>，使得GC尽量减少呢？答案是肯定的。原理在于Android的进程机制——每一个App都有一个单独的虚拟机实例，在App自己的进程空间，我们有相当大的主动权。</p>
<p>我举个简单的例子。（下面的内容基于Android 5.1系统，所有的原理以及代码不保证能在其他系统版本甚至ROM上工作）</p>
<p>Android上所有的App进程都从Zygote进程fork而来，App子进程采用copy on write机制共享了Zygote进程的进程空间；其中Android虚拟机以及运行时的创建在Android系统启动，创建Zygote进程的时候已经完成了。垃圾回收机制是虚拟机的一部分，因此，我们先从Zygote进程的启动过程谈起。</p>
<p>我们知道，Android系统是基于Linux内核的，而在Linux系统中，所有的进程都是init进程的子孙进程，Zygote进程也不例外，它是在系统启动的过程，由init进程创建的。在系统启动脚本system/core/rootdir/init.rc文件中，我们可以看到启动Zygote进程的脚本命令：</p>
<blockquote>
<p>service zygote /system/bin/app_process -Xzygote /system/bin –zygote –start-system-server</p>
</blockquote>
<p>也就是说init进程通过执行 /system/bin/app_process 这个可执行文件来创建zygote进程；app_process的源码可见 <a href="http://androidxref.com/5.1.1_r6/xref/frameworks/base/cmds/app_process/app_main.cpp" target="_blank" rel="external">这里</a>；在main函数的最后有这么一句话：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">    runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br></pre></td></tr></table></figure>
<p>最终调用到了<a href="http://androidxref.com/5.1.1_r6/xref/frameworks/base/core/jni/AndroidRuntime.cpp" target="_blank" rel="external">AndroidRuntime.cpp</a> 的<code>start</code>函数，而这个函数中最重要的一步就是启动虚拟机：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JNIEnv* env;</span><br><span class="line"><span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数相当之长，不过都是解析虚拟机启动的参数，比如堆大小等等；<a href="http://droidyue.com/blog/2015/08/01/dive-into-android-large-heap/index.html" target="_blank" rel="external">探究largeHeap</a> 这篇文章对一些重要的参数做了说明，这些参数对虚拟机非常重要，后面我们会见到。解析参数完毕之后，最终调用<code>JNI_CreateJavaVM</code>来真正创建Java虚拟机。这个接口是Android虚拟机定义的三个接口这一，dalvik能切换到art很大程度上与这个有关。它的具体是现在 <a href="http://androidxref.com/5.1.1_r6/xref/art/runtime/jni_internal.cc" target="_blank" rel="external">jni_internal.cc</a>；JNI_CreateJavaVM 这个函数在拿到虚拟机的相关参数之后，就直接创建了Android运行时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Runtime::Create(options, ignore_unrecognized)) &#123;</span><br><span class="line">  <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Runtime的创建非常复杂，其中，跟GC相关的是，App的堆空间被创建出来了；Heap的构造函数接受了一大堆参数，这些参数对于GC有着重大的影响，如果要调整GC的策略，从这里入手，是比较靠谱的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">heap_ = <span class="keyword">new</span> gc::Heap(options-&gt;heap_initial_size_,</span><br><span class="line">                     options-&gt;heap_growth_limit_,</span><br><span class="line">                     options-&gt;heap_min_free_,</span><br><span class="line">                     options-&gt;heap_max_free_,</span><br><span class="line">                     options-&gt;heap_target_utilization_,</span><br><span class="line">                     options-&gt;foreground_heap_growth_multiplier_,</span><br><span class="line">                     options-&gt;heap_maximum_size_,</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>其中 heap_initial<em>size</em> 是堆的初始大小，heap_growth<em>limit</em>是堆增长的最大限制，heap_min<em>free</em>以及heap_max<em>free</em> 是什么呢？详细的用途见 <a href="http://hello2mao.github.io/2015/12/16/Android_ART_GC_GrowForUtilization.html" target="_blank" rel="external">Android ART GC之GrowForUtilization的分析</a> 简单来说就是，Android系统为了保证堆的利用效率，减少堆中的内存碎片；每次执行GC回收到一些内存之后，会对堆大小进行调整。比如说你进入了一个图片非常多的页面，这时候申请了100M内存，当你退出这个页面的时候，这100M自然就被回收了，成为了空闲内存；但是系统为了防止浪费，并不会把这100M的空闲内存全部留给你，而是做一个调整。而具体调整到多大，则与   <code>heap_min_free_</code>, <code>heap_max_free_</code> 以及 <code>heap_target_utilization_</code> 相关。</p>
<p>说到这里，原理性的部分已经解释完了；除了流程稍微复杂，也没有什么难点。那么这个堆，跟我们的启动性能优化有什么关系呢？</p>
<p>在Android App的启动过程中，进程占用的内存在一段时间内是持续上涨的；假设堆的初始大小为8M，启动过程中的占用内存峰值30M；启动过程的进行中，伴随着大量临时对象的创建，它们朝生夕死，不久就被回收掉：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1482494040946.png" width="446"></p>
<p>如上图，这是某次启动过程中某App的内存占用情况；我们看到了有很多小折线，专业术语叫做内存抖动；原因呢，也很明显——有大量的临时对象被创建。怎么解决？有人说，不要创建大量的临时对象。道理我都懂，可是做不到。对于很多大型App来说，启动的过程是相当复杂的，而很多操作也不能简单滴去掉。那么问题来了，30M并不是一个很大的数字，为什么系统如此恐慌，还需要不停滴回收内存呢？</p>
<p>有一种冷，叫做你妈妈觉得你冷。垃圾回收并不是说有垃圾了才去回收，而是只要系统觉得你需要回收垃圾就会进行。</p>
<p>那么，能不能在启动过程中让堆保持持续增长而不进行GC呢？毕竟，30M并不会造成什么OOM。是什么原因导致系统没有这么做？答案是空闲内存。比如说一开始堆有8M，随着启动过程的进行，堆增长到了24M；这时候执行了一次GC，回收掉了8M内存，也是堆回到了16M；我们还有8M的空闲内存。系统就会说，小伙子，你占这么多空闲内存干嘛呀？来妈妈帮你保管，于是你就只剩下2M的空闲内存了。但显然App使用的堆内存很快就会超过18M，于是又引发一系列GC以及堆大小调整，周而复始直至启动完成内存平稳。至此，我们的结论已经很明显：</p>
<p><strong>如果我们能够调整 heap_min<em>free</em> 以及 heap_max<em>free</em>，就能很大程度上影响GC的过程</strong></p>
<p>如何调整这两个参数的大小呢？<em>拿到Heap对象的指针，找到这两个参数的偏移量，直接修改内存即可</em> 这里稍微需要一点C++内存布局的知识；至于如何拿到Heap对象的指针，只有去源码里面寻找答案了。这里我给出最终的实现代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyHeap</span><span class="params">(<span class="keyword">unsigned</span> size)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// JavaVMExt指针 可以从JNI_OnLoad中拿到 </span></span><br><span class="line">	JavaVMExt * vmExt = (JavaVMExt *)g_javaVM;</span><br><span class="line">	<span class="keyword">if</span> (vmExt-&gt;runtime == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span>* runtime_ptr = (<span class="keyword">char</span>*) vmExt-&gt;runtime;</span><br><span class="line">    <span class="keyword">void</span>** heap_pp = (<span class="keyword">void</span>**)(runtime_ptr + <span class="number">188</span>);</span><br><span class="line">    <span class="keyword">char</span>* c_heap = (<span class="keyword">char</span>*) (*heap_pp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* min_free_offset = c_heap + <span class="number">532</span>;</span><br><span class="line">    <span class="keyword">char</span>* max_free_offset = min_free_offset + <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">char</span>* target_utilization_offset = max_free_offset + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span>* min_free_ = (<span class="keyword">size_t</span>*) min_free_offset;</span><br><span class="line">    <span class="keyword">size_t</span>* max_free_ = (<span class="keyword">size_t</span>*) max_free_offset;</span><br><span class="line">    </span><br><span class="line">    *min_free_ = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">2</span>;</span><br><span class="line">    *max_free_ = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改之后启动过程中内存占用如下，可以看到我们的目的已经达到：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1482496070927.png" width="452"></p>
<p>顺便说明一下，上面的代码没有考虑任何的可移植性和适配性，只起演示作用。真正投入使用是一个体力活：其一，我们依赖了某特定Android版本某个类的内存布局，其中的成员变量的偏移量可能不同版本不同；其二，这个 min<em>free</em> 以及 max<em>free</em> 具体调整为多大，跟手机的物理内存，App使用的内存，手机配置的初始堆大小等等因素密切相关；调整一个合适的参数需要花费一些时间，Android机型如此之多，这里需要一些小技巧。</p>
<p>不知道上面这个例子有木有让你感受到深入系统底层，那种呼风唤雨无所不能的快感？可能很多人觉得我们都是写写if else而已，调节面改动画写业务已经够了；但我想说明的是，深入学习系统原理是非常有好处的，它可以赋予你在应用层永远无法拥有的能力。</p>
<p>另外留个作业，我们上面提到观察GC的次数，除了使用debug模式下用工具观察，能不能用代码监听到呢？本文主要说明了虚拟机运行时等native层的重要性，而这个答案可以在Java Framework中找到 ^_^</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>介绍完 <a href="https://zhuanlan.zhihu.com/p/24414378">深入学习Android：虚拟机&amp;运行时</a> 之后，很多小伙伴问我，你描述的这些知识结构看起来艰深晦涩高大上，实际工作中能有多大用途呢？今天我就简单举个例子。</p>
<p>众所周知，我们的Android App运行在Java虚拟机之上，而Java是一门带GC的语言。在虚拟机进行垃圾回收的时候，要做一件很形象的事叫做STW（stop the world）；也就是说，为了回收那些不再使用的对象，虚拟机必须要停止所有的线程来进行必要的工作。虽说这一点在ART运行时上得到了很大的改善，但是GC的存在对App运行时的性能始终有着微妙的影响。如果你观察过手机输入的日志，一定会看到类似如下的内容：</p>
<blockquote>
<p>12-23 18:46:07.300 28643-28658/? I/art: Background sticky concurrent mark sweep GC freed 15442(1400KB) AllocSpace objects, 8(128KB) LOS objects, 4% free, 32MB/33MB, paused 10.356ms total 53.023ms at GCDaemon thread CareAboutPauseTimes 1<br>12-23 18:46:12.250 28643-28658/? I/art: Background partial concurrent mark sweep GC freed 28723(1856KB) AllocSpace objects, 6(92KB) LOS objects, 11% free, 31MB/35MB, paused 2.380ms <strong>total 108.502ms</strong> at GCDaemon thread CareAboutPauseTimes 1</p>
</blockquote>
<p>上面的日志反映一个事实：GC是有代价的。有很多有关性能优化的文章提到GC，会花长篇大论讲述垃圾回收的过程以及原理，但所做的策略无非就是「不要创建不必要的对象」，「避免内存泄漏」最终就提到MAT，LeakCanary等工具的使用上去了；我只能说这很苍白无力——写出这样的代码、学会使用工具应该是基本要求。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="heap" scheme="http://weishu.me/tags/heap/"/>
    
      <category term="performance" scheme="http://weishu.me/tags/performance/"/>
    
      <category term="vm" scheme="http://weishu.me/tags/vm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[请不要滥用SharedPreference]]></title>
    <link href="http://weishu.me/2016/10/13/sharedpreference-advices/"/>
    <id>http://weishu.me/2016/10/13/sharedpreference-advices/</id>
    <published>2016-10-12T16:31:19.000Z</published>
    <updated>2019-01-30T04:06:02.846Z</updated>
    <content type="html"><![CDATA[<p>SharedPreference是Android上一种非常易用的轻量级存储方式，由于其API及其友好，得到了很多很多开发者的青睐。但是，SharedPreference并不是万能的，如果把它用在不合适的使用场景，那么将会带来灾难性的后果；本文将讲述一些SharedPreference的使用误区。</p>
<h2 id="存储超大的value">存储超大的value</h2><p>第一次看到下面这个sp的时候，我的内心是崩溃的：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1476286071563.png" width="664"></p>
<p>一个默认的sp有90K，当我打开它的时候，我都快哭了：除了零零星星的几个很小的key之外，存储了一个炒鸡大的key，这一个key至少占了其中的89K。知道这是什么概念吗？</p>
<p>在小米1S这种手机上，<strong>就算获取这个sp里面一个很小的key，会花费120+ms！！</strong>那个毫不相干的key拖慢了其他所有key的读取速度！当然，在性能稍好的手机上，这个问题不是特别严重。但是要知道，120ms这个是完全不能忍的！</p>
<p>之所以说SharedPreference（下文简称sp）是一种轻量级的存储方式，是它的设计所决定的：sp在创建的时候会把整个文件全部加载进内存，如果你的sp文件比较大，那么会带来两个严重问题：</p>
<ol>
<li>第一次从sp中获取值的时候，有可能阻塞主线程，使界面卡顿、掉帧。</li>
<li>解析sp的时候会产生大量的临时对象，导致频繁GC，引起界面卡顿。</li>
<li>这些key和value会永远存在于内存之中，占用大量内存。</li>
</ol>
<a id="more"></a>
<p>也许有童鞋会说，sp的加载不是在子线程么，怎么会卡住主线程？子线程IO就一定不会阻塞主线程吗？</p>
<p>下面是默认的sp实现SharedPreferenceImpl这个类的getString函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(String key, @Nullable String defValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">        String v = (String)mMap.get(key);</span><br><span class="line">        <span class="keyword">return</span> v != <span class="keyword">null</span> ? v : defValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看看这个awaitLoadedLocked：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">awaitLoadedLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!mLoaded) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException unused) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一把锁就是挂在那里！！这意味着，如果你直接调用getString，主线程会等待加载sp的那么线程加载完毕！这不就把主线程卡住了么？</p>
<p>另外，有一个叫诀窍可以节省一下等待的时间：既然getString之类的操作会等待sp加载完成，而加载是在另外一个线程执行的，我们可以让sp先去加载，做一堆事情，然后再getString！如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先让sp去另外一个线程加载</span></span><br><span class="line">SharedPreferences sp = getSharedPreferences(<span class="string">"test"</span>, MODE_PRIVATE);</span><br><span class="line"><span class="comment">// 做一堆别的事情</span></span><br><span class="line">setContentView(testSpJson);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OK,这时候估计已经加载完了吧,就算没完,我们在原本应该等待的时间也做了一些事!</span></span><br><span class="line">String testValue = sp.getString(<span class="string">"testKey"</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>更为严重的是，被加载进来的这些大对象，会永远存在于内存之中，不会被释放。我们看看ContextImpl这个类，在getSharedPreference的时候会把所有的sp放到一个静态变量里面缓存起来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ArrayMap&lt;File, SharedPreferencesImpl&gt; getSharedPreferencesCacheLocked() &#123;</span><br><span class="line">    <span class="keyword">if</span> (sSharedPrefsCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sSharedPrefsCache = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String packageName = getPackageName();</span><br><span class="line">    ArrayMap&lt;File, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefsCache.get(packageName);</span><br><span class="line">    <span class="keyword">if</span> (packagePrefs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        packagePrefs = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">        sSharedPrefsCache.put(packageName, packagePrefs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> packagePrefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这个<strong>static</strong>的<code>sSharedPrefsCache</code>，它保存了你所有使用的sp，然后sp里面有一个成员<code>mMap</code>保存了所有的键值对；这样，你程序中使用到的那些个sp永远就呆在内存中，是不是不寒而栗？！</p>
<p>所以，<strong>请不要在sp里面存储炒鸡大的key</strong>碰到这样的猪队友，请让他自行检讨！！赶紧把自家App检查一下！！</p>
<h2 id="存储JSON等特殊符号很多的value">存储JSON等特殊符号很多的value</h2><p>还有一些童鞋，他在sp里面存json或者HTML；这么做不是不可以，但是，如果这个json相对较大，那么也会引起sp读取速度的急剧下降。</p>
<p>JSON或者HTML格式存放在sp里面的时候，需要转义，这样会带来很多<code>&amp;</code>这种特殊符号，sp在解析碰到这个特殊符号的时候会进行特殊的处理，引发额外的字符串拼接以及函数调用开销。而JSON本来就是可以用来做配置文件的，你干嘛又把它放在sp里面呢？多此一举。下面我写个demo验证一下。</p>
<p>下面这个sp是某个app的换肤配置：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1476282570956.png" width="696"></p>
<p>我们先用sp进行读取，然后用直接把它丢json文件，直接读取并且解析；json使用的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValueByJson</span><span class="params">(Context context, String key)</span> </span>&#123;</span><br><span class="line">    File jsonFile = <span class="keyword">new</span> File(context.getFilesDir().getParent() + File.separator + SP_DIR_NAME, <span class="string">"skin_beta2.json"</span>);</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    ByteArrayOutputStream bao = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(jsonFile);</span><br><span class="line">        FileChannel channel = fis.getChannel();</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1</span> &lt;&lt; <span class="number">13</span>); <span class="comment">// 8K</span></span><br><span class="line">        <span class="keyword">int</span> i1;</span><br><span class="line">        <span class="keyword">while</span> ((i1 = channel.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            bao.write(buffer.array(), <span class="number">0</span>, i1);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String content = bao.toString();</span><br><span class="line">        JSONObject jsonObject = <span class="keyword">new</span> JSONObject(content);</span><br><span class="line">        <span class="keyword">return</span> jsonObject.getInt(key);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"not a json file"</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        close(fis);</span><br><span class="line">        close(bao);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我的测试结果是：直接解析JSON比在xml里面要快一倍！在小米1S上结果如下：</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>json</th>
<th>sp</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mi 1S</td>
<td>80</td>
<td>38</td>
</tr>
<tr>
<td>Nexus5X</td>
<td>3.5</td>
<td>6.5</td>
</tr>
</tbody>
</table>
<p>这个JSON的读取还没有做任何的优化，提升潜力巨大！因此，<strong>如果你需要用JSON做配置，请不要把它存放在sp里面！！</strong></p>
<h2 id="多次edit多次apply">多次edit多次apply</h2><p>我见过这样的使用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences sp = getSharedPreferences(<span class="string">"test"</span>, MODE_PRIVATE);</span><br><span class="line">sp.edit().putString(<span class="string">"test1"</span>, <span class="string">"sss"</span>).apply();</span><br><span class="line">sp.edit().putString(<span class="string">"test2"</span>, <span class="string">"sss"</span>).apply();</span><br><span class="line">sp.edit().putString(<span class="string">"test3"</span>, <span class="string">"sss"</span>).apply();</span><br><span class="line">sp.edit().putString(<span class="string">"test4"</span>, <span class="string">"sss"</span>).apply();</span><br></pre></td></tr></table></figure>
<p>每次edit都会创建一个Editor对象，额外占用内存；当然多创建几个对象也影响不了多少；但是，多次apply也会卡界面你造吗？</p>
<p>有童鞋会说，apply不是在别的线程些磁盘的吗，怎么可能卡界面？我带你仔细看一下源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    <span class="keyword">final</span> Runnable awaitCommit = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mcr.writtenToDiskLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    QueuedWork.add(awaitCommit);</span><br><span class="line"></span><br><span class="line">    Runnable postWriteRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                awaitCommit.run();</span><br><span class="line">                QueuedWork.remove(awaitCommit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意两点，第一，把一个带有await的runnable添加进了<code>QueueWork</code>类的一个队列；第二，把这个写入任务通过enqueueDiskWrite丢给了一个<strong>只有单个线程</strong>的线程池执行。</p>
<p>到这里一切都OK，在子线程里面写入不会卡UI。但是，你去ActivityThread类的handleStopActivity里看一看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleStopActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> show, <span class="keyword">int</span> configChanges, <span class="keyword">int</span> seq)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关。。</span></span><br><span class="line">    <span class="comment">// Make sure any pending writes are now committed.</span></span><br><span class="line">    <span class="keyword">if</span> (!r.isPreHoneycomb()) &#123;</span><br><span class="line">        QueuedWork.waitToFinish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>waitToFinish?? 又要等？源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">waitToFinish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Runnable toFinish;</span><br><span class="line">    <span class="keyword">while</span> ((toFinish = sPendingWorkFinishers.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        toFinish.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还记得这个<code>toFinish</code>的Runnable是啥吗？就是上面那个<code>awaitCommit</code>它里面就一句话，等待写入线程！！如果在Activity Stop的时候，已经写入完毕了，那么万事大吉，不会有任何等待，这个函数会立马返回。但是，如果你使用了太多次的apply，那么意味着写入队列会有很多写入任务，而那里就只有一个线程在写。当App规模很大的时候，这种情况简直就太常见了！</p>
<p>因此，虽然apply是在子线程执行的，但是请不要无节制地apply；commit我就不多说了吧？直接在当前线程写入，如果你在主线程干这个，小心挨揍。</p>
<h2 id="用来跨进程">用来跨进程</h2><p>还有童鞋发现sp有一个貌似可以提供「跨进程」功能的FLAG——<code>MODE_MULTI_PROCESS</code>,我们看看这个FLAG的文档：</p>
<blockquote>
<p>@deprecated MODE_MULTI_PROCESS does not work reliably in<br>some versions of Android, and furthermore does not provide any mechanism for reconciling concurrent modifications across processes.  Applications should not attempt to use it.  Instead, they should use an explicit cross-process data management approach such as {@link android.content.ContentProvider ContentProvider}.</p>
</blockquote>
<p>文档也说了，这玩意在某些Android版本上不可靠，并且未来也不会提供任何支持，要是用跨进程数据传输需要使用类似ContentProvider的东西。而且，SharedPreference的文档也特别说明：</p>
<blockquote>
<p>Note: This class does not support use across multiple processes.</p>
</blockquote>
<p>那么我们姑且看一看，设置了这个Flag到底干了啥；在SharedPreferenceImpl里面，没有发现任何对这个Flag的使用；然后我们去ContextImpl类里面找找getSharedPreference的时候做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SharedPreferences <span class="title">getSharedPreferences</span><span class="params">(File file, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">    checkMode(mode);</span><br><span class="line">    SharedPreferencesImpl sp;</span><br><span class="line">    <span class="keyword">synchronized</span> (ContextImpl.class) &#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked();</span><br><span class="line">        sp = cache.get(file);</span><br><span class="line">        <span class="keyword">if</span> (sp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sp = <span class="keyword">new</span> SharedPreferencesImpl(file, mode);</span><br><span class="line">            cache.put(file, sp);</span><br><span class="line">            <span class="keyword">return</span> sp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((mode &amp; Context.MODE_MULTI_PROCESS) != <span class="number">0</span> ||</span><br><span class="line">        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        <span class="comment">// If somebody else (some other process) changed the prefs</span></span><br><span class="line">        <span class="comment">// file behind our back, we reload it.  This has been the</span></span><br><span class="line">        <span class="comment">// historical (if undocumented) behavior.</span></span><br><span class="line">        sp.startReloadIfChangedUnexpectedly();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个flag保证了啥？保证了<strong>在API 11以前</strong>的系统上，如果sp已经被读取进内存，再次获取这个sp的时候，如果有这个flag，会重新读一遍文件，仅此而已！所以，如果仰仗这个Flag做跨进程存取，简直就是丢人现眼。</p>
<h2 id="小结">小结</h2><p>总价一下，sp是一种轻量级的存储方式，使用方便，但是也有它适用的场景。要优雅滴使用sp，要注意以下几点：</p>
<ol>
<li>不要存放大的key和value！我就不重复三遍了，会引起界面卡、频繁GC、占用内存等等，好自为之！</li>
<li>毫不相关的配置项就不要丢在一起了！文件越大读取越慢，不知不觉就被猪队友给坑了；蓝后，放进defalut的那个简直就是愚蠢行为！</li>
<li>读取频繁的key和不易变动的key尽量不要放在一起，影响速度。（如果整个文件很小，那么忽略吧，为了这点性能添加维护成本得不偿失）</li>
<li>不要乱edit和apply，尽量批量修改一次提交！</li>
<li>尽量不要存放JSON和HTML，这种场景请直接使用json！</li>
<li>不要指望用这货进行跨进程通信！！！ </li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>SharedPreference是Android上一种非常易用的轻量级存储方式，由于其API及其友好，得到了很多很多开发者的青睐。但是，SharedPreference并不是万能的，如果把它用在不合适的使用场景，那么将会带来灾难性的后果；本文将讲述一些SharedPreference的使用误区。</p>
<h2 id="存储超大的value">存储超大的value</h2><p>第一次看到下面这个sp的时候，我的内心是崩溃的：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1476286071563.png" width="664"/></p>
<p>一个默认的sp有90K，当我打开它的时候，我都快哭了：除了零零星星的几个很小的key之外，存储了一个炒鸡大的key，这一个key至少占了其中的89K。知道这是什么概念吗？</p>
<p>在小米1S这种手机上，<strong>就算获取这个sp里面一个很小的key，会花费120+ms！！</strong>那个毫不相干的key拖慢了其他所有key的读取速度！当然，在性能稍好的手机上，这个问题不是特别严重。但是要知道，120ms这个是完全不能忍的！</p>
<p>之所以说SharedPreference（下文简称sp）是一种轻量级的存储方式，是它的设计所决定的：sp在创建的时候会把整个文件全部加载进内存，如果你的sp文件比较大，那么会带来两个严重问题：</p>
<ol>
<li>第一次从sp中获取值的时候，有可能阻塞主线程，使界面卡顿、掉帧。</li>
<li>解析sp的时候会产生大量的临时对象，导致频繁GC，引起界面卡顿。</li>
<li>这些key和value会永远存在于内存之中，占用大量内存。</li>
</ol>]]>
    
    </summary>
    
      <category term="-android" scheme="http://weishu.me/tags/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android插件化原理解析——ContentProvider的插件化]]></title>
    <link href="http://weishu.me/2016/07/12/understand-plugin-framework-content-provider/"/>
    <id>http://weishu.me/2016/07/12/understand-plugin-framework-content-provider/</id>
    <published>2016-07-12T11:18:07.000Z</published>
    <updated>2019-01-30T04:06:02.856Z</updated>
    <content type="html"><![CDATA[<p>目前为止我们已经完成了Android四大组件中Activity，Service以及BroadcastReceiver的插件化，这几个组件各不相同，我们根据它们的特点定制了不同的插件化方案；那么对于ContentProvider，它又有什么特点？应该如何实现它的插件化？</p>
<p>与Activity，BroadcastReceiver等频繁被使用的组件不同，我们接触和使用ContentProvider的机会要少得多；但是，ContentProvider这个组件对于Android系统有着特别重要的作用——作为一种极其方便的<strong>数据共享</strong>的手段，ContentProvider使得广大第三方App能够在壁垒森严的系统中自由呼吸。</p>
<p>在Android系统中，每一个应用程序都有自己的用户ID，而每一个应用程序所创建的文件的读写权限都是只赋予给自己所属的用户，这就限制了应用程序之间相互读写数据的操作。应用程序之间如果希望能够进行交互，只能采取跨进程通信的方式；Binder机制能够满足一般的IPC需求，但是如果应用程序之间需要共享大量数据，单纯使用Binder是很难办到的——我相信大家对于Binder 1M缓冲区以及TransactionTooLargeException一定不陌生；ContentProvider使用了匿名共享内存(Ashmem)机制完成数据共享，因此它可以很方便地完成大量数据的传输。Android系统的短信，联系人，相册，媒体库等等一系列的基础功能都依赖与ContentProvider，它的重要性可见一斑。</p>
<p>既然ContentProvider的核心特性是数据共享，那么要实现它的插件化，必须能让插件能够把它的ContentProvider共享给系统——如果不能「<strong>provide content</strong>」那还叫什么ContentProvider？</p>
<p>但是，如果回想一下Activity等组件的插件化方式，在涉及到「共享」这个问题上，一直没有较好的解决方案：<br><a id="more"></a></p>
<ol>
<li>系统中的第三方App无法启动插件中带有特定IntentFilter的Activity，因为系统压根儿感受不到插件中这个真正的Activity的存在。</li>
<li>插件中的静态注册的广播并不真正是静态的，而是使用动态注册广播模拟实现的；这就导致如果宿主程序进程死亡，这个静态广播不会起作用；这个问题的根本原因在由于BroadcastReceiver的IntentFilter的不可预知性，使得我们没有办法把静态广播真正“共享”给系统。</li>
<li>我们没有办法在第三方App中启动或者绑定插件中的Service组件；因为插件的Service并不是真正的Service组件，系统能感知到的只是那个代理Service；因此如果插件如果带有远程Service组件，它根本不能给第三方App提供远程服务。</li>
</ol>
<p>虽然在插件系统中一派生机勃勃的景象，Activity，Service等插件组件百花齐放，插件与宿主、插件与插件争奇斗艳；但是一旦脱离了插件系统的温室，这一片和谐景象不复存在：插件组件不过是傀儡而已；活着的，只有宿主——整个插件系统就是一座死寂的鬼城，各个插件组件借尸还魂般地依附在宿主身上，了无生机。</p>
<p>既然希望把插件的ContentProvider共享给整个系统，让第三方的App都能获取到我们插件共享的数据，我们必须解决这个问题；下文将会围绕这个目标展开，完成ContentProvider的插件化，并且顺带给出上述问题的解决方案。阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>，参考此项目的 contentprovider-management 模块。另外，插件框架原理解析系列文章见 <a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">索引</a>。</p>
<h2 id="ContentProvider工作原理">ContentProvider工作原理</h2><p>首先我们还是得分析一下ContentProvider的工作原理，很多插件化的思路，以及一些Hook点的发现都严重依赖于对于系统工作原理的理解；对于ContentProvider的插件化，这一点特别重要。</p>
<h3 id="铺垫工作">铺垫工作</h3><p>如同我们通过<code>startActivity</code>来启动Activity一样，与ContentProvider打交道的过程也是从Context类的一个方法开始的，这个方法叫做<code>getContentResolver</code>，使用ContentProvider的典型代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ContentResolver resolver = content.getContentResolver();</span><br><span class="line">resolver.query(Uri.parse(<span class="string">"content://authority/test"</span>), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>直接去ContextImpl类里面查找的<code>getContentResolver</code>实现，发现这个方法返回的类型是android.app.ContextImpl.ApplicationContentResolver，这个类是抽象类android.content.ContentResolver的子类，<code>resolver.query</code>实际上是调用父类ContentResolver的<code>query</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="annotation">@Nullable</span> <span class="function">Cursor <span class="title">query</span><span class="params">(<span class="keyword">final</span> @NonNull Uri uri, @Nullable String[] projection,</span><br><span class="line">        @Nullable String selection, @Nullable String[] selectionArgs,</span><br><span class="line">        @Nullable String sortOrder, @Nullable CancellationSignal cancellationSignal)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(uri, <span class="string">"uri"</span>);</span><br><span class="line">    IContentProvider unstableProvider = acquireUnstableProvider(uri);</span><br><span class="line">    <span class="keyword">if</span> (unstableProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    IContentProvider stableProvider = <span class="keyword">null</span>;</span><br><span class="line">    Cursor qCursor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">        ICancellationSignal remoteCancellationSignal = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (cancellationSignal != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cancellationSignal.throwIfCanceled();</span><br><span class="line">            remoteCancellationSignal = unstableProvider.createCancellationSignal();</span><br><span class="line">            cancellationSignal.setRemote(remoteCancellationSignal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            qCursor = unstableProvider.query(mPackageName, uri, projection,</span><br><span class="line">                    selection, selectionArgs, sortOrder, remoteCancellationSignal);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">            <span class="comment">// The remote process has died...  but we only hold an unstable</span></span><br><span class="line">            <span class="comment">// reference though, so we might recover!!!  Let's try!!!!</span></span><br><span class="line">            <span class="comment">// This is exciting!!1!!1!!!!1</span></span><br><span class="line">            unstableProviderDied(unstableProvider);</span><br><span class="line">            stableProvider = acquireProvider(uri);</span><br><span class="line">            <span class="keyword">if</span> (stableProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            qCursor = stableProvider.query(mPackageName, uri, projection,</span><br><span class="line">                    selection, selectionArgs, sortOrder, remoteCancellationSignal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里面的那个<code>try..catch</code>语句，<code>query</code>方法首先尝试调用抽象方法acquireUnstableProvider拿到一个IContentProvider对象，并尝试调用这个”unstable”对象的<code>query</code>方法，万一调用失败（抛出DeadObjectExceptopn，熟悉Binder的应该了解这个异常）说明ContentProvider所在的进程已经死亡，这时候会尝试调用<code>acquireProvider</code>这个抽象方法来获取一个可用的IContentProvider（代码里面那个萌萌的注释说明了一切^_^）；由于这两个<code>acquire*</code>都是抽象方法，我们可以直接看子类<code>ApplicationContentResolver</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> IContentProvider <span class="title">acquireUnstableProvider</span><span class="params">(Context c, String auth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMainThread.acquireProvider(c,</span><br><span class="line">            ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">            resolveUserIdFromAuthority(auth), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(Context context, String auth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMainThread.acquireProvider(context,</span><br><span class="line">            ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">            resolveUserIdFromAuthority(auth), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这两个抽象方法最终都通过调用<code>ActivityThread</code>类的<code>acquireProvider</code>获取到IContentProvider，接下来我们看看到底是如何获取到ContentProvider的。</p>
<h3 id="ContentProvider获取过程">ContentProvider获取过程</h3><p>ActivityThread类的<code>acquireProvider</code>方法如下，我们需要知道的是，方法的最后一个参数<code>stable</code>代表着ContentProvider所在的进程是否存活，如果进程已死，可能需要在必要的时候唤起这个进程；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(</span><br><span class="line">        Context c, String auth, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IContentProvider provider = acquireExistingProvider(c, auth, userId, stable);</span><br><span class="line">    <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> provider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IActivityManager.ContentProviderHolder holder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        holder = ActivityManagerNative.getDefault().getContentProvider(</span><br><span class="line">                getApplicationThread(), auth, userId, stable);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">"Failed to find provider info for "</span> + auth);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    holder = installProvider(c, holder, holder.info,</span><br><span class="line">            <span class="keyword">true</span> <span class="comment">/*noisy*/</span>, holder.noReleaseNeeded, stable);</span><br><span class="line">    <span class="keyword">return</span> holder.provider;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法首先通过<code>acquireExistingProvider</code>尝试从本进程中获取ContentProvider，如果获取不到，那么再请求<code>AMS</code>获取对应ContentProvider；想象一下，如果你查询的是自己App内部的ContentProvider组件，干嘛要劳烦AMS呢？不论是从哪里获取到的ContentProvider，获取完毕之后会调用<code>installProvider</code>来安装ContentProvider。</p>
<p>OK打住，我们思考一下，如果要实现ContentProvider的插件化，我们需要完成一些什么工作？开篇的时候我提到了数据共享，那么具体来说，实现插件的数据共享，需要完成什么？ContentProvider是一个数据共享组件，也就是说它不过是<strong>一个携带数据的载体而已</strong>。为了支持跨进程共享，这个载体是<strong>Binder调用</strong>，为了共享大量数据，使用了匿名共享内存；这么说还是有点抽象，那么想一下，给出一个ContentProvider，你能对它做一些什么操作？如果能让插件支持这些操作，不就支持了插件化么？这就是典型的duck type思想——如果一个东西看起来像ContentProvider，用起来也像ContentProvider，那么它就是ContentProvider。</p>
<p>ContentProvider主要支持<code>query, insert, update, delete</code>操作，由于这个组件一般工作在别的进程，因此这些调用都是Binder调用。从上面的代码可以看到，这些调用最终都是委托给一个IContentProvider的Binder对象完成的，如果我们Hook掉这个对象，那么对于ContentProvider的所有操作都会被我们拦截掉，这时候我们可以做进一步的操作来完成对于插件ContentProvider组件的支持。要拦截这个过程，我们可以<strong>假装插件的ContentProvider是自己App的ContentProvider</strong>，也就是说，让<code>acquireExistingProvider</code>方法可以直接获取到插件的ContentProvider，这样我们就不需要欺骗AMS就能完成插件化了。当然，你也可以选择Hook掉AMS，让AMS的<code>getContentProvider</code>方法返回被我们处理过的对象，这也是可行的；但是，为什么要舍近求远呢？</p>
<p>从上文的分析暂时得出结论：我们可以把插件的ContentProvider信息预先放在App进程内部，使得对于ContentProvider执行CURD操作的时候，可以获取到插件的组件，这样或许就可以实现插件化了。具体来说，我们要做的事情就是让<code>ActivityThread</code>的<code>acquireExistingProvider</code>方法能够返回插件的ContentProvider信息，我们看看这个方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireExistingProvider</span><span class="params">(</span><br><span class="line">        Context c, String auth, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mProviderMap) &#123;</span><br><span class="line">        <span class="keyword">final</span> ProviderKey key = <span class="keyword">new</span> ProviderKey(auth, userId);</span><br><span class="line">        <span class="keyword">final</span> ProviderClientRecord pr = mProviderMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (pr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 略。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，App内部自己的ContentProvider信息保存在ActivityThread类的<code>mProviderMap</code>中，这个map的类型是ArrayMap<providerkey, providerclientrecord="">；我们当然可以通过反射修改这个成员变量，直接把插件的ContentProvider信息填进去，但是这个ProviderClientRecord对象如何构造？我们姑且看看系统自己是如果填充这个字段的。在ActivityThread类中搜索一遍，发现调用mProviderMap对象的<code>put</code>方法的之后<code>installProviderAuthoritiesLocked</code>，而这个方法最终被<code>installProvider</code>方法调用。在分析ContentProvider的获取过程中我们已经知道，不论是通过本进程的<code>acquireExistingProvider</code>还是借助AMS的<code>getContentProvider</code>得到ContentProvider，最终都会对这个对象执行<code>installProvider</code>操作，也就是「安装」在本进程内部。那么，我们接着看这个<code>installProvider</code>做了什么，它是如何「安装」ContentProvider的。</providerkey,></p>
<h3 id="进程内部ContentProvider安装过程">进程内部ContentProvider安装过程</h3><p>首先，如果之前没有“安装”过，那么holder为null，下面的代码会被执行，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> java.lang.ClassLoader cl = c.getClassLoader();</span><br><span class="line">localProvider = (ContentProvider)cl.</span><br><span class="line">    loadClass(info.name).newInstance();</span><br><span class="line">provider = localProvider.getIContentProvider();</span><br><span class="line"><span class="keyword">if</span> (provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">    Slog.e(TAG, <span class="string">"Failed to instantiate class "</span> +</span><br><span class="line">          info.name + <span class="string">" from sourceDir "</span> +</span><br><span class="line">          info.applicationInfo.sourceDir);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (DEBUG_PROVIDER) Slog.v(</span><br><span class="line">    TAG, <span class="string">"Instantiating local provider "</span> + info.name);</span><br><span class="line"><span class="comment">// <span class="label">XXX Need to create the correct context for this provider.</span></span></span><br><span class="line">localProvider.attachInfo(c, info);</span><br></pre></td></tr></table></figure>
<p>比较直观，直接load这个ContentProvider所在的类，然后用反射创建出这个ContentProvider对象；但是由于查询是需要进行跨进程通信的，在本进程创建出这个对象意义不大，所以我们需要取出ContentProvider承载跨进程通信的Binder对象IContentProvider；创建出对象之后，接下来就是构建合适的信息，保存在ActivityThread内部，也就是<code>mProviderMap</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (localProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ComponentName cname = <span class="keyword">new</span> ComponentName(info.packageName, info.name);</span><br><span class="line">    ProviderClientRecord pr = mLocalProvidersByName.get(cname);</span><br><span class="line">    <span class="keyword">if</span> (pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROVIDER) &#123;</span><br><span class="line">            Slog.v(TAG, <span class="string">"installProvider: lost the race, "</span></span><br><span class="line">                    + <span class="string">"using existing local provider"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        provider = pr.mProvider;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        holder = <span class="keyword">new</span> IActivityManager.ContentProviderHolder(info);</span><br><span class="line">        holder.provider = provider;</span><br><span class="line">        holder.noReleaseNeeded = <span class="keyword">true</span>;</span><br><span class="line">        pr = installProviderAuthoritiesLocked(provider, localProvider, holder);</span><br><span class="line">        mLocalProviders.put(jBinder, pr);</span><br><span class="line">        mLocalProvidersByName.put(cname, pr);</span><br><span class="line">    &#125;</span><br><span class="line">    retHolder = pr.mHolder;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure>
<p>以上就是安装代码，不难理解。</p>
<h3 id="思路尝试——本地安装">思路尝试——本地安装</h3><p>那么，了解了「安装」过程再结合上文的分析，我们似乎可以完成ContentProvider的插件化了——直接把插件的ContentProvider安装在进程内部就行了。如果插件系统有多个进程，那么必须在每个进程都「安装」一遍，如果你熟悉Android进程的启动流程那么就会知道，这个安装ContentProvider的过程适合放在Application类中，因为每个Android进程启动的时候，App的Application类是会被启动的。</p>
<p>看起来实现ContentProvider的思路有了，但是这里实际上有一个严重的缺陷！</p>
<p>我们依然没有解决「共享」的问题。我们只是在插件系统启动的进程里面的ActivityThread的<code>mProviderMap</code>给修改了，这使得只有通过插件系统启动的进程，才能感知到插件中的ContentProvider(因为我们手动把插件中的信息install到这个进程中去了)；如果第三方的App想要使用插件的ContentProvider，那系统只会告诉它查无此人。</p>
<p>那么，我们应该如何解决共享这个问题呢？看来还是逃不过AMS的魔掌，我们继续跟踪源码，看看如果在本进程查询不到ContentProvider，AMS是如何完成这个过程的。在ActivityThread的<code>acquireProvider</code>方法中我们提到，如果<code>acquireExistingProvider</code>方法返回null，会调用ActivityManagerNative的<code>getContentProvider</code>方法通过AMS查询整个系统中是否存在需要的这个ContentProvider。如果第三方App查询插件系统的ContentProvider必然走的是这个流程，我们仔细分析一下这个过程；</p>
<h3 id="AMS中的ContentProvider">AMS中的ContentProvider</h3><p>首先我们查阅ActivityManagerService的<code>getContentProvider</code>方法，这个方法间接调用了<code>getContentProviderImpl</code>方法；<code>getContentProviderImpl</code>方法体相当的长，但是实际上只做了两件事件事（我这就不贴代码了，读者可以对着源码看一遍）：</p>
<ol>
<li>使用PackageManagerService的resolveContentProvider根据Uri中提供的auth信息查阅对应的ContentProivoder的信息ProviderInfo。</li>
<li>根据查询到的ContentProvider信息，尝试将这个ContentProvider组件安装到系统上。</li>
</ol>
<h4 id="查询ContentProvider组件的过程">查询ContentProvider组件的过程</h4><p>查询ContentProvider组件的过程看起来很简单，直接调用PackageManager的<code>resolveContentProvider</code>就能从URI中获取到对应的<code>ProviderInfo</code>信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProviderInfo <span class="title">resolveContentProvider</span><span class="params">(String name, <span class="keyword">int</span> flags, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sUserManager.exists(userId)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// reader</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">        <span class="keyword">final</span> PackageParser.Provider provider = mProvidersByAuthority.get(name);</span><br><span class="line">        PackageSetting ps = provider != <span class="keyword">null</span></span><br><span class="line">                ? mSettings.mPackages.get(provider.owner.packageName)</span><br><span class="line">                : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> ps != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mSettings.isEnabledLPr(provider.info, flags, userId)</span><br><span class="line">                &amp;&amp; (!mSafeMode || (provider.info.applicationInfo.flags</span><br><span class="line">                        &amp;ApplicationInfo.FLAG_SYSTEM) != <span class="number">0</span>)</span><br><span class="line">                ? PackageParser.generateProviderInfo(provider, flags,</span><br><span class="line">                        ps.readUserState(userId), userId)</span><br><span class="line">                : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是实际上我们关心的是，这个<code>mProvidersByAuthority</code>里面的信息是如何添加进PackageManagerService的，会在什么时候更新？在PackageManagerService这个类中搜索mProvidersByAuthority.put这个调用，会发现在<code>scanPackageDirtyLI</code>会更新<code>mProvidersByAuthority</code>这个map的信息，接着往前追踪会发现：<strong>这些信息是在Android系统启动的时候收集的</strong>。也就是说，Android系统在启动的时候会扫描一些App的安装目录，典型的比如/data/app/*，获取这个目录里面的apk文件，读取其AndroidManifest.xml中的信息，然后把这些信息保存在PackageManagerService中。合理猜测，在系统启动之后，安装新的App也会触发对新App中AndroidManifest.xml的操作，感兴趣的读者可以自行翻阅源码。</p>
<p>现在我们知道，查询ContentProvider的信息来源在Android系统启动的时候已经初始化好了，这个过程对于我们第三方app来说是鞭长莫及，想要使用类似在进程内部Hack ContentProvider的查找过程是不可能的。</p>
<h4 id="安装ContentProvider组件的过程">安装ContentProvider组件的过程</h4><p>获取到URI对应的ContentProvider的信息之后，接下来就是把它安装到系统上了，这样以后有别的查询操作就可以直接拿来使用；但是这个安装过程AMS是没有办法以一己之力完成的。想象一下App DemoA 查询App DemoB 的某个ContentProviderAppB，那么这个ContentProviderAppB必然存在于DemoB这个App中，AMS所在的进程(system_server)连这个ContentProviderAppB的类都没有，因此，AMS必须委托DemoB完成它的ContentProviderAppB的安装；这里就分两种情况：其一，DemoB这个App已经在运行了，那么AMS直接通知DemoB安装ContentProviderAppB（如果B已经安装了那就更好了）；其二，DemoB这个app没在运行，那么必须把B进程唤醒，让它干活；这个过程也就是ActivityManagerService的<code>getContentProviderImpl</code>方法所做的，如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (proc != <span class="keyword">null</span> &amp;&amp; proc.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!proc.pubProviders.containsKey(cpi.name)) &#123;</span><br><span class="line">        proc.pubProviders.put(cpi.name, cpr);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            proc.thread.scheduleInstallProvider(cpi);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    proc = startProcessLocked(cpi.processName,</span><br><span class="line">            cpr.appInfo, <span class="keyword">false</span>, <span class="number">0</span>, <span class="string">"content provider"</span>,</span><br><span class="line">            <span class="keyword">new</span> ComponentName(cpi.applicationInfo.packageName,</span><br><span class="line">                    cpi.name), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (proc == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果查询的ContentProvider所在进程处于运行状态，那么AMS会通过这个进程给AMS的ApplicationThread这个Binder对象完成scheduleInstallProvider调用，这个过程比较简单，最终会调用到目标进程的<code>installProvider</code>方法，而这个方法我们在上文已经分析过了。我们看一下如果目标进程没有启动，会发生什么情况。</p>
<p>如果ContentProvider所在的进程已经死亡，那么会调用startProcessLocked来启动新的进程，<code>startProcessLocked</code>有一系列重载函数，我们一路跟踪，发现最终启动进程的操作交给了<code>Process</code>类的<code>start</code>方法完成，这个方法通过socket与Zygote进程进行通信，通知Zygote进程fork出一个子进程，然后通过反射调用了之前传递过来的一个入口类的main函数，一般来说这个入口类就是ActivityThread，因此子进程fork出来之后会执行ActivityThread类的main函数。</p>
<p>在我们继续观察子进程ActivityThread的main函数执行之前，我们看看AMS进程这时候会干什么——startProcessLocked之后AMS进程和fork出来的DemoB进程分道扬镳；AMS会继续往下面执行。我们暂时回到AMS的<code>getContentProviderImpl</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wait for the provider to be published...</span></span><br><span class="line"><span class="keyword">synchronized</span> (cpr) &#123;</span><br><span class="line">    <span class="keyword">while</span> (cpr.provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cpr.launchingApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.waiting = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cpr.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.waiting = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你没看错，一个死循环就是糊在上面：AMS进程会通过一个死循环等到进程B完成ContentProvider的安装，等待完成之后会把ContentProvider的信息返回给进程A。那么，我们现在的疑惑是，<strong>进程B在启动之后，在哪个时间点会完成ContentProvider的安装呢？</strong> </p>
<p>我们接着看ActivityThread的main函数，顺便寻找我们上面那个问题的答案；这个分析实际上就是Android App的启动过程，更详细的过程可以参阅老罗的文章 <a href="http://blog.csdn.net/luoshengyang/article/details/6689748" target="_blank" rel="external">Android应用程序启动过程源代码分析</a>，这里只给出简要调用流程：</p>
<p><img src="http://weishu.dimensionalzone.com/201605/1468313182087.png" alt="App启动简要流程"></p>
<p>最终，DemoB进程启动之后会执行ActivityThread类的handleBindApplication方法，这个方法相当之长，基本完成了App进程启动之后所有必要的操作；这里我们只关心ContentProvider相关的初始化操作，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the app is being launched for full backup or restore, bring it up in</span></span><br><span class="line"><span class="comment">// a restricted environment with the base application class.</span></span><br><span class="line">Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line">mInitialApplication = app;</span><br><span class="line"></span><br><span class="line"><span class="comment">// don't bring up providers in restricted mode; they may depend on the</span></span><br><span class="line"><span class="comment">// app's custom Application class</span></span><br><span class="line"><span class="keyword">if</span> (!data.restrictedBackupMode) &#123;</span><br><span class="line">    List&lt;ProviderInfo&gt; providers = data.providers;</span><br><span class="line">    <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        installContentProviders(app, providers);</span><br><span class="line">        <span class="comment">// For process that contains content providers, we want to</span></span><br><span class="line">        <span class="comment">// ensure that the JIT is enabled "at some point".</span></span><br><span class="line">        mH.sendEmptyMessageDelayed(H.ENABLE_JIT, <span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do this after providers, since instrumentation tests generally start their</span></span><br><span class="line"><span class="comment">// test thread at this point, and we don't want that racing.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细观察以上代码，你会发现：<strong>ContentProvider的安装比Application的onCreate回调还要早！！</strong>因此，分析到这里我们已经明白了前面提出的那个问题，<strong>进程启动之后会在Applition类的onCreate 回调之前，在Application对象创建之后完成ContentProvider的安装</strong>。</p>
<p>然后不要忘了，我们的AMS进程还在那傻傻等待DemoB进程完成ContentProviderAppB的安装呢！在DemoB的Application的onCreate回调之前，DemoB的ContentProviderAppB已经安装好了，因此AMS停止等待，把DemoB安装的结果返回给请求这个ContentProvider的DemoA。我们必须对这个时序保持敏感，有时候就是失之毫厘，差之千里！！</p>
<p>到这里，有关ContentProvider的调用过程以及简要的工作原理我们已经分析完毕，关于它如何共享数据，如何使用匿名共享内存这部分不是插件化的重点，感兴趣的可以参考 <a href="http://blog.csdn.net/luoshengyang/article/details/6967204" target="_blank" rel="external">Android应用程序组件Content Provider在应用程序之间共享数据的原理分析</a>。</p>
<h2 id="不同之处">不同之处</h2><p>在实现ContentProvider的插件化之前，通过分析这个组件的工作原理，我们可以得出它的一些与众不同的特性：</p>
<ol>
<li>ContentProvider本身是用来共享数据的，因此它提供一般的CURD服务；它类似HTTP这种无状态的服务，没有Activity，Service所谓的生命周期的概念，服务要么可用，要么不可用；对应着ContentProvider要么启动，要么随着进程死亡；而通常情况下，死亡之后还会被系统启动。所以，ContentProvider，只要有人需要这个服务，系统可以保证是永生的；这是与其他组件的最大不同；完全不用考虑生命周期的概念。</li>
<li>ContentProvider被设计为共享数据，这种数据量一般来说是相当大的；熟悉Binder的人应该知道，Binder进行数据传输有1M限制，因此如果要使用Binder传输大数据，必须使用类似socket的方式一段一段的读，也就是说需要自己在上层架设一层协议；ContentProvider并没有采取这种方式，而是采用了Android系统的匿名共享内存机制，利用Binder来传输这个文件描述符，进而实现文件的共享；这是第二个不同，因为其他的三个组建通信都是基于Binder的，只有ContentProvider使用了Ashmem。</li>
<li>一个App启动过程中，ContentProvider组件的启动是非常早的，甚至比Application的onCreate还要早；我们可以利用这个特性结合它不死的特点，完成一些有意义的事情。</li>
<li>ContentProvider存在优先查询本进程的特点，使得它的插件化甚至不需要Hook AMS就能完成。</li>
</ol>
<h2 id="思路分析">思路分析</h2><p>在分析ContentProvider的工作原理的过程中我们提出了一种插件化方案：在进程启动之初，手动把ContentProvider安装到本进程，使得后续对于插件ContentProvider的请求能够顺利完成。我们也指出它的一个严重缺陷，那就是它只能在插件系统内部掩耳盗铃，在插件系统之外，第三方App依然无法感知到插件中的ContentProvider的存在。</p>
<p>如果插件的ContentProvider组件仅仅是为了共享给其他插件或者宿主程序使用，那么这种方案可以解决问题；不需要Hook AMS，非常简单。</p>
<p>但是，如果希望把插件ContenProvider共享给整个系统呢？在分析AMS中获取ContentProvider的过程中我们了解到，ContentProvider信息的注册是在Android系统启动或者新安装App的时候完成的，而AMS把ContentProvider返回给第三方App也是在system_server进程完成；我们无法对其暗箱操作。</p>
<p>在完成Activity，Service组件的插件化之后，这种限制对我们来说已经是小case了：我们在宿主程序里面注册一个货真价实、被系统认可的StubContentProvider组件，把这个组件共享给第三方App；然后通过<strong>代理分发技术</strong>把第三方App对于插件ContentProvider的请求通过这个StubContentProvider分发给对应的插件。</p>
<p>但是这还存在一个问题，由于第三方App查阅的其实是StubContentProvider，因此他们查阅的URI也必然是StubContentProvider的authority，要查询到插件的ContentProvider，必须把要查询的真正的插件ContentProvider信息传递进来。这个问题的解决方案也很容易，我们可以制定一个「插件查询协议」来实现。</p>
<p>举个例子，假设插件系统的宿主程序在AndroidManifest.xml中注册了一个StubContentProvider，它的Authority为<code>com.test.host_authority</code>；由于这个组件被注册在AndroidManifest.xml中，是系统认可的ContentProvider组件，整个系统都是可以使用这个共享组件的，使用它的URI一般为<code>content://com.test.host_authority</code>；那么，如果插件系统中存在一个插件，这个插件提供了一个PluginContentProvider，它的Authority为<code>com.test.plugin_authorith</code>，因为这个插件的PluginContentProvider没有在宿主程序的AndroidMainifest.xml中注册（预先注册就失去插件的意义了），整个系统是无法感知到它的存在的；前面提到代理分发技术，也就是，我们让第三方App请求宿主程序的StubContentProvider，这个StubContentProvider把请求转发给合适的插件的ContentProvider就能完成了(插件内部通过预先installProvider可以查询所有的ContentProvider组件)；这个协议可以有很多，比如说：如果第三方App需要请求插件的StubContentProvider，可以以<code>content://com.test.host_authority/com.test.plugin_authorith</code>去查询系统；也就是说，我们假装请求StubContentProvider，把真正的需要请求的PluginContentProvider的Authority放在路径参数里面，StubContentProvider收到这个请求之后，拿到这个真正的Authority去请求插件的PluginContentProvider，拿到结果之后再返回给第三方App。</p>
<p>这样，我们通过「代理分发技术」以及「插件查询协议」可以完美解决「共享」的问题，开篇提到了我们之前对于Activity，Service组件插件化方案中对于「共享」功能的缺失，按照这个思路，基本可以解决这一系列问题。比如，对于第三方App无法绑定插件服务的问题，我们可以注册一个StubService，把真正需要bind的插件服务信息放在intent的某个字段中，然后在StubService的onBind中解析出这个插件服务信息，然后去拿到插件Service组件的Binder对象返回给第三方。</p>
<h2 id="实现">实现</h2><p>上文详细分析了如何实现ContentProvider的插件化，接下来我们就实现这个过程。</p>
<h3 id="预先installProvider">预先installProvider</h3><p>要实现预先installProvider，我们首先需要知道，所谓的「预先」到底是在什么时候？</p>
<p>前文我们提到过App进程安装ContentProvider的时机非常之早，在Application类的onCreate回调执行之前已经完成了；这意味着什么？</p>
<p>现在我们对于ContentProvider插件化的实现方式是通过「代理分发技术」，也就是说在请求插件ContentProvider的时候会先请求宿主程序的StubContentProvider；如果一个第三方App查询插件的ContentProvider，而宿主程序没有启动的话，AMS会启动宿主程序并等待宿主程序的StubContentProvider完成安装，<strong>一旦安装完成就会把得到的IContentProvider返回给这个第三方App</strong>；第三方App拿到IContentProvider这个Binder对象之后就可能发起CURD操作，如果这个时候插件ContentProvider还没有启动，那么肯定就会出异常；要记住，“这个时候”可能宿主程序的onCreate还没有执行完毕呢！！</p>
<p>所以，我们基本可以得出结论，预先安装这个所谓的「预先」必须早于Application的onCreate方法，在Android SDK给我们的回调里面，attachBaseContent这个方法是可以满足要求的，它在Application这个对象被创建之后就会立即调用。</p>
<p>解决了时机问题，那么我们接下来就可以安装ContentProvider了。</p>
<p>安装ContentProvider也就是要调用ActivityThread类的<code>installProvider</code>方法，这个方法需要的参数有点多，而且它的第二个参数IActivityManager.ContentProviderHolder是一个隐藏类，我们不知道如何构造，就算通过反射构造由于SDK没有暴露稳定性不易保证，我们看看有什么方法调用了这个installProvider。</p>
<p>installContentProviders这个方法直接调用installProvder看起来可以使用，但是它是一个private的方法，还有public的方法吗？继续往上寻找调用链，发现了installSystemProviders这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">installSystemProviders</span><span class="params">(List&lt;ProviderInfo&gt; providers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        installContentProviders(mInitialApplication, providers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，我们说过ContentProvider的安装必须相当早，必须在Application类的attachBaseContent方法内，而这个<code>mInitialApplication</code>字段是在<code>onCreate</code>方法调用之后初始化的，所以，如果直接使用这个<code>installSystemProviders</code>势必抛出空指针异常；因此，我们只有退而求其次，选择<strong>通过installContentProviders这个方法完成ContentProvider的安装</strong></p>
<p>要调用这个方法必须拿到ContentProvider对应的ProviderInfo，这个我们在之前也介绍过，可以通过PackageParser类完成，当然这个类有一些兼容性问题，我们需要手动处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 解析Apk文件中的 &lt;provider&gt;, 并存储起来</span><br><span class="line"> * 主要是调用PackageParser类的generateProviderInfo方法</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> apkFile 插件对应的apk文件</span><br><span class="line"> * <span class="doctag">@throws</span> Exception 解析出错或者反射调用出错, 均会抛出异常</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;ProviderInfo&gt; <span class="title">parseProviders</span><span class="params">(File apkFile)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class&lt;?&gt; packageParserClass = Class.forName(<span class="string">"android.content.pm.PackageParser"</span>);</span><br><span class="line">    Method parsePackageMethod = packageParserClass.getDeclaredMethod(<span class="string">"parsePackage"</span>, File.class, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">    Object packageParser = packageParserClass.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先调用parsePackage获取到apk对象对应的Package对象</span></span><br><span class="line">    Object packageObj = parsePackageMethod.invoke(packageParser, apkFile, PackageManager.GET_PROVIDERS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取Package对象里面的services字段</span></span><br><span class="line">    <span class="comment">// 接下来要做的就是根据这个List&lt;Provider&gt; 获取到Provider对应的ProviderInfo</span></span><br><span class="line">    Field providersField = packageObj.getClass().getDeclaredField(<span class="string">"providers"</span>);</span><br><span class="line">    List providers = (List) providersField.get(packageObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用generateProviderInfo 方法, 把PackageParser.Provider转换成ProviderInfo</span></span><br><span class="line">    Class&lt;?&gt; packageParser$ProviderClass = Class.forName(<span class="string">"android.content.pm.PackageParser$Provider"</span>);</span><br><span class="line">    Class&lt;?&gt; packageUserStateClass = Class.forName(<span class="string">"android.content.pm.PackageUserState"</span>);</span><br><span class="line">    Class&lt;?&gt; userHandler = Class.forName(<span class="string">"android.os.UserHandle"</span>);</span><br><span class="line">    Method getCallingUserIdMethod = userHandler.getDeclaredMethod(<span class="string">"getCallingUserId"</span>);</span><br><span class="line">    <span class="keyword">int</span> userId = (Integer) getCallingUserIdMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line">    Object defaultUserState = packageUserStateClass.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要调用 android.content.pm.PackageParser#generateProviderInfo</span></span><br><span class="line">    Method generateProviderInfo = packageParserClass.getDeclaredMethod(<span class="string">"generateProviderInfo"</span>,</span><br><span class="line">            packageParser$ProviderClass, <span class="keyword">int</span>.class, packageUserStateClass, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">    List&lt;ProviderInfo&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 解析出intent对应的Provider组件</span></span><br><span class="line">    <span class="keyword">for</span> (Object service : providers) &#123;</span><br><span class="line">        ProviderInfo info = (ProviderInfo) generateProviderInfo.invoke(packageParser, service, <span class="number">0</span>, defaultUserState, userId);</span><br><span class="line">        ret.add(info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析出ProviderInfo之后，就可以直接调用installContentProvider了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 在进程内部安装provider, 也就是调用 ActivityThread.installContentProviders方法</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> context you know</span><br><span class="line"> * <span class="doctag">@param</span> apkFile</span><br><span class="line"> * <span class="doctag">@throws</span> Exception</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installProviders</span><span class="params">(Context context, File apkFile)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;ProviderInfo&gt; providerInfos = parseProviders(apkFile);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ProviderInfo providerInfo : providerInfos) &#123;</span><br><span class="line">        providerInfo.applicationInfo.packageName = context.getPackageName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Log.d(<span class="string">"test"</span>, providerInfos.toString());</span><br><span class="line">    Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">    Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">    Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line">    Method installProvidersMethod = activityThreadClass.getDeclaredMethod(<span class="string">"installContentProviders"</span>, Context.class, List.class);</span><br><span class="line">    installProvidersMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    installProvidersMethod.invoke(currentActivityThread, context, providerInfos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个安装过程<strong>必须在Application类的attachBaseContent里面完成</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 一定需要Application，并且在attachBaseContext里面Hook</span><br><span class="line"> * 因为provider的初始化非常早，比Application的onCreate还要早</span><br><span class="line"> * 在别的地方hook都晚了。</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@author</span> weishu</span><br><span class="line"> * <span class="doctag">@date</span> 16/3/29</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UPFApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File apkFile = getFileStreamPath(<span class="string">"testcontentprovider-debug.apk"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!apkFile.exists()) &#123;</span><br><span class="line">                Utils.extractAssets(base, <span class="string">"testcontentprovider-debug.apk"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            File odexFile = getFileStreamPath(<span class="string">"test.odex"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hook ClassLoader, 让插件中的类能够被成功加载</span></span><br><span class="line">            BaseDexClassLoaderHookHelper.patchClassLoader(getClassLoader(), apkFile, odexFile);</span><br><span class="line">            ProviderHelper.installProviders(base, getFileStreamPath(<span class="string">"testcontentprovider-debug.apk"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"hook failed"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代理分发以及协议解析">代理分发以及协议解析</h3><p>把插件中的ContentProvider安装到插件系统中之后，在插件内部就可以自由使用这些ContentProvider了；要把这些插件共享给整个系统，我们还需要一个货真价实的ContentProvider组件来执行分发：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">provider</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.example.weishu.contentprovider_management.StubContentProvider"</span></span><br><span class="line">    <span class="attribute">android:authorities</span>=<span class="value">"com.example.weishu.contentprovider_management.StubContentProvider"</span></span><br><span class="line">    <span class="attribute">android:process</span>=<span class="value">":p"</span></span><br><span class="line">    <span class="attribute">android:exported</span>=<span class="value">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>第三方App如果要查询到插件的ContentProvider，必须遵循一个「插件查询协议」，这样StubContentProvider才能把对于插件的请求分发到正确的插件组件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 为了使得插件的ContentProvder提供给外部使用，我们需要一个StubProvider做中转；</span><br><span class="line"> * 如果外部程序需要使用插件系统中插件的ContentProvider，不能直接查询原来的那个uri</span><br><span class="line"> * 我们对uri做一些手脚，使得插件系统能识别这个uri；</span><br><span class="line"> *</span><br><span class="line"> * 这里的处理方式如下：</span><br><span class="line"> *</span><br><span class="line"> * 原始查询插件的URI应该为：</span><br><span class="line"> * content://plugin_auth/path/query</span><br><span class="line"> *</span><br><span class="line"> * 如果需要查询插件，需要修改为：</span><br><span class="line"> *</span><br><span class="line"> * content://stub_auth/plugin_auth/path/query</span><br><span class="line"> *</span><br><span class="line"> * 也就是，我们把插件ContentProvider的信息放在URI的path中保存起来；</span><br><span class="line"> * 然后在StubProvider中做分发。</span><br><span class="line"> *</span><br><span class="line"> * 当然，也可以使用QueryParamerter,比如：</span><br><span class="line"> * content://plugin_auth/path/query/ -&gt;  content://stub_auth/path/query?plugin=plugin_auth</span><br><span class="line"> * <span class="doctag">@param</span> raw 外部查询我们使用的URI</span><br><span class="line"> * <span class="doctag">@return</span> 插件真正的URI</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Uri <span class="title">getRealUri</span><span class="params">(Uri raw)</span> </span>&#123;</span><br><span class="line">    String rawAuth = raw.getAuthority();</span><br><span class="line">    <span class="keyword">if</span> (!AUTHORITY.equals(rawAuth)) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"rawAuth:"</span> + rawAuth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String uriString = raw.toString();</span><br><span class="line">    uriString = uriString.replaceAll(rawAuth + <span class="string">'/'</span>, <span class="string">""</span>);</span><br><span class="line">    Uri newUri = Uri.parse(uriString);</span><br><span class="line">    Log.i(TAG, <span class="string">"realUri:"</span> + newUri);</span><br><span class="line">    <span class="keyword">return</span> newUri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上过程我们就实现了ContentProvider的插件化。需要说明的是，DroidPlugind的插件化与上述介绍的方案有一些不同之处：</p>
<ol>
<li>首先DroidPlugin并没有选择预先安装的方案，而是选择Hook ActivityManagerNative，拦截它的getContentProvider以及publishContentProvider方法实现对于插件组件的控制；从这里可以看出它对ContentProvider与Service的插件化几乎是相同的，Hook才是DroidPlugin Style ^_^.</li>
<li>然后，关于携带插件信息，或者说「插件查询协议」方面；DroidPlugin把插件信息放在查询参数里面，本文呢则是路径参数；这一点完全看个人喜好。</li>
</ol>
<h2 id="小结">小结</h2><p>本文我们通过「代理分发技术」以及「插件查询协议」完成了ContentProvider组件的插件化，并且给出了对「插件共享组件」的问题的一般解决方案。值得一提的是，系统的ContentProvider其实是lazy load的，也就是说只有在需要使用的时候才会启动对应的ContentProvider，而我们对于插件的实现则是<strong>预先加载</strong>，这里还有改进的空间，读者可以思考一下解决方案。</p>
<p>由于ContentProvider的使用频度非常低，而很多它使用的场景（比如系统）并不太需要「插件化」，因此在实际的插件方案中，提供ContentProvider插件化的方案非常之少；就算需要实现ContentProvider的插件化，也只是解决插件内部之间共享组件的问题，并没有把插件组件暴露给整个系统。我个人觉得，如果只是希望插件化，那么是否支持ContentProvider无伤大雅，但是，如果希望实现虚拟化或者说容器技术，所有组件是必须支持插件化的。</p>
<p>至此，对于Android系统的四大组件的插件化已经全部介绍完毕；由于是最后一个要介绍的组件，我并没有像之前一样先给出组件的运行原理，然后一通分析最后给出插件方案，而是一边分析代码一边给出自己的思路，把思考——推翻——改进的整个过程完全展现了出来，Android的插件化已经到达了百花齐放的阶段，插件化之路也不只有一条，但是万变不离其宗，希望我的分析和思考对各位读者理解甚至创造插件化方案带来帮助。接下来我会介绍「插件通信机制」，它与本文的ContentProvider以及我反复强调过的一些特性密切相关，敬请期待！</p>
<p>喜欢就点个赞吧，兜里有一块钱的童鞋可以点击下面的打赏然后扫一下二维码哦～持续更新，请关注github项目 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a> 和我的 <a href="http://weishu.me">博客</a>! 另外很抱歉一个多月没有更新博客了，每天看到各位的来访记录深感惭愧，实在是业务繁忙，身不由已！不出意外接下来会以正常速度更新内容，谢谢支持 ^_^</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>目前为止我们已经完成了Android四大组件中Activity，Service以及BroadcastReceiver的插件化，这几个组件各不相同，我们根据它们的特点定制了不同的插件化方案；那么对于ContentProvider，它又有什么特点？应该如何实现它的插件化？</p>
<p>与Activity，BroadcastReceiver等频繁被使用的组件不同，我们接触和使用ContentProvider的机会要少得多；但是，ContentProvider这个组件对于Android系统有着特别重要的作用——作为一种极其方便的<strong>数据共享</strong>的手段，ContentProvider使得广大第三方App能够在壁垒森严的系统中自由呼吸。</p>
<p>在Android系统中，每一个应用程序都有自己的用户ID，而每一个应用程序所创建的文件的读写权限都是只赋予给自己所属的用户，这就限制了应用程序之间相互读写数据的操作。应用程序之间如果希望能够进行交互，只能采取跨进程通信的方式；Binder机制能够满足一般的IPC需求，但是如果应用程序之间需要共享大量数据，单纯使用Binder是很难办到的——我相信大家对于Binder 1M缓冲区以及TransactionTooLargeException一定不陌生；ContentProvider使用了匿名共享内存(Ashmem)机制完成数据共享，因此它可以很方便地完成大量数据的传输。Android系统的短信，联系人，相册，媒体库等等一系列的基础功能都依赖与ContentProvider，它的重要性可见一斑。</p>
<p>既然ContentProvider的核心特性是数据共享，那么要实现它的插件化，必须能让插件能够把它的ContentProvider共享给系统——如果不能「<strong>provide content</strong>」那还叫什么ContentProvider？</p>
<p>但是，如果回想一下Activity等组件的插件化方式，在涉及到「共享」这个问题上，一直没有较好的解决方案：<br>]]>
    
    </summary>
    
      <category term="ContentProvider" scheme="http://weishu.me/tags/ContentProvider/"/>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="droidplugin" scheme="http://weishu.me/tags/droidplugin/"/>
    
      <category term="plugin framework" scheme="http://weishu.me/tags/plugin-framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何调试Android Framework？]]></title>
    <link href="http://weishu.me/2016/05/30/how-to-debug-android-framework/"/>
    <id>http://weishu.me/2016/05/30/how-to-debug-android-framework/</id>
    <published>2016-05-30T09:26:05.000Z</published>
    <updated>2019-01-30T04:06:02.841Z</updated>
    <content type="html"><![CDATA[<p>Linus有一句名言广为人知：Read the fucking source code. 但其实，要深入理解某个软件、框架或者系统的工作原理，仅仅「看」代码是远远不够的。就拿Android Framework来说，整个代码量非常大不说，那些个动辄几万行的类如何去理解？所以我今天要说的就是：</p>
<p><strong>Debug the fucking source code!!</strong></p>
<p>之前分享过一个答案：<a href="https://www.zhihu.com/question/40300713/answer/86706105" target="_blank" rel="external">大家遇到过什么 Android 兼容性问题？</a>，这里面的有一些非常诡异的问题，我相信光靠看代码你是永远定位不出来的。还有我写的一系列<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">Android插件框架原理</a>的文章，这里面涉及到大量Android Framework层的知识，有小伙伴会问，这些Framework层的原理，你是如何学习的呢，有诀窍吗？有！那就是调试。</p>
<p>Debug是一项非常非常重要的技能，毋庸多言。今天我就给大家分享一下「调试Android Framework」的经验，一旦掌握这项技能，那么Java层的任何问题都拦不住你了。</p>
<a id="more"></a>
<h2 id="概览">概览</h2><p>其实整个调试过程非常简单：</p>
<ol>
<li>在你要调试进程的合适位置打上断点</li>
<li>跟踪代码（Step in/out/over等等）</li>
</ol>
<p>在展开讲述这两方面之前，有必要先简单了解下调试的基础知识。Java平台的调试是有一个规范化的标准的，那就是JPDA（Java Platform Debugger Architecture）；通过 JPDA 提供的 API，开发人员可以方便灵活的搭建 Java 调试应用程序。 JPDA 主要由三个部分组成：Java 虚拟机工具接口（JVMTI），Java 调试线协议（JDWP），以及 Java 调试接口（JDI）。</p>
<p>Java程序的调试无非就是通过一个调试器（debugger）获取对应Java虚拟机的信息，上文所述的JDWP就是调试器与虚拟机通信的桥梁。在dalvik虚拟机内部有一个专门的jdwp线程，Android系统的adbd进程通过socket与各个虚拟机的jdwp线程进行通信，外部调试器通过adb工具与adbd通信进而完成与jdwp的通信。我们通常所说的「attach debugger」指的就是这个意思——连接到指定的需要调试的进程。</p>
<p><img src="http://weishu.dimensionalzone.com/201605/1464599537380.png" alt="调试器工作原理"></p>
<h2 id="如何在正确的地方下断点">如何在正确的地方下断点</h2><p>「正确的地方」包含两个含义：首先，调试是以进程为单位进行的，如果你需要调试运行在进程A 中的代码，却把debugger attach到了B进程，那么这个断点压根儿就是牛头不对马嘴；另外呢，比如你想调试Android的多媒体框架，你得知道media相关的类在哪吧，也就是说需要在正确的函数里面下断点。</p>
<h3 id="如何在合适的进程下断点？">如何在合适的进程下断点？</h3><p>如果是调试我们自己写的App，在Android Studio里面非常简单，在Run菜单de最后面有一个attach debugger to android process 的选项，点击之后会出现一个菜单，选择自己需要调试的进程即可；但是，如果需要调试Android Framework层的代码，这样做是达不到目的的——Framework层的代码通常运行在别的进程（比如ActivityManagerService运行在system_server进程），而这些进程通常情况下是不可调试的，也就是说在attach debugger to android process 的那个菜单里面不会有系统的进程，如下图：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1464596347439.png" alt="普通的无法调试的Android设备"></p>
<p>为什么不可调试呢？上文我们简要讲述了调试器的工作原理，我们知道每一个虚拟机有一个jdwp线程，如果这个线程拒绝连接到调试器，你也就没办法对这个进程进行调试了。Android的所有App进程都是通过Zygote进程fork出来的，我们在<code>android.os.Process</code>这个类里面可以看到android进程的启动过程有这么一句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((debugFlags &amp; Zygote.DEBUG_ENABLE_DEBUGGER) != <span class="number">0</span>) &#123;</span><br><span class="line">    argsForZygote.add(<span class="string">"--enable-debugger"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，一个进程是否可以调试是由进程启动时候的参数决定的；普通的App进程如果是debug keystore默认是可以调试的，有或者你在AndroidManifest里面指定debuggable为true也是可以调试的。对系统进程，我们只有采取系统级别的手段：让整个系统可以调试——debug版或者编译参数debuggable为1的系统。</p>
<p>解决这个办法很简单：使用模拟器（真机也行，限Nexus系列刷原生Android系统，把系统启动的debuggable参数修改为1），我的Nexus 5 可以调试的进程如下：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1464596367660.png" alt="可调试任意进程的设备"></p>
<p>这样，系统中所有的Android进程都可以调试了；这一点很重要，比如你要分析Activity的启动流程，相当多一部分代码是在ActivityManagerService所在的进程system_server执行的，如果你把断点打在别的进程，就会产生跟丢了的情况。在比如，你要调试ActivityThread的main函数，在main函数里面执行了一句attach，最终调用AMS的attachApplication的时候，代码就通过Binder IPC调用到了AMS的system_server进程。</p>
<p>明白你要执行的代码运行在哪一个进程相当重要，在Android中，由于Binder通信机制的存在，「进程迁移」使用的非常非常频繁，因此需要对binder机制有一定的了解；详细的话可以参考我的博客：<a href="http://weishu.me/2016/01/12/binder-index-for-newer/">Binder学习指南</a></p>
<h3 id="如何在对应的代码处下断点？">如何在对应的代码处下断点？</h3><p>假设我们现在把debugger attach到了正确的进程，那么断点应该下在哪里呢？直观来讲，就是说我需要导入所有的Android源码吗？如果不是应该导入哪些代码，怎么导入？</p>
<p>首先，如果你需要调试的类在sdk里面导出了，你压根儿就不需要再导入源码，Android Studio自动帮你关联了这部分代码（前提是你用SDK Manager下载了sdk的源码，如下图：</p>
<p><img src="http://weishu.dimensionalzone.com/201605/1464596414635.png" alt="SDK manager下载源码"></p>
<p>比如你要调试ActivityManagerService类的attachApplication方法，那么很简单；创建一个空的Android项目，SDK版本选择与你要调试的模拟器/真机 的android相同（这很重要，下文会讲述）；然后attrach 到system_server进程（debugger显示的名字为system_process)，直接在attach_application上面打上断点；随便启动一个app，可以看到我们熟悉的调试界面：</p>
<p><img src="http://weishu.dimensionalzone.com/201605/1464596428584.png" alt="调试attachApplication"></p>
<p>如果这部分类在sdk中没有导入（比如@hide)的，又或者压根儿不是SDK的类，（比如系统app的源码）那应该怎么办呢？直接导入这部分代码即可。不需要是Android项目，普通的Java项目即可；举个例子，假设你想调试原生Android系统的「系统设置」这个程序，该如何做呢？</p>
<p>根据上面的分析，我们首先得知道「系统设置˜」运行在哪一个进程，通常情况下进程名字就是包名；我们查出设置的包名即可，而包名是在源码的AndroidManifeist中声明的，因此，我们找到「系统设置」这个程序的源码即可；源码在 <a href="https://android.googlesource.com/" target="_blank" rel="external">https://android.googlesource.com/</a> ，系统App的源码在/packages这个子目录下面，我们一个个找，最终可以确定「系统设置」的源码在 <a href="https://android.googlesource.com/platform/packages/apps/Settings/" target="_blank" rel="external">https://android.googlesource.com/platform/packages/apps/Settings/</a> ；然后我们把这部分代码git clone下来，导入Android Studio：</p>
<p><img src="http://weishu.dimensionalzone.com/201605/1464596441461.png" alt="调试Settings"></p>
<p>我们去AndroidManifest中查到，「系统设置」的包名为：com.android.settings，这样我们attach到这个进程 ：</p>
<p><img src="http://weishu.dimensionalzone.com/201605/1464596456242.png" alt="attach setting进程"></p>
<p>然后，我们随便打个断点玩一玩，比如进入设置主界面的时候，断下来；我们在AndroidManifest中查到设置程序的入口界面为：Settings，我们在这个类的onCreate里面打一个断点，然后进入设置程序，发现完美滴断下来了：</p>
<p><img src="http://weishu.dimensionalzone.com/201605/1464596476109.png" alt="在setting中断点成功"></p>
<p>OK，到这里；应该学会如何在正确的位置打断点了：正确的进程，正确的位置。接下来，要完成调试，还需要一些技巧。</p>
<h2 id="如何跟踪代码？">如何跟踪代码？</h2><p>或许你会说，跟踪代码不就是step in/out/over么，这有什么难的？但其实事情并没有你想象的那么简单，要优雅滴调试，还是需要一些姿势的。</p>
<h3 id="行号对应">行号对应</h3><p>跟踪代码一个首要的问题是行号对应。如果你在正确位置下了断点，但是跟踪的时候，单步调试，发现运行的代码和Android Studio里面的代码对不上号，那么就很蛋疼；要使得调试器的行号能够对应，必须保证设备上的代码和调试器的代码是同一份；简单来说，需要使用Android的原生系统（模拟器，Nexus系列真机），然后调试器里面使用的SDK版本，必须和设备的系统版本一致。</p>
<h3 id="行号不对应怎么办？">行号不对应怎么办？</h3><p>一定要注意行号对应这一点，这会使调试过程简单很多；如果没有办法，行号对不上，那该如何调试呢？</p>
<p>行号不对应带来的一个首要问题就是，下断点的时候都有可能出现问题；比如你在TestClass的第100行下了一个断点，但是由于行号不对应，有可能真正执行的代码第100行是没有意义的空行或者是在下一个函数里面，这样断点就没有起到应有的作用了。</p>
<p>要解决行好对应的问题，必须使用<strong>方法断点</strong>；我们直接在某个函数的入口设置断点，这样即使行号对不上，也能在正确的入口出断下来，这一点非常重要。</p>
<p>解决了如何下断点的问题，那么行号不对应，怎么知道执行到哪了，怎么查看局部变量？</p>
<p><strong>观察栈桢</strong></p>
<p>在Android Studio的调试器的左边，显示了每一个线程执行的栈桢，栈桢里面包含了当前线程丰富的信息：</p>
<p><img src="http://weishu.dimensionalzone.com/201605/1464598434021.png" width="292"></p>
<p>看到没，真正运行的代码在哪一行，当前运行的是什么函数一目了然；接下来你在step into/out的时候，不能以源代码的行数为准，而应该以这个栈桢所显示的代码行数为准。</p>
<h3 id="熟练使用断点">熟练使用断点</h3><p>OK，现在不论行号是否能对应，我们都能正确滴下断点调试了。断点有很多种类型，方法断点，watch point，条件断点都能够很好滴辅助我们调试；如果你连这几个名词都没有听说过，一定要恶补一下；可以参阅我的博客：<a href="http://weishu.me/2015/12/21/android-studio-debug-tips-you-may-not-know/">Android Studio你不知道的调试技巧</a>；我就不再复述了。</p>
<p>如果你仔细看完了本文和我给出的链接，那么应该对Debug技术不再陌生了；接下来你可以选择Framework层的代码，手动调试一下加深理解；在日后的工作过程中，不断滴加强debug技术的练习，让它称为你解决复杂问题的条件反射，一定会事半功倍！还有记住：</p>
<blockquote>
<p>Debug the fucking source code.</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>Linus有一句名言广为人知：Read the fucking source code. 但其实，要深入理解某个软件、框架或者系统的工作原理，仅仅「看」代码是远远不够的。就拿Android Framework来说，整个代码量非常大不说，那些个动辄几万行的类如何去理解？所以我今天要说的就是：</p>
<p><strong>Debug the fucking source code!!</strong></p>
<p>之前分享过一个答案：<a href="https://www.zhihu.com/question/40300713/answer/86706105">大家遇到过什么 Android 兼容性问题？</a>，这里面的有一些非常诡异的问题，我相信光靠看代码你是永远定位不出来的。还有我写的一系列<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">Android插件框架原理</a>的文章，这里面涉及到大量Android Framework层的知识，有小伙伴会问，这些Framework层的原理，你是如何学习的呢，有诀窍吗？有！那就是调试。</p>
<p>Debug是一项非常非常重要的技能，毋庸多言。今天我就给大家分享一下「调试Android Framework」的经验，一旦掌握这项技能，那么Java层的任何问题都拦不住你了。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="debug" scheme="http://weishu.me/tags/debug/"/>
    
      <category term="framework" scheme="http://weishu.me/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 插件化原理解析——Service的插件化]]></title>
    <link href="http://weishu.me/2016/05/11/understand-plugin-framework-service/"/>
    <id>http://weishu.me/2016/05/11/understand-plugin-framework-service/</id>
    <published>2016-05-11T13:02:50.000Z</published>
    <updated>2019-01-30T04:06:02.861Z</updated>
    <content type="html"><![CDATA[<p>在 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/">Activity生命周期管理</a> 以及 <a href="http://weishu.me/2016/04/12/understand-plugin-framework-receiver/">广播的管理</a> 中我们详细探讨了Android系统中的Activity、BroadcastReceiver组件的工作原理以及它们的插件化方案，相信读者已经对Android Framework和插件化技术有了一定的了解；本文将探讨Android四大组件之一——Service组件的插件化方式。</p>
<p>与Activity, BroadcastReceiver相比，Service组件的不同点在哪里呢？我们能否用与之相同的方式实现Service的插件化？如果不行，它们的差别在哪里，应该如何实现Service的插件化？</p>
<p>我们接下来将围绕这几个问题展开，最终给出Service组件的插件化方式；阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>，参考此项目的 service-management 模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">索引</a>。</p>
<a id="more"></a>
<h2 id="Service工作原理">Service工作原理</h2><p>连Service的工作原理都不了解，谈何插件化？知己知彼。</p>
<p>Service分为两种形式：以startService<strong>启动</strong>的服务和用bindService<strong>绑定</strong>的服务；由于这两个过程大体相似，这里以稍复杂的<code>bindService</code>为例分析Service组件的工作原理。</p>
<p>绑定Service的过程是通过<code>Context</code>类的<code>bindService</code>完成的，这个方法需要三个参数：第一个参数代表想要绑定的Service的Intent，第二个参数是一个ServiceConnetion，我们可以通过这个对象接收到Service绑定成功或者失败的回调；第三个参数则是绑定时候的一些FLAG；关于服务的基本概念，可以参阅 <a href="http://developer.android.com/intl/zh-cn/guide/components/services.html" target="_blank" rel="external">官方文档</a>。（现在汉化了哦，E文不好童鞋的福音）</p>
<p>Context的具体实现在ContextImpl类，ContextImpl中的<code>bindService</code>方法直接调用了<code>bindServiceCommon</code>方法，此方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">bindServiceCommon</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags,</span><br><span class="line">        UserHandle user)</span> </span>&#123;</span><br><span class="line">    IServiceConnection sd;</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"connection is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// important</span></span><br><span class="line">        sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(),</span><br><span class="line">                mMainThread.getHandler(), flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not supported in system context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    validateServiceIntent(service);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        IBinder token = getActivityToken();</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span> &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == <span class="number">0</span> &amp;&amp; mPackageInfo != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion</span><br><span class="line">                &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">            flags |= BIND_WAIVE_PRIORITY;</span><br><span class="line">        &#125;</span><br><span class="line">        service.prepareToLeaveProcess();</span><br><span class="line">        <span class="keyword">int</span> res = ActivityManagerNative.getDefault().bindService(</span><br><span class="line">            mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">            service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">            sd, flags, getOpPackageName(), user.getIdentifier());</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Not allowed to bind to service "</span> + service);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致观察就能发现这个方法最终通过ActivityManagerNative借助AMS进而完成Service的绑定过程，在跟踪AMS的<code>bindService</code>源码之前，我们关注一下这个方法开始处创建的<code>sd</code>变量。这个变量的类型是<code>IServiceConnection</code>，如果读者还有印象，我们在 <a href="http://weishu.me/2016/04/12/understand-plugin-framework-receiver/">广播的管理</a> 一文中也遇到过类似的处理方式——IIntentReceiver；所以，这个IServiceConnection与IApplicationThread以及IIntentReceiver相同，都是ActivityThread给AMS提供的用来与之进行通信的Binder对象；这个接口的实现类为LoadedApk.ServiceDispatcher。</p>
<p>这个方法最终调用了ActivityManagerNative的bindService，而这个方法的真正实现在AMS里面，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bindService</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span><br><span class="line">        String resolvedType, IServiceConnection connection, <span class="keyword">int</span> flags, String callingPackage,</span><br><span class="line">        <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"bindService"</span>);</span><br><span class="line">    <span class="comment">// 略去参数校检</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mServices.bindServiceLocked(caller, token, service,</span><br><span class="line">                resolvedType, connection, flags, callingPackage, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bindService这个方法相当简单，只是做了一些参数校检之后直接调用了ActivityServices类的<code>bindServiceLocked</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bindServiceLocked</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span><br><span class="line">        String resolvedType, IServiceConnection connection, <span class="keyword">int</span> flags,</span><br><span class="line">        String callingPackage, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);</span><br><span class="line">    <span class="comment">// 参数校检，略</span></span><br><span class="line"></span><br><span class="line">    ServiceLookupResult res =</span><br><span class="line">        retrieveServiceLocked(service, resolvedType, callingPackage,</span><br><span class="line">                Binder.getCallingPid(), Binder.getCallingUid(), userId, <span class="keyword">true</span>, callerFg);</span><br><span class="line">    <span class="comment">// 结果校检， 略</span></span><br><span class="line">    ServiceRecord s = res.record;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ... 不关心， 略</span></span><br><span class="line"></span><br><span class="line">        mAm.startAssociationLocked(callerApp.uid, callerApp.processName,</span><br><span class="line">                s.appInfo.uid, s.name, s.processName);</span><br><span class="line"></span><br><span class="line">        AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp);</span><br><span class="line">        ConnectionRecord c = <span class="keyword">new</span> ConnectionRecord(b, activity,</span><br><span class="line">                connection, flags, clientLabel, clientIntent);</span><br><span class="line">        IBinder binder = connection.asBinder();</span><br><span class="line">        ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对connection进行处理， 方便存取，略</span></span><br><span class="line">        clist.add(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">            s.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (bringUpServiceLocked(s, service.getFlags(), callerFg, <span class="keyword">false</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 与BIND_AUTO_CREATE不同的启动FLAG，原理与后续相同，略</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法比较长，我这里省去了很多无关代码，只列出关键逻辑；首先它通过<code>retrieveServiceLocked</code>方法获取到了intent匹配到的需要bind到的Service组件<code>res</code>；然后把ActivityThread传递过来的IServiceConnection使用ConnectionRecord进行了包装，方便接下来使用；最后如果启动的FLAG为BIND_AUTO_CREATE，那么调用<code>bringUpServiceLocked</code>开始创建Service，我们跟踪这个方法：（非这种FLAG的代码已经省略，可以自行跟踪）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> String <span class="title">bringUpServiceLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> intentFlags, <span class="keyword">boolean</span> execInFg,</span><br><span class="line">        <span class="keyword">boolean</span> whileRestarting)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 略。。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> String procName = r.processName;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">        app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);</span><br><span class="line">                <span class="comment">// 1. important !!!</span></span><br><span class="line">                realStartServiceLocked(r, app, execInFg);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception when starting service "</span> + r.shortName, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app = r.isolatedProc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not running -- get it started, and enqueue this service record</span></span><br><span class="line">    <span class="comment">// to be executed when the app comes up.</span></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. important !!!</span></span><br><span class="line">        <span class="keyword">if</span> ((app=mAm.startProcessLocked(procName, r.appInfo, <span class="keyword">true</span>, intentFlags,</span><br><span class="line">                <span class="string">"service"</span>, r.name, <span class="keyword">false</span>, isolated, <span class="keyword">false</span>)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bringDownServiceLocked(r);</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isolated) &#123;</span><br><span class="line">            r.isolatedProc = app;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 略。。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方案同样也很长，但是实际上非常简单：注意我注释的两个important的地方，如果Service所在的进程已经启动，那么直接调用<code>realStartServiceLocked</code>方法来<strong>真正</strong>启动Service组件；如果Service所在的进程还没有启动，那么先在AMS中记下这个要启动的Service组件，然后通过<code>startProcessLocked</code>启动新的进程。</p>
<p>我们先看Service进程已经启动的情况，也即<code>realStartServiceLocked</code>分支：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span><br><span class="line">        ProcessRecord app, <span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 略。。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.startLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        mAm.ensurePackageDexOpt(r.serviceInfo.packageName);</span><br><span class="line">        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line">        r.postNotification();</span><br><span class="line">        created = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">        mAm.appDiedLocked(app);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 略。。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不关心，略。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法首先调用了app.thread的scheduleCreateService方法，我们知道，这是一个IApplicationThread对象，它是App所在进程提供给AMS的用来与App进程进行通信的Binder对象，这个Binder的Server端在ActivityThread的ApplicationThread类，因此，我们跟踪ActivityThread类，这个方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleCreateService</span><span class="params">(IBinder token,</span><br><span class="line">        ServiceInfo info, CompatibilityInfo compatInfo, <span class="keyword">int</span> processState)</span> </span>&#123;</span><br><span class="line">    updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">    CreateServiceData s = <span class="keyword">new</span> CreateServiceData();</span><br><span class="line">    s.token = token;</span><br><span class="line">    s.info = info;</span><br><span class="line">    s.compatInfo = compatInfo;</span><br><span class="line"></span><br><span class="line">    sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它不过是转发了一个消息给ActivityThread的<code>H</code>这个Handler，<code>H</code>类收到这个消息之后，直接调用了ActivityThread类的<code>handleCreateService</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateService</span><span class="params">(CreateServiceData data)</span> </span>&#123;</span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line"></span><br><span class="line">    LoadedApk packageInfo = getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line">    Service service = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">        service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ContextImpl context = ContextImpl.createAppContext(<span class="keyword">this</span>, packageInfo);</span><br><span class="line">        context.setOuterContext(service);</span><br><span class="line"></span><br><span class="line">        Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">        service.attach(context, <span class="keyword">this</span>, data.info.name, data.token, app,</span><br><span class="line">                ActivityManagerNative.getDefault());</span><br><span class="line">        service.onCreate();</span><br><span class="line">        mServices.put(data.token, service);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                    data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="comment">// nothing to do.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这段代码，是不是似曾相识？！没错，这里与Activity组件的创建过程如出一辙！所以这里就不赘述了，可以参阅 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/">Activity生命周期管理</a>。</p>
<p>需要注意的是，这里Service类的创建过程与Activity是略微有点不同的，虽然都是通过ClassLoader通过反射创建，但是Activity却把创建过程委托给了Instrumentation类，而Service则是直接进行。</p>
<p>OK，现在ActivityThread里面的<code>handleCreateService</code>方法成功创建出了Service对象，并且调用了它的<code>onCreate</code>方法；到这里我们的Service已经启动成功。<code>scheduleCreateService</code>这个Binder调用过程结束，代码又回到了AMS进程的<code>realStartServiceLocked</code>方法。这里我们不得不感叹Binder机制的精妙，如此简洁方便高效的跨进程调用，在进程之间来回穿梭，游刃有余。</p>
<p><code>realStartServiceLocked</code>方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span><br><span class="line">        ProcessRecord app, <span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 略。。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.startLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        mAm.ensurePackageDexOpt(r.serviceInfo.packageName);</span><br><span class="line">        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line">        r.postNotification();</span><br><span class="line">        created = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">        mAm.appDiedLocked(app);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 略。。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不关心，略。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法在完成<code>scheduleCreateService</code>这个binder调用之后，执行了一个<code>requestServiceBindingsLocked</code>方法；看方法名好像于「绑定服务」有关，它简单地执行了一个遍历然后调用了另外一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">requestServiceBindingLocked</span><span class="params">(ServiceRecord r, IntentBindRecord i,</span><br><span class="line">        <span class="keyword">boolean</span> execInFg, <span class="keyword">boolean</span> rebind)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r.app == <span class="keyword">null</span> || r.app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bumpServiceExecutingLocked(r, execInFg, <span class="string">"bind"</span>);</span><br><span class="line">            r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">            r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span><br><span class="line">                    r.app.repProcState);</span><br><span class="line">        <span class="comment">// 不关心，略。。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里又通过IApplicationThread这个Binder进行了一次IPC调用，我们跟踪ActivityThread类里面的ApplicationThread的<code>scheduleBindService</code>方法，发现这个方法不过通过Handler转发了一次消息，真正的处理代码在<code>handleBindService</code>里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindService</span><span class="params">(BindServiceData data)</span> </span>&#123;</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!data.rebind) &#123;</span><br><span class="line">                    IBinder binder = s.onBind(data.intent);</span><br><span class="line">                    ActivityManagerNative.getDefault().publishService(</span><br><span class="line">                            data.token, data.intent, binder);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s.onRebind(data.intent);</span><br><span class="line">                    ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ensureJitEnabled();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们要Bind的Service终于在这里完成了绑定！绑定之后又通过ActivityManagerNative这个Binder进行一次IPC调用，我们查看AMS的<code>publishService</code>方法，这个方法简单第调用了<code>publishServiceLocked</code>方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">publishServiceLocked</span><span class="params">(ServiceRecord r, Intent intent, IBinder service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Intent.FilterComparison filter</span><br><span class="line">                    = <span class="keyword">new</span> Intent.FilterComparison(intent);</span><br><span class="line">            IntentBindRecord b = r.bindings.get(filter);</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span> &amp;&amp; !b.received) &#123;</span><br><span class="line">                b.binder = service;</span><br><span class="line">                b.requested = <span class="keyword">true</span>;</span><br><span class="line">                b.received = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> conni=r.connections.size()-<span class="number">1</span>; conni&gt;=<span class="number">0</span>; conni--) &#123;</span><br><span class="line">                    ArrayList&lt;ConnectionRecord&gt; clist = r.connections.valueAt(conni);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;clist.size(); i++) &#123;</span><br><span class="line">                        ConnectionRecord c = clist.get(i);</span><br><span class="line">                        <span class="keyword">if</span> (!filter.equals(c.binding.intent.intent)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            c.conn.connected(r.name, service);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还记得我们之前提到的那个IServiceConnection吗？在<code>bindServiceLocked</code>方法里面，我们把这个IServiceConnection放到了一个ConnectionRecord的List中存放在ServiceRecord里面，这里所做的就是取出已经被Bind的这个Service对应的IServiceConnection对象，然后调用它的<code>connected</code>方法；我们说过，这个IServiceConnection也是一个Binder对象，它的Server端在LoadedApk.ServiceDispatcher里面。代码到这里已经很明确了，由于分析过程过长，再继续估计大家要瞌睡了；接下来的过程非常简单，感兴趣的读者自行查阅LoadedApk.ServiceDispatcher的<code>connected</code>方法，一路跟踪弄清楚ServiceConnection回调过程，完成最后的拼图！</p>
<p>最后提一点，以上我们分析了Service所在进程已经存在的情况，如果Service所在进程不存在，那么会调用startProcessLocked方法创建一个新的进程，并把需要启动的Service放在一个队列里面；创建进程的过程通过Zygote fork出来，进程创建成功之后会调用ActivityThread的main方法，在这个main方法里面间接调用到了AMS的attachApplication方法，在AMS的attachApplication里面会检查刚刚那个待启动Service队列里面的内容，并执行Service的启动操作；之后的启动过程与进程已经存在的情况下相同；可以自行分析。</p>
<h2 id="Service的插件化思路">Service的插件化思路</h2><p>现在我们已经明白了Service组件的工作原理，可对如何实现Service的插件化依然是一头雾水。</p>
<p>从上文的源码分析来看，Service组件与Activity有着非常多的相似之处：它们都是通过Context类完成启动，接着通过ActivityMnagaerNative进入AMS，最后又通过IApplicationThread这个Binder IPC到App进程的Binder线程池，然后通过H转发消息到App进程的主线程，最终完成组件生命周期的回调；对于Service组件，看起来好像可以沿用Activity组件的插件化方式：Hook掉ActivityManagerNative以及<code>H</code>类，但事实真的如此吗？</p>
<h3 id="Service与Activity的异同">Service与Activity的异同</h3><p>Service组件和Activity组件有什么不同？这些不同使得我们对于插件化方案的选择又有什么影响？</p>
<h4 id="用户交互对于生命周期的影响">用户交互对于生命周期的影响</h4><p>首先，Activity与Service组件最大的不同点在于，Activity组件可以与用户进行交互；这一点意味着用户的行为会对Activity组件产生影响，对我们来说最重要的影响就是Activity组件的生命周期；用户点击按钮从界面A跳转到界面B，会引起A和B这两个Activity一系列生命周期的变化。而Service组件则代表后台任务，除了内存不足系统回收之外，它的生命周期完全由我们的代码控制，与用户的交互无关。</p>
<p>这意味着什么？</p>
<p>Activity组件的生命周期受用户交互影响，而这种变化只有Android系统才能感知，因此我们必须把插件的Activity交给系统管理，才能拥有完整的生命周期；但Service组件的生命周期不受外界因素影响，那么自然而然，我们可以<strong>手动控制它的生命周期</strong>，就像我们对于BroadcastReceiver的插件化方式一样！Activity组件的插件化无疑是比较复杂的，为了把插件Activity交给系统管理进而拥有完整生命周期，我们设计了一个天衣无缝的方案骗过了AMS；既然Service的生命周期可以由我们自己控制，那么我们可以有更简单的方案实现它的插件化。</p>
<h4 id="Activity的任务栈">Activity的任务栈</h4><p>上文指出了Activity和Service组件在处理用户交互方面的不同，这使得我们对于Service组建的插件化可以选择一种较为简单的方式；也许你会问，那采用Activity插件化的那一套技术能够实现Service组件的插件化吗？</p>
<p>很遗憾，答案是不行的。虽然Activity的插件化技术更复杂，但是这种方案并不能完成Service组件的插件化——复杂的方案并不意味了它能处理更多的问题。</p>
<p>原因在于Activity拥有任务栈的概念。或许你觉得任务栈并不是什么了不起的东西，但是，这确实是Service组件与Activity组件插件化方式分道扬镳的根本原因。</p>
<p>任务栈的概念使得Activtiy的创建就代表着入栈，销毁则代表出栈；又由于Activity代表着与用户交互的界面，所以这个栈的深度不可能太深——Activity栈太深意味着用户需要狂点back键才能回到初始界面，这种体验显然有问题；因此，插件框架要处理的Activity数量其实是有限的，所以我们在AndroidManifest.xml中声明有限个StubActivity就能满足插件启动近乎无限个插件Activity的需求。</p>
<p>但是Service组件不一样，理论情况下，可以启动的Service组件是无限的——除了硬件以及内存资源，没有什么限制它的数目；如果采用Activity的插件化方式，就算我们在AndroidMafenist.xml中声明再多的StubService，总有不能满足插件中要启动的Service数目的情况出现。也许有童鞋会说，可以用一个StubService对应多个插件Service，这确实能解决部分问题；但是，下面的这个区别让这种设想彻底泡汤。</p>
<h4 id="Service无法拥有多实例">Service无法拥有多实例</h4><p>Service组件与Activity组件另外一个不同点在于，对同一个Service调用多次startService并不会启动多个Service实例，而非特定Flag的Activity是可以允许这种情况存在的，因此如果用StubService的方式，为了实现Service的这种特性，必须建立一个StubService到插件Service的一个Map，Map的这种一一对应关系使得我们使用一个StubService对应多个插件Service的计划成为天方夜谭。</p>
<p>至此，结论已经非常清晰——对于Service组件的插件化，我们不能简单地套用Activity的方案。</p>
<h3 id="如何实现Service的插件化？">如何实现Service的插件化？</h3><p>上文指出，我们不能套用Activity的方案实现Service组件的插件化，可以通过手动控制Service组件的生命周期实现；我们先来看一下Service的生命周期：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1462949033406.png" alt="Service生命周期"></p>
<p>从图中可以看出，Service的生命周期相当简单：整个生命周期从调用 onCreate() 开始起，到 onDestroy() 返回时结束。对于非绑定服务，就是从startService调用到stopService或者stopSelf调用。对于绑定服务，就是bindService调用到unbindService调用；</p>
<p>如果要手动控制Service组件的生命周期，我们只需要模拟出这个过程即可；而实现这一点并不复杂：</p>
<ol>
<li>如果以startService方式启动插件Service，直接回调要启动的Service对象的onStartCommand方法即可；如果用stopService或者stopSelf的方式停止Service，只需要回调对应的Service组件的onDestroy方法。</li>
<li>如果用bindService方式绑定插件Service，可以调用对应Service对应的onBind方法，获取onBind方法返回的Binder对象，然后通过ServiceConnection对象进行回调统计；unBindService的实现同理。</li>
</ol>
<h4 id="完全手动控制">完全手动控制</h4><p>现在我们已经有了实现思路，那么具体如何实现呢？</p>
<p>我们必须在startService,stopService等方法被调用的时候拿到控制权，才能手动去控制Service的生命周期；要达到这一目的非常简单——Hook ActivityManagerNative即可。在Activity的插件化方案中我们就通过这种方式接管了startActivity调用，相信读者并不陌生。</p>
<p>我们Hook掉ActivityManagerNative之后，可以拦截对于startService以及stopService等方法的调用；拦截之后，我们可以直接对插件Service进行操作：</p>
<ol>
<li>拦截到startService之后，如果Service还没有创建就直接创建Service对象（可能需要加载插件），然后调用这个Service的onCreate,onStartCommond方法；如果Service已经创建，获取到原来创建的Service对象并执行其onStartCommand方法。</li>
<li>拦截到stopService之后，获取到对应的Service对象，直接调用这个Service的onDestroy方法。</li>
</ol>
<p>这种方案简直简单得让人不敢相信！很可惜，这么干是不行的。</p>
<p>首先，Service存在的意义在于它作为一个后台任务，拥有相对较高运行时优先级；除非在内存及其不足威胁到前台Activity的时候，这个组件才会被系统杀死。上述这种实现完全把Service当作一个普通的Java对象使用了，因此并没有完全实现Service所具备的能力。</p>
<p>其次，Activity以及Service等组件是可以指定进程的，而让Service运行在某个特定进程的情况非常常见——所谓的远程Service；用上述这种办法压根儿没有办法让某个Service对象运行在一个别的进程。Android系统给开发者控制进程的机会太少了，要么在AndroidManifest.xml中通过process属性指定，要么借助Java的Runtime类或者native的fork；这几种方式都无法让我们以一种简单的方式配合上述方案达到目的。</p>
<h4 id="代理分发技术">代理分发技术</h4><p>既然我们希望插件的Service具有一定的运行时优先级，那么一个货真价实的Service组件是必不可少的——只有这种被系统认可的真正的Service组件才具有所谓的运行时优先级。</p>
<p>因此，我们可以注册一个真正的Service组件ProxyService，让这个Service承载一个真正的Service组件所具备的能力（进程优先级等）；当启动插件的服务比如PluginService的时候，我们统一启动这个ProxyService，当这个ProxyService运行起来之后，再在它的onStartCommand等方法里面进行分发，执行PluginService的onStartCommond等对应的方法；我们把这种方案形象地称为「代理分发技术」</p>
<p>代理分发技术也可以完美解决插件Service可以运行在不同的进程的问题——我们可以在AndroidManifest.xml中注册多个ProxyService，指定它们的process属性，让它们运行在不同的进程；当启动的插件Service希望运行在一个新的进程时，我们可以选择某一个合适的ProxyService进行分发。也许有童鞋会说，那得注册多少个ProxyService才能满足需求啊？理论上确实存在这问题，但事实上，一个App使用超过10个进程的几乎没有；因此这种方案是可行的。</p>
<h2 id="Service插件化的实现">Service插件化的实现</h2><p>现在我们已经设计出了Service组件的插件化方案，接下来我们以startService以及stopService为例实现这个过程。</p>
<h3 id="注册代理Service">注册代理Service</h3><p>我们需要一个货真价实的Service组件来承载进程优先级等功能，因此需要在AndroidManifest.xml中声明一个或者多个（用以支持多进程）这样的Sevice：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">service</span></span><br><span class="line">        <span class="attribute">android:name</span>=<span class="value">"com.weishu.upf.service_management.app.ProxyService"</span></span><br><span class="line">        <span class="attribute">android:process</span>=<span class="value">"plugin01"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="拦截startService等调用过程">拦截startService等调用过程</h3><p>要手动控制Service组件的生命周期，需要拦截startService,stopService等调用，并且把启动插件Service全部重定向为启动ProxyService（保留原始插件Service信息）；这个拦截过程需要Hook ActvityManagerNative，我们对这种技术应该是轻车熟路了；不了解的童鞋可以参考之前的文章 <a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/">Hook机制之AMS&amp;PMS</a> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hookActivityManagerNative</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException,</span><br><span class="line">        NoSuchMethodException, InvocationTargetException,</span><br><span class="line">        IllegalAccessException, NoSuchFieldException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; activityManagerNativeClass = Class.forName(<span class="string">"android.app.ActivityManagerNative"</span>);</span><br><span class="line"></span><br><span class="line">    Field gDefaultField = activityManagerNativeClass.getDeclaredField(<span class="string">"gDefault"</span>);</span><br><span class="line">    gDefaultField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    Object gDefault = gDefaultField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gDefault是一个 android.util.Singleton对象; 我们取出这个单例里面的字段</span></span><br><span class="line">    Class&lt;?&gt; singleton = Class.forName(<span class="string">"android.util.Singleton"</span>);</span><br><span class="line">    Field mInstanceField = singleton.getDeclaredField(<span class="string">"mInstance"</span>);</span><br><span class="line">    mInstanceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ActivityManagerNative 的gDefault对象里面原始的 IActivityManager对象</span></span><br><span class="line">    Object rawIActivityManager = mInstanceField.get(gDefault);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个这个对象的代理对象, 然后替换这个字段, 让我们的代理对象帮忙干活</span></span><br><span class="line">    Class&lt;?&gt; iActivityManagerInterface = Class.forName(<span class="string">"android.app.IActivityManager"</span>);</span><br><span class="line">    Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> Class&lt;?&gt;[] &#123; iActivityManagerInterface &#125;, <span class="keyword">new</span> IActivityManagerHandler(rawIActivityManager));</span><br><span class="line">    mInstanceField.set(gDefault, proxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在收到startService,stopService之后可以进行具体的操作，对于startService来说，就是直接替换启动的插件Service为ProxyService等待后续处理，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">"startService"</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="comment">// API 23:</span></span><br><span class="line">    <span class="comment">// public ComponentName startService(IApplicationThread caller, Intent service,</span></span><br><span class="line">    <span class="comment">//        String resolvedType, int userId) throws RemoteException</span></span><br><span class="line">    <span class="comment">// 找到参数里面的第一个Intent 对象</span></span><br><span class="line">    Pair&lt;Integer, Intent&gt; integerIntentPair = foundFirstIntentOfArgs(args);</span><br><span class="line">    Intent newIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">    <span class="comment">// 代理Service的包名, 也就是我们自己的包名</span></span><br><span class="line">    String stubPackage = UPFApplication.getContext().getPackageName();</span><br><span class="line">    <span class="comment">// 这里我们把启动的Service替换为ProxyService, 让ProxyService接收生命周期回调</span></span><br><span class="line">    ComponentName componentName = <span class="keyword">new</span> ComponentName(stubPackage, ProxyService.class.getName());</span><br><span class="line">    newIntent.setComponent(componentName);</span><br><span class="line">    <span class="comment">// 把我们原始要启动的TargetService先存起来</span></span><br><span class="line">    newIntent.putExtra(AMSHookHelper.EXTRA_TARGET_INTENT, integerIntentPair.second);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 替换掉Intent, 达到欺骗AMS的目的</span></span><br><span class="line">    args[integerIntentPair.first] = newIntent;</span><br><span class="line">    Log.v(TAG, <span class="string">"hook method startService success"</span>);</span><br><span class="line">    <span class="keyword">return</span> method.invoke(mBase, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对stopService的处理略有不同但是大同小异，读者可以上 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">github</a> 查阅源码。</p>
<h3 id="分发Service">分发Service</h3><p>Hook ActivityManagerNative之后，所有的插件Service的启动都被重定向了到了我们注册的ProxyService，这样可以保证我们的插件Service有一个真正的Service组件作为宿主；但是要执行特定插件Service的任务，我们必须把这个任务分发到真正要启动的Service上去；以<code>onStart</code>为例，在启动ProxyService之后，会收到ProxyService的<code>onStart</code>回调，我们可以在这个方法里面把具体的任务交给原始要启动的插件Service组件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"onStart() called with "</span> + <span class="string">"intent = ["</span> + intent + <span class="string">"], startId = ["</span> + startId + <span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分发Service</span></span><br><span class="line">    ServiceManager.getInstance().onStart(intent, startId);</span><br><span class="line">    <span class="keyword">super</span>.onStart(intent, startId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="加载Service">加载Service</h4><p>我们可以在ProxyService里面把任务转发给真正要启动的插件Service组件，要完成这个过程肯定需要创建一个对应的插件Service对象，比如PluginService；但是通常情况下插件存在与单独的文件之中，正常的方式是无法创建这个PluginService对象的，宿主程序默认的ClassLoader无法加载插件中对应的这个类；所以，要创建这个对应的PluginService对象，必须先完成插件的加载过程，让这个插件中的所有类都可以被正常访问；这种技术我们在之前专门讨论过，并给出了「激进方案」和「保守方案」，不了解的童鞋可以参考文章 <a href="http://weishu.me/2016/04/05/understand-plugin-framework-classloader/">插件加载机制</a>；这里我选择代码较少的「保守方案」为例（Droid Plugin中采用的激进方案）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">patchClassLoader</span><span class="params">(ClassLoader cl, File apkFile, File optDexFile)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException, NoSuchMethodException, IOException, InvocationTargetException, InstantiationException, NoSuchFieldException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 BaseDexClassLoader : pathList</span></span><br><span class="line">    Field pathListField = DexClassLoader.class.getSuperclass().getDeclaredField(<span class="string">"pathList"</span>);</span><br><span class="line">    pathListField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object pathListObj = pathListField.get(cl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 PathList: Element[] dexElements</span></span><br><span class="line">    Field dexElementArray = pathListObj.getClass().getDeclaredField(<span class="string">"dexElements"</span>);</span><br><span class="line">    dexElementArray.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object[] dexElements = (Object[]) dexElementArray.get(pathListObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Element 类型</span></span><br><span class="line">    Class&lt;?&gt; elementClass = dexElements.getClass().getComponentType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个数组, 用来替换原始的数组</span></span><br><span class="line">    Object[] newElements = (Object[]) Array.newInstance(elementClass, dexElements.length + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造插件Element(File file, boolean isDirectory, File zip, DexFile dexFile) 这个构造函数</span></span><br><span class="line">    Constructor&lt;?&gt; constructor = elementClass.getConstructor(File.class, <span class="keyword">boolean</span>.class, File.class, DexFile.class);</span><br><span class="line">    Object o = constructor.newInstance(apkFile, <span class="keyword">false</span>, apkFile, DexFile.loadDex(apkFile.getCanonicalPath(), optDexFile.getAbsolutePath(), <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    Object[] toAddElementArray = <span class="keyword">new</span> Object[] &#123; o &#125;;</span><br><span class="line">    <span class="comment">// 把原始的elements复制进去</span></span><br><span class="line">    System.arraycopy(dexElements, <span class="number">0</span>, newElements, <span class="number">0</span>, dexElements.length);</span><br><span class="line">    <span class="comment">// 插件的那个element复制进去</span></span><br><span class="line">    System.arraycopy(toAddElementArray, <span class="number">0</span>, newElements, dexElements.length, toAddElementArray.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换</span></span><br><span class="line">    dexElementArray.set(pathListObj, newElements);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="匹配过程">匹配过程</h4><p>上文中我们把启动插件Service重定向为启动ProxyService，现在ProxyService已经启动，因此必须把控制权交回原始的PluginService；在加载插件的时候，我们存储了插件中所有的Service组件的信息，因此，只需要根据Intent里面的Component信息就可以取出对应的PluginService。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ServiceInfo <span class="title">selectPluginService</span><span class="params">(Intent pluginIntent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ComponentName componentName : mServiceInfoMap.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (componentName.equals(pluginIntent.getComponent())) &#123;</span><br><span class="line">            <span class="keyword">return</span> mServiceInfoMap.get(componentName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建以及分发">创建以及分发</h4><p>插件被加载之后，我们就需要创建插件Service对应的Java对象了；由于这些类是在运行时动态加载进来的，肯定不能直接使用<code>new</code>关键字——我们需要使用反射机制。但是下面的代码创建出插件Service对象能满足要求吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl = getClassLoader();</span><br><span class="line">Service service = cl.loadClass(<span class="string">"com.plugin.xxx.PluginService1"</span>);</span><br></pre></td></tr></table></figure>
<p>Service作为Android系统的组件，最重要的特点是它具有<code>Context</code>；所以，直接通过反射创建出来的这个PluginService就是一个壳子——没有Context的Service能干什么？因此我们需要给将要创建的Service类创建出Conetxt；但是Context应该如何创建呢？我们平时压根儿没有这么干过，Context都是系统给我们创建好的。既然这样，我们可以参照一下系统是如何创建Service对象的；在上文的Service源码分析中，在ActivityThread类的handleCreateService完成了这个步骤，摘要如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">    service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ContextImpl context = ContextImpl.createAppContext(<span class="keyword">this</span>, packageInfo);</span><br><span class="line">    context.setOuterContext(service);</span><br><span class="line"></span><br><span class="line">    Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">    service.attach(context, <span class="keyword">this</span>, data.info.name, data.token, app,</span><br><span class="line">            ActivityManagerNative.getDefault());</span><br><span class="line">    service.onCreate();</span><br></pre></td></tr></table></figure>
<p>可以看到，系统也是通过反射创建出了对应的Service对象，然后也创建了对应的Context，并给Service注入了活力。如果我们模拟系统创建Context这个过程，势必需要进行一系列反射调用，那么我们何不直接反射handleCreateService方法呢？</p>
<p>当然，handleCreateService这个方法并没有把创建出来的Service对象作为返回值返回，而是存放在ActivityThread的成员变量<code>mService</code>之中，这个是小case，我们反射取出来就行；所以，创建Service对象的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 通过ActivityThread的handleCreateService方法创建出Service对象</span><br><span class="line"> * <span class="doctag">@param</span> serviceInfo 插件的ServiceInfo</span><br><span class="line"> * <span class="doctag">@throws</span> Exception</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">proxyCreateService</span><span class="params">(ServiceInfo serviceInfo)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    IBinder token = <span class="keyword">new</span> Binder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建CreateServiceData对象, 用来传递给ActivityThread的handleCreateService 当作参数</span></span><br><span class="line">    Class&lt;?&gt; createServiceDataClass = Class.forName(<span class="string">"android.app.ActivityThread$CreateServiceData"</span>);</span><br><span class="line">    Constructor&lt;?&gt; constructor  = createServiceDataClass.getDeclaredConstructor();</span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object createServiceData = constructor.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入我们创建的createServiceData的token字段, ActivityThread的handleCreateService用这个作为key存储Service</span></span><br><span class="line">    Field tokenField = createServiceDataClass.getDeclaredField(<span class="string">"token"</span>);</span><br><span class="line">    tokenField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    tokenField.set(createServiceData, token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入info对象</span></span><br><span class="line">    <span class="comment">// 这个修改是为了loadClass的时候, LoadedApk会是主程序的ClassLoader, 我们选择Hook BaseDexClassLoader的方式加载插件</span></span><br><span class="line">    serviceInfo.applicationInfo.packageName = UPFApplication.getContext().getPackageName();</span><br><span class="line">    Field infoField = createServiceDataClass.getDeclaredField(<span class="string">"info"</span>);</span><br><span class="line">    infoField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    infoField.set(createServiceData, serviceInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入compatInfo字段</span></span><br><span class="line">    <span class="comment">// 获取默认的compatibility配置</span></span><br><span class="line">    Class&lt;?&gt; compatibilityClass = Class.forName(<span class="string">"android.content.res.CompatibilityInfo"</span>);</span><br><span class="line">    Field defaultCompatibilityField = compatibilityClass.getDeclaredField(<span class="string">"DEFAULT_COMPATIBILITY_INFO"</span>);</span><br><span class="line">    Object defaultCompatibility = defaultCompatibilityField.get(<span class="keyword">null</span>);</span><br><span class="line">    Field compatInfoField = createServiceDataClass.getDeclaredField(<span class="string">"compatInfo"</span>);</span><br><span class="line">    compatInfoField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    compatInfoField.set(createServiceData, defaultCompatibility);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">    Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">    Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private void handleCreateService(CreateServiceData data) &#123;</span></span><br><span class="line">    Method handleCreateServiceMethod = activityThreadClass.getDeclaredMethod(<span class="string">"handleCreateService"</span>, createServiceDataClass);</span><br><span class="line">    handleCreateServiceMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    handleCreateServiceMethod.invoke(currentActivityThread, createServiceData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handleCreateService创建出来的Service对象并没有返回, 而是存储在ActivityThread的mServices字段里面, 这里我们手动把它取出来</span></span><br><span class="line">    Field mServicesField = activityThreadClass.getDeclaredField(<span class="string">"mServices"</span>);</span><br><span class="line">    mServicesField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Map mServices = (Map) mServicesField.get(currentActivityThread);</span><br><span class="line">    Service service = (Service) mServices.get(token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到之后, 移除这个service, 我们只是借花献佛</span></span><br><span class="line">    mServices.remove(token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将此Service存储起来</span></span><br><span class="line">    mServiceMap.put(serviceInfo.name, service);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们已经创建出了对应的PluginService，并且拥有至关重要的Context对象；接下来就可以把消息分发给原始的PluginService组件了，这个分发的过程很简单，直接执行消息对应的回调(onStart, onDestroy等）即可；因此，完整的startService分发过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Intent proxyIntent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Intent targetIntent = proxyIntent.getParcelableExtra(AMSHookHelper.EXTRA_TARGET_INTENT);</span><br><span class="line">    ServiceInfo serviceInfo = selectPluginService(targetIntent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (serviceInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"can not found service : "</span> + targetIntent.getComponent());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mServiceMap.containsKey(serviceInfo.name)) &#123;</span><br><span class="line">            <span class="comment">// service还不存在, 先创建</span></span><br><span class="line">            proxyCreateService(serviceInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Service service = mServiceMap.get(serviceInfo.name);</span><br><span class="line">        service.onStart(targetIntent, startId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们已经实现了Service组件的插件化；完整的代码见 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">github</a>，代码以startService, stopService为例进行了说明，bindService以及unbindService的原理是一样的，感兴趣的读者可以自行实现；欢迎PR。</p>
<h2 id="小节">小节</h2><p>本文中我们以绑定服务为例分析了Service组件的工作原理，并指出用户交导致组件生命周期的变化是Activity与Service的根本差别，这种差别使得插件方案对于它们必须采取不同的处理方式；最后我们通过手动控制Service组件的生命周期结合「代理分发技术」成功地实现了Service组件的插件化；这种插件化方案堪称「完美」，如果非要吹毛求疵，那只能说由于同一个进程的所有Service都挂载在同一个ProxyService上面，如果系统可用内存不够必须回收Service，杀死一个ProxyService会导致一大票的插件Service歇菜。</p>
<p>实际使用过程中，Service组件的更新频度并不高，因此直接把插件Service注册到主程序也是可以接受的；而且如果需要绑定远程Service，完全可以使用一个Service组件根据不同的Intent返回不同的IBinder，所以不实现Service组件的插件化也能满足工程需要。值得一提的是，我们对于Service组件的插件化方案实际上是一种「代理」的方式，用这种方式也能实现Activity组件的插件化，有一些开源的插件方案比如 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">DL</a> 就是这么做的。</p>
<p>迄今为止，我们讲述了了Activity、BroadcastReceiver以及Service的插件化方式，不知读者思索过没有，实现插件化的关键点在哪里？</p>
<p>Service，Activity等不过就是一些普通的Java类，它们之所称为四大组件，是因为他们有生命周期；这也是简单地采用Java的动态加载技术无法实现插件化的原因——动态加载进来的Service等类如果没有它的生命周期，无异于一个没有灵魂的傀儡。对于Activity组件，由于他的生命周期受用户交互影响，只有系统本身才能对这种交互有全局掌控力，因此它的插件化方式是Hook AMS，但是生命周期依然交由系统管理；而Service以及BroadcastReceiver的生命周期没有额外的因素影响，因此我们选择了手动控制其生命周期的方式。不论是借尸还魂还是女娲造人，对这些组件的插件化终归结底是要赋予组件“生命”。</p>
<p>插件化系列的文章有整整一个月没有更新了，非常抱歉！这段时间发生了很多事情，我实在抽不出时间照顾博客；而写这种文章又需要足够的时间准备，要跟踪源码分析过程，要找联系DroidPlugin作者确认设计思路，还要亲自写demo验证。<br>喜欢就点个赞吧，兜里有一块钱的童鞋可以点击下面的打赏然后扫一下二维码哦～持续更新，请关注github项目 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a> 和我的 <a href="http://weishu.me">博客</a>! </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/">Activity生命周期管理</a> 以及 <a href="http://weishu.me/2016/04/12/understand-plugin-framework-receiver/">广播的管理</a> 中我们详细探讨了Android系统中的Activity、BroadcastReceiver组件的工作原理以及它们的插件化方案，相信读者已经对Android Framework和插件化技术有了一定的了解；本文将探讨Android四大组件之一——Service组件的插件化方式。</p>
<p>与Activity, BroadcastReceiver相比，Service组件的不同点在哪里呢？我们能否用与之相同的方式实现Service的插件化？如果不行，它们的差别在哪里，应该如何实现Service的插件化？</p>
<p>我们接下来将围绕这几个问题展开，最终给出Service组件的插件化方式；阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework">understand-plugin-framework</a>，参考此项目的 service-management 模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">索引</a>。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="droidplugin" scheme="http://weishu.me/tags/droidplugin/"/>
    
      <category term="plugin framework" scheme="http://weishu.me/tags/plugin-framework/"/>
    
      <category term="service" scheme="http://weishu.me/tags/service/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android插件化原理解析——广播的管理]]></title>
    <link href="http://weishu.me/2016/04/12/understand-plugin-framework-receiver/"/>
    <id>http://weishu.me/2016/04/12/understand-plugin-framework-receiver/</id>
    <published>2016-04-12T11:08:16.000Z</published>
    <updated>2019-01-30T04:06:02.859Z</updated>
    <content type="html"><![CDATA[<p>在<a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/">Activity生命周期管理</a> 以及 <a href="http://weishu.me/2016/04/05/understand-plugin-framework-classloader/">插件加载机制</a> 中我们详细讲述了插件化过程中对于Activity组件的处理方式，为了实现Activity的插件化我们付出了相当多的努力；那么Android系统的其他组件，比如BroadcastReceiver，Service还有ContentProvider，它们又该如何处理呢？</p>
<p>相比Activity，BroadcastReceiver要简单很多——广播的生命周期相当简单；如果希望插件能够支持广播，这意味着什么？</p>
<p>回想一下我们日常开发的时候是如何使用BroadcastReceiver的：<strong>注册</strong>, <strong>发送</strong>和<strong>接收</strong>；因此，要实现BroadcastReceiver的插件化就这三种操作提供支持；接下来我们将一步步完成这个过程。</p>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>，参考此项目的<code>receiver-management</code> 模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">索引</a>。</p>
<a id="more"></a>
<p>如果连BroadcastReceiver的工作原理都不清楚，又怎么能让插件支持它？老规矩，知己知彼。</p>
<h2 id="源码分析">源码分析</h2><p>我们可以注册一个BroadcastReceiver然后接收我们感兴趣的广播，也可以给某有缘人发出某个广播；因此，我们对源码的分析按照两条路线展开：</p>
<h3 id="注册过程">注册过程</h3><p>不论是静态广播还是动态广播，在使用之前都是需要注册的；动态广播的注册需要借助Context类的registerReceiver方法，而静态广播的注册直接在AndroidManifest.xml中声明即可；我们首先分析一下动态广播的注册过程。</p>
<p>Context类的registerReceiver的真正实现在ContextImpl里面，而这个方法间接调用了registerReceiverInternal，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Intent <span class="title">registerReceiverInternal</span><span class="params">(BroadcastReceiver receiver, <span class="keyword">int</span> userId,</span><br><span class="line">        IntentFilter filter, String broadcastPermission,</span><br><span class="line">        Handler scheduler, Context context)</span> </span>&#123;</span><br><span class="line">    IIntentReceiver rd = <span class="keyword">null</span>; <span class="comment">// Important !!!!!</span></span><br><span class="line">    <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span> &amp;&amp; context != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = mPackageInfo.getReceiverDispatcher(</span><br><span class="line">                receiver, context, scheduler,</span><br><span class="line">                mMainThread.getInstrumentation(), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = <span class="keyword">new</span> LoadedApk.ReceiverDispatcher(</span><br><span class="line">                    receiver, context, scheduler, <span class="keyword">null</span>, <span class="keyword">true</span>).getIIntentReceiver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ActivityManagerNative.getDefault().registerReceiver(</span><br><span class="line">                mMainThread.getApplicationThread(), mBasePackageName,</span><br><span class="line">                rd, filter, broadcastPermission, userId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，BroadcastReceiver的注册也是通过<code>AMS</code>完成的；在进入<code>AMS</code>跟踪它的registerReceiver方法之前，我们先弄清楚这个<code>IIntentReceiver</code>类型的变量<code>rd</code>是什么。首先查阅API文档，很遗憾SDK里面没有导出这个类，我们直接去 <a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.0.1_r1/android/content/IIntentReceiver.java?av=f" target="_blank" rel="external">grepcode</a> 上看，文档如下：</p>
<blockquote>
<p>System private API for dispatching intent broadcasts. This is given to the activity manager as part of registering for an intent broadcasts, and is called when it receives intents.</p>
</blockquote>
<p>这个类是通过AIDL工具生成的，它是一个Binder对象，因此可以用来跨进程传输；文档说的很清楚，它是用来进行广播分发的。什么意思呢？</p>
<p>由于广播的分发过程是在AMS中进行的，而AMS所在的进程和BroadcastReceiver所在的进程不一样，因此要把广播分发到BroadcastReceiver具体的进程需要进行跨进程通信，这个<strong>通信的载体</strong>就是IIntentReceiver类。其实这个类的作用跟 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/">Activity生命周期管理</a> 中提到的 <code>IApplicationThread</code>相同，都是App进程给AMS进程用来进行通信的对象。另外，<code>IIntentReceiver</code>是一个接口，从上述代码中可以看出，它的实现类为LoadedApk.ReceiverDispatcher。</p>
<p>OK，我们继续跟踪源码，AMS类的registerReceiver方法代码有点多，这里不一一解释了，感兴趣的话可以自行查阅；这个方法主要做了以下两件事：</p>
<ol>
<li>对发送者的身份和权限做出一定的校检</li>
<li>把这个BroadcastReceiver以BroadcastFilter的形式存储在AMS的<code>mReceiverResolver</code>变量中，供后续使用。</li>
</ol>
<p>就这样，被传递过来的BroadcastReceiver已经成功地注册在系统之中，能够接收特定类型的广播了；那么注册在AndroidManifest.xml中的静态广播是如何被系统感知的呢？</p>
<p>在 <a href="http://weishu.me/2016/04/05/understand-plugin-framework-classloader/">插件加载机制</a> 中我们知道系统会通过PackageParser解析Apk中的AndroidManifest.xml文件，因此我们有理由认为，系统会在解析AndroidMafest.xml的&lt;receiver&gt;标签（也即静态注册的广播）的时候保存相应的信息；而Apk的解析过程是在PMS中进行的，因此<strong>静态注册广播的信息存储在PMS中</strong>。接下来的分析会证实这一结论。</p>
<h3 id="发送和接收过程">发送和接收过程</h3><h4 id="发送过程">发送过程</h4><p>发送广播很简单，就是一句context.sendBroadcast()，我们顺藤摸瓜，跟踪这个方法。前文也提到过，Context中方法的调用都会委托到ContextImpl这个类，我们直接看ContextImpl对这个方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.prepareToLeaveProcess();</span><br><span class="line">        ActivityManagerNative.getDefault().broadcastIntent(</span><br><span class="line">                mMainThread.getApplicationThread(), intent, resolvedType, <span class="keyword">null</span>,</span><br><span class="line">                Activity.RESULT_OK, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, AppOpsManager.OP_NONE, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>,</span><br><span class="line">                getUserId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，发送广播也是通过AMS进行的，我们直接查看ActivityManagerService类的broadcastIntent方法，这个方法仅仅是调用了broadcastIntentLocked方法，我们继续跟踪；broadcastIntentLocked这个方法相当长，处理了诸如粘性广播，顺序广播，各种Flag以及动态广播静态广播的接收过程，这些我们暂时不关心；值得注意的是，在这个方法中我们发现，其实<strong>广播的发送和接收是融为一体的</strong>。某个广播被发送之后，AMS会找出所有注册过的BroadcastReceiver中与这个广播匹配的接收者，然后将这个广播分发给相应的接收者处理。</p>
<h4 id="匹配过程">匹配过程</h4><p>某一条广播被发出之后，并不是阿猫阿狗都能接收它并处理的；BroadcastReceiver可能只对某些类型的广播感兴趣，因此它也只能接收和处理这种特定类型的广播；在broadcastIntentLocked方法内部有如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Figure out who all will receive this broadcast.</span></span><br><span class="line">List receivers = <span class="keyword">null</span>;</span><br><span class="line">List&lt;BroadcastFilter&gt; registeredReceivers = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// Need to resolve the intent to interested receivers...</span></span><br><span class="line"><span class="keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY)</span><br><span class="line">         == <span class="number">0</span>) &#123;</span><br><span class="line">    receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (intent.getComponent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userId == UserHandle.USER_ALL &amp;&amp; callingUid == Process.SHELL_UID) &#123;</span><br><span class="line">        <span class="comment">// Query one target user at a time, excluding shell-restricted users</span></span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        registeredReceivers = mReceiverResolver.queryIntent(intent,</span><br><span class="line">                resolvedType, <span class="keyword">false</span>, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个列表<code>receivers</code>和<code>registeredReceivers</code>，看名字好像是广播接收者的列表；下面是它们的赋值过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</span><br><span class="line">registeredReceivers = mReceiverResolver.queryIntent(intent, resolvedType, <span class="keyword">false</span>, userId);</span><br></pre></td></tr></table></figure>
<p>读者可以自行跟踪这两个方法的代码，过程比较简单，我这里直接给出结论：</p>
<ol>
<li><code>receivers</code>是对这个广播感兴趣的<strong>静态BroadcastReceiver</strong>列表；collectReceiverComponents 通过PackageManager获取了与这个广播匹配的静态BroadcastReceiver信息；这里也证实了我们在分析BroadcasrReceiver注册过程中的推论——静态BroadcastReceiver的注册过程的确实在PMS中进行的。</li>
<li><code>mReceiverResolver</code>存储了<strong>动态注册</strong>的BroadcastReceiver的信息；还记得这个<code>mReceiverResolver</code>吗？我们在分析动态广播的注册过程中发现，动态注册的BroadcastReceiver的相关信息最终存储在此对象之中；在这里，通过mReceiverResolver对象匹配出了对应的BroadcastReceiver供进一步使用。</li>
</ol>
<p>现在系统通过PMS拿到了所有符合要求的静态BroadcastReceiver，然后从AMS中获取了符合要求的动态BroadcastReceiver；因此接下来的工作非常简单：唤醒这些广播接受者。简单来说就是回调它们的<code>onReceive</code>方法。</p>
<h4 id="接收过程">接收过程</h4><p>通过上文的分析过程我们知道，在AMS的broadcastIntentLocked方法中找出了符合要求的所有BroadcastReceiver；接下来就需要把这个广播分发到这些接收者之中。在broadcastIntentLocked方法的后半部分有如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">        callerPackage, callingPid, callingUid, resolvedType,</span><br><span class="line">        requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</span><br><span class="line">        resultData, resultExtras, ordered, sticky, <span class="keyword">false</span>, userId);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);</span><br><span class="line"><span class="keyword">if</span> (!replaced) &#123;</span><br><span class="line">    queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">    queue.scheduleBroadcastsLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先创建了一个BroadcastRecord代表此次发送的这条广播，然后把它丢进一个队列，最后通过scheduleBroadcastsLocked通知队列对广播进行处理。</p>
<p>在BroadcastQueue中通过Handle调度了对于广播处理的消息，调度过程由processNextBroadcast方法完成，而这个方法通过performReceiveLocked最终调用了IIntentReceiver的performReceive方法。</p>
<p>这个<code>IIntentReceiver</code>正是在广播注册过程中由App进程提供给AMS进程的Binder对象，现在AMS通过这个Binder对象进行IPC调用通知广播接受者所在进程完成余下操作。在上文我们分析广播的注册过程中提到过，这个IItentReceiver的实现是LoadedApk.ReceiverDispatcher；我们查看这个对象的performReceive方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performReceive</span><span class="params">(Intent intent, <span class="keyword">int</span> resultCode, String data,</span><br><span class="line">        Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> </span>&#123;</span><br><span class="line">    Args args = <span class="keyword">new</span> Args(intent, resultCode, data, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line">    <span class="keyword">if</span> (!mActivityThread.post(args)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">            args.sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法创建了一个<code>Args</code>对象，然后把它post到了mActivityThread这个Handler中；我们查看<code>Args</code>类的<code>run</code>方法：(坚持一下，马上就分析完了 ^ ^)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BroadcastReceiver receiver = mReceiver;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> ordered = mOrdered;  </span><br><span class="line">    <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">    <span class="keyword">final</span> Intent intent = mCurIntent;</span><br><span class="line">    mCurIntent = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (receiver == <span class="keyword">null</span> || mForgotten) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ClassLoader cl =  mReceiver.getClass().getClassLoader(); <span class="comment">// Important!! load class</span></span><br><span class="line">        intent.setExtrasClassLoader(cl);</span><br><span class="line">        setExtrasClassLoader(cl);</span><br><span class="line">        receiver.setPendingResult(<span class="keyword">this</span>);</span><br><span class="line">        receiver.onReceive(mContext, intent); <span class="comment">// callback</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mInstrumentation == <span class="keyword">null</span> ||</span><br><span class="line">                !mInstrumentation.onException(mReceiver, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Error receiving broadcast "</span> + intent</span><br><span class="line">                + <span class="string">" in "</span> + mReceiver, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (receiver.getPendingResult() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们看到了相应BroadcastReceiver的<code>onReceive</code>回调；因此，广播的工作原理到这里就水落石出了；我们接下来将探讨如何实现对于广播的插件化。</p>
<h2 id="思路分析">思路分析</h2><p>上文中我们分析了BroadcastReceiver的工作原理，那么怎么才能实现对BroadcastReceiver的插件化呢？</p>
<p>从分析过程中我们发现，Framework对于静态广播和动态广播的处理是不同的；不过，这个不同之处仅仅体现在<strong>注册过程</strong>——静态广播需要在AndroidManifest.xml中注册，并且注册的信息存储在PMS中；动态广播不需要预注册，注册的信息存储在AMS中。</p>
<p>从实现Activity的插件化过程中我们知道，需要在AndroidManifest.xml中预先注册是一个相当麻烦的事情——我们需要使用『替身』并在合适的时候进行『偷梁换柱』；因此看起来动态广播的处理要容易那么一点，我们先讨论一下如何实现动态注册BroadcastReceiver的插件化。</p>
<p>首先，广播并没有复杂的生命周期，它的整个存活过程其实就是一个<code>onReceive</code>回调；而动态广播又不需要在AndroidManifest.xml中预先注册，所以动态注册的BroadcastReceiver其实可以当作一个普通的Java对象；我们完全可以用纯ClassLoader技术实现它——不就是把插件中的Receiver加载进来，然后想办法让它能接受<code>onReceive</code>回调嘛。</p>
<p>静态BroadcastReceiver看起来要复杂一些，但是我们连Activity都搞定了，还有什么难得到我们呢？对于实现静态BroadcastReceiver插件化的问题，有的童鞋或许会想，我们可以借鉴Activity的工作方式——用替身和Hook解决。但是很遗憾，这样是行不通的。为什么呢？</p>
<p>BroadcastReceiver有一个IntentFilter的概念，也就是说，每一个BroadcastReceiver只对特定的Broadcast感兴趣；而且，AMS在进行广播分发的时候，也会对这些BroadcastReceiver与发出的广播进行匹配，只有Intent匹配的Receiver才能收到广播；在分析源码的时候也提到了这个匹配过程。如果我们尝试用替身Receiver解决静态注册的问题，那么它的IntentFilter该写什么？我们无法预料插件中静态注册的Receiver会使用什么类型的IntentFilter，就算我们在AndroidManifest.xml中声明替身也没有用——我们压根儿收不到与我们的IntentFilter不匹配的广播。其实，我们对于Activity的处理方式也有这个问题；如果你尝试用IntentFilter的方式启动Activity，这并不能成功；这算得上是DroidPlugin的缺陷之一。</p>
<p>那么，我们就真的对静态BroadcastReceiver无能为力吗？想一想这里的难点是什么？</p>
<p>没错，主要是在静态BroadcastReceiver里面这个IntentFilter我们事先无法确定，它是动态变化的；但是，动态BroadcastReceiver不是可以动态添加IntentFilter吗！！！</p>
<p><strong>可以把静态广播当作动态广播处理</strong></p>
<p>既然都是广播，它们的功能都是订阅一个特定的消息然后执行某个特定的操作，我们完全可以把插件中的静态广播全部注册为动态广播，这样就解决了静态广播的问题。当然，这样也是有缺陷的，静态BroadcastReceiver与动态BroadcastReceiver一个非常大的不同之处在于：动态BroadcastReceiver在进程死亡之后是无法接收广播的，而静态BroadcastReceiver则可以——系统会唤醒Receiver所在进程；这算得上缺陷之二，当然，瑕不掩瑜。</p>
<h2 id="静态广播非静态的实现">静态广播非静态的实现</h2><p>上文我们提到，可以把静态BroadcastReceiver当作动态BroadcastReceiver处理；我们接下来实现这个过程。</p>
<h3 id="解析">解析</h3><p>要把插件中的静态BroadcastReceiver当作动态BroadcastReceiver处理，我们首先得知道插件中到底注册了哪些广播；这个过程归根结底就是获取AndroidManifest.xml中的&lt;receiver&gt;标签下面的内容，我们可以选择手动解析xml文件；这里我们选择使用系统的 PackageParser 帮助解析，这种方式在之前的 [插件加载过程][] 中也用到过，如果忘记了可以温习一下。</p>
<p>PackageParser中有一系列方法用来提取Apk中的信息，可是翻遍了这个类也没有找到与「Receiver」名字相关的方法；最终我们发现BroadcastReceiver信息是用与Activity相同的类存储的！这一点可以在PackageParser的内部类Package中发现端倪——成员变量<code>receivers</code>和<code>activities</code>的范型类型相同。所以，我们要解析apk的&lt;receiver&gt;的信息，可以使用PackageParser的<code>generateActivityInfo</code>方法。</p>
<p>知道这一点之后，代码就比较简单了；使用反射调用相应的隐藏接口，并且在必要的时候构造相应参数的方式我们在插件化系列文章中已经讲述过很多，相信读者已经熟练，这里就不赘述，直接贴代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parserReceivers</span><span class="params">(File apkFile)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class&lt;?&gt; packageParserClass = Class.forName(<span class="string">"android.content.pm.PackageParser"</span>);</span><br><span class="line">    Method parsePackageMethod = packageParserClass.getDeclaredMethod(<span class="string">"parsePackage"</span>, File.class, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">    Object packageParser = packageParserClass.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先调用parsePackage获取到apk对象对应的Package对象</span></span><br><span class="line">    Object packageObj = parsePackageMethod.invoke(packageParser, apkFile, PackageManager.GET_RECEIVERS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取Package对象里面的receivers字段,注意这是一个 List&lt;Activity&gt; (没错,底层把&lt;receiver&gt;当作&lt;activity&gt;处理)</span></span><br><span class="line">    <span class="comment">// 接下来要做的就是根据这个List&lt;Activity&gt; 获取到Receiver对应的 ActivityInfo (依然是把receiver信息用activity处理了)</span></span><br><span class="line">    Field receiversField = packageObj.getClass().getDeclaredField(<span class="string">"receivers"</span>);</span><br><span class="line">    List receivers = (List) receiversField.get(packageObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用generateActivityInfo 方法, 把PackageParser.Activity 转换成</span></span><br><span class="line">    Class&lt;?&gt; packageParser$ActivityClass = Class.forName(<span class="string">"android.content.pm.PackageParser$Activity"</span>);</span><br><span class="line">    Class&lt;?&gt; packageUserStateClass = Class.forName(<span class="string">"android.content.pm.PackageUserState"</span>);</span><br><span class="line">    Class&lt;?&gt; userHandler = Class.forName(<span class="string">"android.os.UserHandle"</span>);</span><br><span class="line">    Method getCallingUserIdMethod = userHandler.getDeclaredMethod(<span class="string">"getCallingUserId"</span>);</span><br><span class="line">    <span class="keyword">int</span> userId = (Integer) getCallingUserIdMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line">    Object defaultUserState = packageUserStateClass.newInstance();</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; componentClass = Class.forName(<span class="string">"android.content.pm.PackageParser$Component"</span>);</span><br><span class="line">    Field intentsField = componentClass.getDeclaredField(<span class="string">"intents"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要调用 android.content.pm.PackageParser#generateActivityInfo(android.content.pm.ActivityInfo, int, android.content.pm.PackageUserState, int)</span></span><br><span class="line">    Method generateReceiverInfo = packageParserClass.getDeclaredMethod(<span class="string">"generateActivityInfo"</span>,</span><br><span class="line">            packageParser$ActivityClass, <span class="keyword">int</span>.class, packageUserStateClass, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析出 receiver以及对应的 intentFilter</span></span><br><span class="line">    <span class="keyword">for</span> (Object receiver : receivers) &#123;</span><br><span class="line">        ActivityInfo info = (ActivityInfo) generateReceiverInfo.invoke(packageParser, receiver, <span class="number">0</span>, defaultUserState, userId);</span><br><span class="line">        List&lt;? extends IntentFilter&gt; filters = (List&lt;? extends IntentFilter&gt;) intentsField.get(receiver);</span><br><span class="line">        sCache.put(info, filters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注册">注册</h3><p>我们已经解析得到了插件中静态注册的BroadcastReceiver的信息，现在我们只需要把这些静态广播动态注册一遍就可以了；但是，由于BroadcastReceiver的实现类存在于插件之后，我们需要手动用ClassLoader来加载它；这一点在 <a href="http://weishu.me/2016/04/05/understand-plugin-framework-classloader/">插件加载机制</a> 已有讲述，不啰嗦了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (ActivityInfo activityInfo : ReceiverHelper.sCache.keySet()) &#123;</span><br><span class="line">    Log.i(TAG, <span class="string">"preload receiver:"</span> + activityInfo.name);</span><br><span class="line">    List&lt;? extends IntentFilter&gt; intentFilters = ReceiverHelper.sCache.get(activityInfo);</span><br><span class="line">    <span class="keyword">if</span> (cl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cl = CustomClassLoader.getPluginClassLoader(apk, activityInfo.packageName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把解析出来的每一个静态Receiver都注册为动态的</span></span><br><span class="line">    <span class="keyword">for</span> (IntentFilter intentFilter : intentFilters) &#123;</span><br><span class="line">        BroadcastReceiver receiver = (BroadcastReceiver) cl.loadClass(activityInfo.name).newInstance();</span><br><span class="line">        context.registerReceiver(receiver, intentFilter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就这样，我们对插件静态BroadcastReceiver的支持已经完成了，是不是相当简单？至于插件中的动态广播如何实现插件化，这一点<strong>交给读者自行完成</strong>，希望你在解决这个问题的过程中能够加深对于插件方案的理解 ^ ^</p>
<h2 id="小节">小节</h2><p>本文我们介绍了BroadcastReceiver组件的插件化方式，可以看到，插件方案对于BroadcastReceiver的处理相对简单；同时「静态广播非静态」的特性以及BroadcastReceiver先天的一些特点导致插件方案没有办法做到尽善尽美，不过这都是大醇小疵——在绝大多数情况下，这样的处理方式是可以满足需求的。</p>
<p>虽然对于BroadcastReceiver的处理方式相对简单，但是文章的内容却并不短——我们花了大量的篇幅讲述BroadcastReceiver的原理，这也是我的初衷：借助DroidPlugin更深入地了解Android Framework。</p>
<p>接下来为文章会讲述四大组件中的另外两个——Service和ContentProvider的插件化方案；喜欢就点个赞吧～持续更新，请关注github项目 <a href="http://weishu.me/2016/04/05/understand-plugin-framework-classloader/">understand-plugin-framework</a> 和我的 <a href="http://weishu.me">博客</a> ! 如果你觉得能从文中学到皮毛，还请支持一下 :)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在<a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/">Activity生命周期管理</a> 以及 <a href="http://weishu.me/2016/04/05/understand-plugin-framework-classloader/">插件加载机制</a> 中我们详细讲述了插件化过程中对于Activity组件的处理方式，为了实现Activity的插件化我们付出了相当多的努力；那么Android系统的其他组件，比如BroadcastReceiver，Service还有ContentProvider，它们又该如何处理呢？</p>
<p>相比Activity，BroadcastReceiver要简单很多——广播的生命周期相当简单；如果希望插件能够支持广播，这意味着什么？</p>
<p>回想一下我们日常开发的时候是如何使用BroadcastReceiver的：<strong>注册</strong>, <strong>发送</strong>和<strong>接收</strong>；因此，要实现BroadcastReceiver的插件化就这三种操作提供支持；接下来我们将一步步完成这个过程。</p>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework">understand-plugin-framework</a>，参考此项目的<code>receiver-management</code> 模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">索引</a>。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="broadcastreceiver" scheme="http://weishu.me/tags/broadcastreceiver/"/>
    
      <category term="droidplugin" scheme="http://weishu.me/tags/droidplugin/"/>
    
      <category term="plugin framework" scheme="http://weishu.me/tags/plugin-framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 插件化原理解析——插件加载机制]]></title>
    <link href="http://weishu.me/2016/04/05/understand-plugin-framework-classloader/"/>
    <id>http://weishu.me/2016/04/05/understand-plugin-framework-classloader/</id>
    <published>2016-04-05T12:13:01.000Z</published>
    <updated>2019-01-30T04:06:02.855Z</updated>
    <content type="html"><![CDATA[<p>上文 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/">Activity生命周期管理</a> 中我们地完成了『启动没有在AndroidManifest.xml中显式声明的Activity』的任务；通过Hook <code>AMS</code>和拦截ActivityThread中<code>H</code>类对于组件调度我们成功地绕过了AndroidMAnifest.xml的限制。</p>
<p>但是我们启动的『没有在AndroidManifet.xml中显式声明』的Activity和宿主程序存在于同一个Apk中；通常情况下，插件均以独立的文件存在甚至通过网络获取，这时候插件中的Activity能否成功启动呢？</p>
<p>要启动Activity组件肯定先要创建对应的Activity类的对象，从上文 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/">Activity生命周期管理</a> 知道，创建Activity类对象的过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">activity = mInstrumentation.newActivity(</span><br><span class="line">        cl, component.getClassName(), r.intent);</span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure>
<p>也就是说，系统通过<code>ClassLoader</code>加载了需要的Activity类并通过反射调用构造函数创建出了Activity对象。如果Activity组件存在于独立于宿主程序的文件之中，系统的ClassLoader怎么知道去哪里加载呢？因此，如果不做额外的处理，插件中的Activity对象甚至都没有办法创建出来，谈何启动？</p>
<p>因此，要使存在于独立文件或者网络中的插件被成功启动，首先就需要解决这个<strong>插件类加载</strong>的问题。<br>下文将围绕此问题展开，完成『启动没有在AndroidManifest.xml中显示声明，并且存在于外部插件中的Activity』的任务。</p>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>，参考此项目的<code>classloader-hook</code> 模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">索引</a>。</p>
<a id="more"></a>
<h2 id="ClassLoader机制">ClassLoader机制</h2><p>或许有的童鞋还不太了解Java的ClassLoader机制，我这里简要介绍一下。</p>
<blockquote>
<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校检、转换解析和初始化的，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。<br>与那些在编译时进行链连接工作的语言不同，在Java语言里面，类型的加载、连接和初始化都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以同代拓展的语言特性就是依赖运行期动态加载和动态链接这个特点实现的。例如，如果编写一个面相接口的应用程序，可以等到运行时在制定实际的实现类；用户可以通过Java与定义的和自定义的类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为代码的一部分，这种组装应用程序的方式目前已经广泛应用于Java程序之中。从最基础的Applet，JSP到复杂的OSGi技术，都使用了Java语言运行期类加载的特性。</p>
</blockquote>
<p>Java的类加载是一个相对复杂的过程；它包括加载、验证、准备、解析和初始化五个阶段；对于开发者来说，可控性最强的是<strong>加载阶段</strong>；加载阶段主要完成三件事：</p>
<ol>
<li>根据一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为JVM方法区中的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>『通过一个类的全限定名获取描述此类的二进制字节流』这个过程被抽象出来，就是Java的类加载器模块，也即JDK中ClassLoader API。</p>
<p>Android Framework提供了DexClassLoader这个类，简化了『通过一个类的全限定名获取描述次类的二进制字节流』这个过程；我们只需要告诉DexClassLoader一个dex文件或者apk文件的路径就能完成类的加载。因此本文的内容用一句话就可以概括：</p>
<p><strong>将插件的dex或者apk文件告诉『合适的』DexClassLoader，借助它完成插件类的加载</strong></p>
<p>关于CLassLoader机制更多的内容，请参阅『深入理解Java虚拟机』这本书。</p>
<h2 id="思路分析">思路分析</h2><p>Android系统使用了ClassLoader机制来进行Activity等组件的加载；apk被安装之后，APK文件的代码以及资源会被系统存放在固定的目录（比如/data/app/package_name/base-1.apk )系统在进行类加载的时候，会自动去这一个或者几个特定的路径来寻找这个类；但是系统并不知道存在于插件中的Activity组件的信息(插件可以是任意位置，甚至是网络，系统无法提前预知)，因此正常情况下系统无法加载我们插件中的类；因此也没有办法创建Activity的对象，更不用谈启动组件了。</p>
<p>解决这个问题有两个思路，要么全盘接管这个类加载的过程；要么告知系统我们使用的插件存在于哪里，让系统帮忙加载；这两种方式或多或少都需要<strong>干预</strong>这个类加载的过程。老规矩，知己知彼，百战不殆。我们首先分析一下，系统是如果完成这个类加载过程的。</p>
<p>我们再次搬出Activity的创建过程的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure>
<p>这里可以很明显地看到，系统通过待启动的Activity的类名<code>className</code>，然后使用ClassLoader对象<code>cl</code>把这个类加载进虚拟机，最后使用反射创建了这个Activity类的实例对象。要想干预这个ClassLoader（告知它我们的路径或者替换他），我们首先得看看这玩意到底是个什么来头。（从哪里创建的）</p>
<p><code>cl</code>这个ClasssLoader对象通过<code>r.packageInfo</code>对象的getClassLoader()方法得到，r.packageInfo是一个LoadedApk类的对象；那么，LoadedApk到底是个什么东西？？</p>
<p>我们查阅LoadedApk类的文档，只有一句话，不过说的很明白：</p>
<blockquote>
<p>Local state maintained about a currently loaded .apk.</p>
</blockquote>
<p><strong>LoadedApk对象是APK文件在内存中的表示。</strong> Apk文件的相关信息，诸如Apk文件的代码和资源，甚至代码里面的Activity，Service等组件的信息我们都可以通过此对象获取。</p>
<p>OK, 我们知道这个LoadedApk是何方神圣了；接下来我们要搞清楚的是：这个 <code>r.packageInfo</code> 到底是从哪里获取的？</p>
<p>我们顺着 performLaunchActivity上溯，辗转handleLaunchActivity回到了 <code>H</code> 类的LAUNCH_ACTIVITY消息，找到了<code>r.packageInfo</code>的来源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line">r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">        r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">handleLaunchActivity(r, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>getPackageInfoNoCheck方法很简单，直接调用了getPackageInfo方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> LoadedApk <span class="title">getPackageInfoNoCheck</span><span class="params">(ApplicationInfo ai,</span><br><span class="line">        CompatibilityInfo compatInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getPackageInfo(ai, compatInfo, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个getPackageInfo方法里面我们发现了端倪：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LoadedApk <span class="title">getPackageInfo</span><span class="params">(ApplicationInfo aInfo, CompatibilityInfo compatInfo,</span><br><span class="line">        ClassLoader baseLoader, <span class="keyword">boolean</span> securityViolation, <span class="keyword">boolean</span> includeCode,</span><br><span class="line">        <span class="keyword">boolean</span> registerPackage)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取userid信息</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> differentUser = (UserHandle.myUserId() != UserHandle.getUserId(aInfo.uid));</span><br><span class="line">    <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">    <span class="comment">// 尝试获取缓存信息</span></span><br><span class="line">        WeakReference&lt;LoadedApk&gt; ref;</span><br><span class="line">        <span class="keyword">if</span> (differentUser) &#123;</span><br><span class="line">            <span class="comment">// Caching not supported across users</span></span><br><span class="line">            ref = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (includeCode) &#123;</span><br><span class="line">            ref = mPackages.get(aInfo.packageName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ref = mResourcePackages.get(aInfo.packageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LoadedApk packageInfo = ref != <span class="keyword">null</span> ? ref.get() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (packageInfo == <span class="keyword">null</span> || (packageInfo.mResources != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; !packageInfo.mResources.getAssets().isUpToDate())) &#123;</span><br><span class="line">                <span class="comment">// 缓存没有命中，直接new</span></span><br><span class="line">            packageInfo =</span><br><span class="line">                <span class="keyword">new</span> LoadedApk(<span class="keyword">this</span>, aInfo, compatInfo, baseLoader,</span><br><span class="line">                        securityViolation, includeCode &amp;&amp;</span><br><span class="line">                        (aInfo.flags&amp;ApplicationInfo.FLAG_HAS_CODE) != <span class="number">0</span>, registerPackage);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略。。更新缓存</span></span><br><span class="line">        <span class="keyword">return</span> packageInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法很重要，我们必须弄清楚每一步；</p>
<p>首先，它判断了调用方和或许App信息的一方是不是同一个userId；如果是同一个user，那么可以共享缓存数据（要么缓存的代码数据，要么缓存的资源数据）</p>
<p>接下来尝试获取缓存数据；如果没有命中缓存数据，才通过LoadedApk的构造函数创建了LoadedApk对象；创建成功之后，如果是同一个uid还放入了缓存。</p>
<p>提到缓存数据，看过<a href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/">Hook机制之Binder Hook</a>的童鞋可能就知道了，我们之前成功借助ServiceManager的本地代理使用缓存的机制Hook了各种Binder；因此这里完全可以如法炮制——我们拿到这一份缓存数据，修改里面的ClassLoader；自己控制类加载的过程，这样加载插件中的Activity类的问题就解决了。这就引出了我们加载插件类的第一种方案：</p>
<h2 id="激进方案：Hook掉ClassLoader，自己操刀">激进方案：Hook掉ClassLoader，自己操刀</h2><p>从上述分析中我们得知，在获取LoadedApk的过程中使用了一份缓存数据；这个缓存数据是一个<code>Map</code>，从包名到LoadedApk的一个映射。正常情况下，我们的插件肯定不会存在于这个对象里面；但是<strong>如果我们手动把我们插件的信息添加到里面呢？</strong>系统在查找缓存的过程中，会直接命中缓存！进而使用我们添加进去的LoadedApk的ClassLoader来加载这个特定的Activity类！这样我们就能接管我们自己插件类的加载过程了！</p>
<!--但是，细心的读者可能会发现；缓存命中还有一个条件——UID相同，因此我们需要**共享UID**-->
<p>这个缓存对象<code>mPackages</code>存在于ActivityThread类中；老方法，我们首先获取这个对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先获取到当前的ActivityThread对象</span></span><br><span class="line">Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">currentActivityThreadMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取到 mPackages 这个静态成员变量, 这里缓存了dex包的信息</span></span><br><span class="line">Field mPackagesField = activityThreadClass.getDeclaredField(<span class="string">"mPackages"</span>);</span><br><span class="line">mPackagesField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Map mPackages = (Map) mPackagesField.get(currentActivityThread);</span><br></pre></td></tr></table></figure>
<p>拿到这个Map之后接下来怎么办呢？<strong>我们需要填充这个map，把插件的信息塞进这个map里面</strong>，以便系统在查找的时候能命中缓存。但是这个填充这个Map我们出了需要包名之外，还需要一个LoadedApk对象；如何创建一个LoadedApk对象呢？</p>
<p>我们当然可以直接反射调用它的构造函数直接创建出需要的对象，但是万一哪里有疏漏，构造参数填错了怎么办？又或者Android的不同版本使用了不同的参数，导致我们创建出来的对象与系统创建出的对象不一致，无法work怎么办？</p>
<p>因此我们需要使用与系统完全相同的方式创建LoadedApk对象；从上文分析得知，系统创建LoadedApk对象是通过<code>getPackageInfo</code>来完成的，因此我们可以调用这个函数来创建LoadedApk对象；但是这个函数是<code>private</code>的，我们无法使用。</p>
<p>有的童鞋可能会有疑问了，<code>private</code>不是也能反射到吗？我们确实能够调用这个函数，但是<code>private</code>表明这个函数是内部实现，或许那一天Google高兴，把这个函数改个名字我们就直接GG了；但是public函数不同，public被导出的函数你无法保证是否有别人调用它，因此大部分情况下不会修改；我们最好调用public函数来保证尽可能少的遇到兼容性问题。（当然，如果实在木有路可以考虑调用私有方法，自己处理兼容性问题，这个我们以后也会遇到）</p>
<p>间接调用<code>getPackageInfo</code>这个私有函数的public函数有同名的getPackageInfo系列和getPackageInfoNoCheck；简单查看源代码发现，getPackageInfo除了获取包的信息，还检查了包的一些组件；为了绕过这些验证，我们选择使用<code>getPackageInfoNoCheck</code>获取LoadedApk信息。</p>
<h3 id="构建插件LoadedApk对象">构建插件LoadedApk对象</h3><p>我们这一步的目的很明确，通过getPackageInfoNoCheck函数创建出我们需要的LoadedApk对象，以供接下来使用。</p>
<p>这个函数的签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> LoadedApk <span class="title">getPackageInfoNoCheck</span><span class="params">(ApplicationInfo ai,</span><br><span class="line">            CompatibilityInfo compatInfo)</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>因此，为了调用这个函数，我们需要构造两个参数。其一是ApplicationInfo，其二是CompatibilityInfo；第二个参数顾名思义，代表这个App的兼容性信息，比如targetSDK版本等等，这里我们只需要提取出app的信息，因此直接使用默认的兼容性即可；在CompatibilityInfo类里面有一个公有字段DEFAULT_COMPATIBILITY_INFO代表默认兼容性信息；因此，我们的首要目标是获取这个ApplicationInfo信息。</p>
<h3 id="构建插件ApplicationInfo信息">构建插件ApplicationInfo信息</h3><p>我们首先看看ApplicationInfo代表什么，这个类的文档说的很清楚：</p>
<blockquote>
<p>Information you can retrieve about a particular application.  This corresponds to information collected from the AndroidManifest.xml’s &lt;application&gt; tag.</p>
</blockquote>
<p>也就是说，这个类就是AndroidManifest.xml里面的<application> 这个标签下面的信息；这个AndroidManifest.xml无疑是一个标准的xml文件，因此我们完全可以自己使用parse来解析这个信息。</application></p>
<p>那么，系统是如何获取这个信息的呢？其实Framework就有一个这样的parser，也即PackageParser；理论上，我们也可以借用系统的parser来解析AndroidMAnifest.xml从而得到ApplicationInfo的信息。但遗憾的是，<strong>这个类的兼容性很差</strong>；Google几乎在每一个Android版本都对这个类动刀子，如果坚持使用系统的解析方式，必须写一系列兼容行代码！！DroidPlugin就选择了这种方式，相关类如下：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1459829051777.png" width="283" alt="DroidPlugin的PackageParser"></p>
<p>看到这里我就问你怕不怕！！！这也是我们之前提到的<strong>私有或者隐藏的API可以使用，但必须处理好兼容性问题</strong>；如果Android 7.0发布，这里估计得添加一个新的类PackageParseApi24。</p>
<p>我这里使用API 23作为演示，<strong>版本不同的可能无法运行</strong>请自行查阅 DroidPlugin 不同版本如何处理。</p>
<p>OK回到正题，我们决定使用PackageParser类来提取ApplicationInfo信息。下图是API 23上，PackageParser的部分类结构图：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1459829674687.png" width="481"></p>
<p>看起来有我们需要的方法 generateApplication；确实如此，依靠这个方法我们可以成功地拿到ApplicationInfo。<br>由于PackageParser是@hide的，因此我们需要通过反射进行调用。我们根据这个generateApplicationInfo方法的签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationInfo <span class="title">generateApplicationInfo</span><span class="params">(Package p, <span class="keyword">int</span> flags,</span><br><span class="line">   PackageUserState state)</span></span></span><br></pre></td></tr></table></figure>
<p>可以写出调用generateApplicationInfo的反射代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; packageParserClass = Class.forName(<span class="string">"android.content.pm.PackageParser"</span>);</span><br><span class="line"><span class="comment">// 首先拿到我们得终极目标: generateApplicationInfo方法</span></span><br><span class="line"><span class="comment">// API 23 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line"><span class="comment">// public static ApplicationInfo generateApplicationInfo(Package p, int flags,</span></span><br><span class="line"><span class="comment">//    PackageUserState state) &#123;</span></span><br><span class="line"><span class="comment">// 其他Android版本不保证也是如此.</span></span><br><span class="line">Class&lt;?&gt; packageParser$PackageClass = Class.forName(<span class="string">"android.content.pm.PackageParser$Package"</span>);</span><br><span class="line">Class&lt;?&gt; packageUserStateClass = Class.forName(<span class="string">"android.content.pm.PackageUserState"</span>);</span><br><span class="line">Method generateApplicationInfoMethod = packageParserClass.getDeclaredMethod(<span class="string">"generateApplicationInfo"</span>,</span><br><span class="line">        packageParser$PackageClass,</span><br><span class="line">        <span class="keyword">int</span>.class,</span><br><span class="line">                packageUserStateClass);</span><br></pre></td></tr></table></figure>
<p>要成功调用这个方法，还需要三个参数；因此接下来我们需要一步一步构建调用此函数的参数信息。</p>
<h4 id="构建PackageParser-Package">构建PackageParser.Package</h4><p>generateApplicationInfo方法需要的第一个参数是PackageParser.Package；从名字上看这个类代表某个apk包的信息，我们看看文档怎么解释：</p>
<blockquote>
<p>Representation of a full package parsed from APK files on disk. A package consists of a single base APK, and zero or more split APKs.</p>
</blockquote>
<p>果然，这个类代表从PackageParser中解析得到的某个apk包的信息，是磁盘上apk文件在内存中的数据结构表示；因此，要获取这个类，肯定需要解析整个apk文件。PackageParser中解析apk的核心方法是parsePackage，这个方法返回的就是一个Package类型的实例，因此我们调用这个方法即可；使用反射代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先, 我们得创建出一个Package对象出来供这个方法调用</span></span><br><span class="line"><span class="comment">// 而这个需要得对象可以通过 android.content.pm.PackageParser#parsePackage 这个方法返回得 Package对象得字段获取得到</span></span><br><span class="line"><span class="comment">// 创建出一个PackageParser对象供使用</span></span><br><span class="line">Object packageParser = packageParserClass.newInstance();</span><br><span class="line"><span class="comment">// 调用 PackageParser.parsePackage 解析apk的信息</span></span><br><span class="line">Method parsePackageMethod = packageParserClass.getDeclaredMethod(<span class="string">"parsePackage"</span>, File.class, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际上是一个 android.content.pm.PackageParser.Package 对象</span></span><br><span class="line">Object packageObj = parsePackageMethod.invoke(packageParser, apkFile, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>这样，我们就得到了generateApplicationInfo的第一个参数；第二个参数是解析包使用的flag，我们直接选择解析全部信息，也就是0；</p>
<h4 id="构建PackageUserState">构建PackageUserState</h4><p>第三个参数是PackageUserState，代表不同用户中包的信息。由于Android是一个多任务多用户系统，因此不同的用户同一个包可能有不同的状态；这里我们只需要获取包的信息，因此直接使用默认的即可；</p>
<p>至此，generateApplicaionInfo的参数我们已经全部构造完成，直接调用此方法即可得到我们需要的applicationInfo对象；在返回之前我们需要做一点小小的修改：使用系统系统的这个方法解析得到的ApplicationInfo对象中并没有apk文件本身的信息，所以我们把解析的apk文件的路径设置一下（ClassLoader依赖dex文件以及apk的路径）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三个参数 mDefaultPackageUserState 我们直接使用默认构造函数构造一个出来即可</span></span><br><span class="line">Object defaultPackageUserState = packageUserStateClass.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 万事具备!!!!!!!!!!!!!!</span></span><br><span class="line">ApplicationInfo applicationInfo = (ApplicationInfo) generateApplicationInfoMethod.invoke(packageParser,</span><br><span class="line">        packageObj, <span class="number">0</span>, defaultPackageUserState);</span><br><span class="line">String apkPath = apkFile.getPath();</span><br><span class="line">applicationInfo.sourceDir = apkPath;</span><br><span class="line">applicationInfo.publicSourceDir = apkPath;</span><br></pre></td></tr></table></figure>
<h3 id="替换ClassLoader">替换ClassLoader</h3><h4 id="获取LoadedApk信息">获取LoadedApk信息</h4><p>方才为了获取ApplicationInfo我们费了好大一番精力；回顾一下我们的初衷：</p>
<p>我们最终的目的是调用getPackageInfoNoCheck得到LoadedApk的信息，并替换其中的mClassLoader然后把把添加到ActivityThread的mPackages缓存中；从而达到我们使用自己的ClassLoader加载插件中的类的目的。</p>
<p>现在我们已经拿到了getPackageInfoNoCheck这个方法中至关重要的第一个参数applicationInfo；上文提到第二个参数CompatibilityInfo代表设备兼容性信息，直接使用默认的值即可；因此，两个参数都已经构造出来，我们可以调用getPackageInfoNoCheck获取LoadedApk：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.content.res.CompatibilityInfo</span></span><br><span class="line">Class&lt;?&gt; compatibilityInfoClass = Class.forName(<span class="string">"android.content.res.CompatibilityInfo"</span>);</span><br><span class="line">Method getPackageInfoNoCheckMethod = activityThreadClass.getDeclaredMethod(<span class="string">"getPackageInfoNoCheck"</span>, ApplicationInfo.class, compatibilityInfoClass);</span><br><span class="line"></span><br><span class="line">Field defaultCompatibilityInfoField = compatibilityInfoClass.getDeclaredField(<span class="string">"DEFAULT_COMPATIBILITY_INFO"</span>);</span><br><span class="line">defaultCompatibilityInfoField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">Object defaultCompatibilityInfo = defaultCompatibilityInfoField.get(<span class="keyword">null</span>);</span><br><span class="line">ApplicationInfo applicationInfo = generateApplicationInfo(apkFile);</span><br><span class="line"></span><br><span class="line">Object loadedApk = getPackageInfoNoCheckMethod.invoke(currentActivityThread, applicationInfo, defaultCompatibilityInfo);</span><br></pre></td></tr></table></figure>
<p>我们成功地构造出了LoadedAPK, 接下来我们需要替换其中的ClassLoader，然后把它添加进ActivityThread的mPackages中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String odexPath = Utils.getPluginOptDexDir(applicationInfo.packageName).getPath();</span><br><span class="line">String libDir = Utils.getPluginLibDir(applicationInfo.packageName).getPath();</span><br><span class="line">ClassLoader classLoader = <span class="keyword">new</span> CustomClassLoader(apkFile.getPath(), odexPath, libDir, ClassLoader.getSystemClassLoader());</span><br><span class="line">Field mClassLoaderField = loadedApk.getClass().getDeclaredField(<span class="string">"mClassLoader"</span>);</span><br><span class="line">mClassLoaderField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">mClassLoaderField.set(loadedApk, classLoader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于是弱引用, 因此我们必须在某个地方存一份, 不然容易被GC; 那么就前功尽弃了.</span></span><br><span class="line">sLoadedApk.put(applicationInfo.packageName, loadedApk);</span><br><span class="line"></span><br><span class="line">WeakReference weakReference = <span class="keyword">new</span> WeakReference(loadedApk);</span><br><span class="line">mPackages.put(applicationInfo.packageName, weakReference);</span><br></pre></td></tr></table></figure>
<p>我们的这个CustomClassLoader非常简单，直接继承了DexClassLoader，什么都没有做；当然这里可以直接使用DexClassLoader，这里重新创建一个类是为了更有区分度；以后也可以通过修改这个类实现对于类加载的控制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">DexClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, optimizedDirectory, libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，我们已经成功地把把插件的信息放入ActivityThread中，这样我们插件中的类能够成功地被加载；因此插件中的Activity实例能被成功第创建；由于整个流程较为复杂，我们简单梳理一下：</p>
<ol>
<li>在ActivityThread接收到IApplication的 scheduleLaunchActivity远程调用之后，将消息转发给<code>H</code></li>
<li><code>H</code>类在handleMessage的时候，调用了getPackageInfoNoCheck方法来获取待启动的组件信息。在这个方法中会优先查找<code>mPackages</code>中的缓存信息，而我们已经手动把插件信息添加进去；因此能够成功命中缓存，获取到独立存在的插件信息。</li>
<li><code>H</code>类然后调用handleLaunchActivity最终转发到performLaunchActivity方法；这个方法使用从getPackageInfoNoCheck中拿到LoadedApk中的mClassLoader来加载Activity类，进而使用反射创建Activity实例；接着创建Application，Context等完成Activity组件的启动。</li>
</ol>
<p>看起来好像已经天衣无缝万事大吉了；但是运行一下会出现一个异常，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">04</span>-<span class="number">05</span> <span class="number">02</span>:<span class="number">49</span>:<span class="number">53.742</span>  <span class="number">11759</span>-<span class="number">11759</span>/com.weishu.upf.hook_classloader E/AndroidRuntime﹕ FATAL EXCEPTION: main</span><br><span class="line">    Process: com.weishu.upf.hook_classloader, PID: <span class="number">11759</span></span><br><span class="line">    java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.weishu.upf.ams_pms_hook.app/com.weishu.upf.ams_pms_hook.app.MainActivity&#125;: java.lang.RuntimeException: Unable to instantiate application android.app.Application: java.lang.IllegalStateException: Unable to get <span class="keyword">package</span> info <span class="keyword">for</span> com.weishu.upf.ams_pms_hook.app; is <span class="keyword">package</span> not installed?</span><br></pre></td></tr></table></figure>
<p>错误提示说是无法实例化 <code>Application</code>，而Application的创建也是在performLaunchActivity中进行的，这里有些蹊跷，我们仔细查看一下。</p>
<h4 id="绕过系统检查">绕过系统检查</h4><p>通过ActivityThread的performLaunchActivity方法可以得知，Application通过LoadedApk的makeApplication方法创建，我们查看这个方法，在源码中发现了上文异常抛出的位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (!mPackageName.equals(<span class="string">"android"</span>)) &#123;</span><br><span class="line">        initializeJavaContextClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class="keyword">this</span>);</span><br><span class="line">    app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">            cl, appClass, appContext);</span><br><span class="line">    appContext.setOuterContext(app);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mActivityThread.mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Unable to instantiate application "</span> + appClass</span><br><span class="line">            + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>木有办法，我们只有一行一行地查看到底是哪里抛出这个异常的了；所幸代码不多。（所以说，缩小异常范围是一件多么重要的事情！！！）</p>
<p>第一句 getClassLoader() 没什么可疑的，虽然方法很长，但是它木有抛出任何异常（当然，它调用的代码可能抛出异常，万一找不到只能进一步深搜了；所以我觉得这里应该使用受检异常）。</p>
<p>然后我们看第二句，如果包名不是<code>android</code>开头，那么调用了一个叫做initializeJavaContextClassLoader的方法；我们查阅这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeJavaContextClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IPackageManager pm = ActivityThread.getPackageManager();</span><br><span class="line">    android.content.pm.PackageInfo pi;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pi = pm.getPackageInfo(mPackageName, <span class="number">0</span>, UserHandle.myUserId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable to get package info for "</span></span><br><span class="line">                + mPackageName + <span class="string">"; is system dying?"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pi == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable to get package info for "</span></span><br><span class="line">                + mPackageName + <span class="string">"; is package not installed?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> sharedUserIdSet = (pi.sharedUserId != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">boolean</span> processNameNotDefault =</span><br><span class="line">        (pi.applicationInfo != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">         !mPackageName.equals(pi.applicationInfo.processName));</span><br><span class="line">    <span class="keyword">boolean</span> sharable = (sharedUserIdSet || processNameNotDefault);</span><br><span class="line">    ClassLoader contextClassLoader =</span><br><span class="line">        (sharable)</span><br><span class="line">        ? <span class="keyword">new</span> WarningContextClassLoader()</span><br><span class="line">        : mClassLoader;</span><br><span class="line">    Thread.currentThread().setContextClassLoader(contextClassLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们找出了这个异常的来源：原来这里调用了<code>getPackageInfo</code>方法获取包的信息；而我们的插件<strong>并没有安装在系统上</strong>，因此系统肯定认为插件没有安装，这个方法肯定返回null。所以，我们还要欺骗一下PMS，让系统觉得<strong>插件已经安装在系统上了</strong>；至于如何欺骗 PMS，<a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/">Hook机制之AMS&amp;PMS</a> 有详细解释，这里直接给出代码，不赘述了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hookPackageManager</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这一步是因为 initializeJavaContextClassLoader 这个方法内部无意中检查了这个包是否在系统安装</span></span><br><span class="line">    <span class="comment">// 如果没有安装, 直接抛出异常, 这里需要临时Hook掉 PMS, 绕过这个检查.</span></span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">    Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">    currentActivityThreadMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取ActivityThread里面原始的 sPackageManager</span></span><br><span class="line">    Field sPackageManagerField = activityThreadClass.getDeclaredField(<span class="string">"sPackageManager"</span>);</span><br><span class="line">    sPackageManagerField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object sPackageManager = sPackageManagerField.get(currentActivityThread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备好代理对象, 用来替换原始的对象</span></span><br><span class="line">    Class&lt;?&gt; iPackageManagerInterface = Class.forName(<span class="string">"android.content.pm.IPackageManager"</span>);</span><br><span class="line">    Object proxy = Proxy.newProxyInstance(iPackageManagerInterface.getClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> Class&lt;?&gt;[] &#123; iPackageManagerInterface &#125;,</span><br><span class="line">            <span class="keyword">new</span> IPackageManagerHookHandler(sPackageManager));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 替换掉ActivityThread里面的 sPackageManager 字段</span></span><br><span class="line">    sPackageManagerField.set(currentActivityThread, proxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK到这里，我们已经能够成功地加载<strong>简单的</strong>独立的存在于外部文件系统中的apk了。至此 关于 DroidPlugin 对于Activity生命周期的管理已经完全讲解完毕了；这是一种极其复杂的Activity管理方案，我们仅仅写一个用来理解的demo就Hook了相当多的东西，在Framework层来回牵扯；这其中的来龙去脉要完全把握清楚还请读者亲自翻阅源码。另外，我在此 对DroidPlugin 作者献上我的膝盖～这其中的玄妙让人叹为观止！</p>
<p>上文给出的方案中，我们全盘接管了插件中类的加载过程，这是一种相对暴力的解决方案；能不能更温柔一点呢？通俗来说，我们可以选择改革，而不是革命——告诉系统ClassLoader一些必要信息，让它帮忙完成插件类的加载。</p>
<h2 id="保守方案：委托系统，让系统帮忙加载">保守方案：委托系统，让系统帮忙加载</h2><p>我们再次搬出ActivityThread中加载Activity类的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">activity = mInstrumentation.newActivity(</span><br><span class="line">        cl, component.getClassName(), r.intent);</span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure>
<p>我们知道 这个r.packageInfo中的<code>r</code>是通过getPackageInfoNoCheck获取到的；在『激进方案』中我们把插件apk手动添加进缓存，采用自己加载办法解决；如果我们不干预这个过程，导致无法命中mPackages中的缓存，会发生什么？</p>
<p>查阅 getPackageInfo方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LoadedApk <span class="title">getPackageInfo</span><span class="params">(ApplicationInfo aInfo, CompatibilityInfo compatInfo,</span><br><span class="line">        ClassLoader baseLoader, <span class="keyword">boolean</span> securityViolation, <span class="keyword">boolean</span> includeCode,</span><br><span class="line">        <span class="keyword">boolean</span> registerPackage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> differentUser = (UserHandle.myUserId() != UserHandle.getUserId(aInfo.uid));</span><br><span class="line">    <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">        WeakReference&lt;LoadedApk&gt; ref;</span><br><span class="line">        <span class="keyword">if</span> (differentUser) &#123;</span><br><span class="line">            <span class="comment">// Caching not supported across users</span></span><br><span class="line">            ref = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (includeCode) &#123;</span><br><span class="line">            ref = mPackages.get(aInfo.packageName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ref = mResourcePackages.get(aInfo.packageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LoadedApk packageInfo = ref != <span class="keyword">null</span> ? ref.get() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (packageInfo == <span class="keyword">null</span> || (packageInfo.mResources != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; !packageInfo.mResources.getAssets().isUpToDate())) &#123;</span><br><span class="line">            packageInfo =</span><br><span class="line">                <span class="keyword">new</span> LoadedApk(<span class="keyword">this</span>, aInfo, compatInfo, baseLoader,</span><br><span class="line">                        securityViolation, includeCode &amp;&amp;</span><br><span class="line">                        (aInfo.flags&amp;ApplicationInfo.FLAG_HAS_CODE) != <span class="number">0</span>, registerPackage);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，没有命中缓存的情况下，系统直接new了一个LoadedApk；注意这个构造函数的第二个参数<code>aInfo</code>，这是一个ApplicationInfo类型的对象。在『激进方案』中我们为了获取独立插件的ApplicationInfo花了不少心思；那么如果不做任何处理这里传入的这个<code>aInfo</code>参数是什么？</p>
<p>追本溯源不难发现，这个aInfo是从我们的替身StubActivity中获取的！而StubActivity存在于宿主程序中，所以，这个<code>aInfo</code>对象代表的实际上就是宿主程序的Application信息！</p>
<p>我们知道，接下来会使用new出来的这个LoadedApk的getClassLoader()方法获取到ClassLoader来对插件的类进行加载；而获取到的这个ClassLoader是宿主程序使用的ClassLoader，因此现在还无法加载插件的类；那么，<strong>我们能不能让宿主的ClasLoader获得加载插件类的能力呢？</strong>；如果我们告诉宿主使用的ClassLoader插件使用的类在哪里，就能帮助他完成加载！</p>
<h3 id="宿主的ClassLoader在哪里，是唯一的吗？">宿主的ClassLoader在哪里，是唯一的吗？</h3><p>上面说到，我们可以通过告诉宿主程序的ClassLoader插件使用的类，让宿主的ClasLoader完成对于插件类的加载；那么问题来了，我们如何获取到宿主的ClassLoader？宿主程序使用的ClasLoader默认情况下是全局唯一的吗？</p>
<p>答案是肯定的。</p>
<p>因为在FrameWork中宿主程序也是使用LoadedApk表示的，如同Activity启动是加载Activity类一样，宿主中的类也都是通过LoadedApk的getClassLoader()方法得到的ClassLoader加载的；由类加载机制的『双亲委派』特性，只要有一个应用程序类由某一个ClassLoader加载，那么它引用到的别的类除非父加载器能加载，否则都是由这同一个加载器加载的（不遵循双亲委派模型的除外）。</p>
<p>表示宿主的LoadedApk在Application类中有一个成员变量<code>mLoadedApk</code>，而这个变量是从ContextImpl中获取的；ContextImpl重写了getClassLoader方法，因此<strong>我们在Context环境中直接getClassLoader()获取到的就是宿主程序唯一的ClassLoader</strong>。</p>
<h3 id="LoadedApk的ClassLoader到底是什么？">LoadedApk的ClassLoader到底是什么？</h3><p>现在我们确保了『使用宿主ClassLoader帮助加载插件类』可行性；那么我们应该如何完成这个过程呢？</p>
<p>知己知彼，百战不殆。</p>
<p>不论是宿主程序还是插件程序都是通过LoadedApk的getClassLoader()方法返回的ClassLoader进行类加载的，返回的这个ClassLoader到底是个什么东西？？这个方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mClassLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mClassLoader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mIncludeCode &amp;&amp; !mPackageName.equals(<span class="string">"android"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 略...</span></span><br><span class="line">            mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip, lib,</span><br><span class="line">                    mBaseClassLoader);</span><br><span class="line"></span><br><span class="line">            StrictMode.setThreadPolicy(oldPolicy);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mBaseClassLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mClassLoader = mBaseClassLoader;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，非<code>android</code>开头的包和<code>android</code>开头的包分别使用了两种不同的ClassLoader，我们只关心第一种；因此继续跟踪ApplicationLoaders类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">(String zip, String libPath, ClassLoader parent)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLoaders) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent = baseParent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent == baseParent) &#123;</span><br><span class="line">            ClassLoader loader = mLoaders.get(zip);</span><br><span class="line">            <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> loader;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);</span><br><span class="line">            PathClassLoader pathClassloader =</span><br><span class="line">                <span class="keyword">new</span> PathClassLoader(zip, libPath, parent);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">            mLoaders.put(zip, pathClassloader);</span><br><span class="line">            <span class="keyword">return</span> pathClassloader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);</span><br><span class="line">        PathClassLoader pathClassloader = <span class="keyword">new</span> PathClassLoader(zip, parent);</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        <span class="keyword">return</span> pathClassloader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，应用程序使用的ClassLoader都是PathClassLoader类的实例。那么，这个PathClassLoader是什么呢？从Android SDK给出的源码只能看出这么多：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SDK没有导出这个类的源码，我们去<a href="http://androidxref.com/6.0.1_r10/xref/libcore/dalvik/src/main/java/dalvik/system/PathClassLoader.java" target="_blank" rel="external">androidxref</a>上面看；发现其实这个类真的就这么多内容；我们继续查看它的父类<a href="http://androidxref.com/6.0.1_r10/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java" target="_blank" rel="external">BaseDexClassLoader</a>；ClassLoader嘛，我们查看findClass或者defineClass方法，BaseDexClassLoader的findClass方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">    Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"Didn't find class \""</span> + name + <span class="string">"\" on path: "</span> + pathList);</span><br><span class="line">        <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">            cnfe.addSuppressed(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> cnfe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，查找Class的任务通过<code>pathList</code>完成；这个<code>pathList</code>是一个<code>DexPathList</code>类的对象，它的<code>findClass</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">       DexFile dex = element.dexFile;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</span><br><span class="line">           <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> clazz;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">       suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个DexPathList内部有一个叫做dexElements的数组，然后findClass的时候会遍历这个数组来查找Class；<strong>如果我们把插件的信息塞进这个数组里面，那么不就能够完成类的加载过程吗？！！</strong></p>
<h3 id="给默认ClassLoader打补丁">给默认ClassLoader打补丁</h3><p>通过上述分析，我们知道，可以把插件的相关信息放入BaseDexClassLoader的表示dex文件的数组里面，这样宿主程序的ClassLoader在进行类加载，遍历这个数组的时候，会自动遍历到我们添加进去的插件信息，从而完成插件类的加载！</p>
<p>接下来，我们实现这个过程；我们会用到一些较为复杂的反射技术哦～不过代码非常短：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">patchClassLoader</span><span class="params">(ClassLoader cl, File apkFile, File optDexFile)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException, NoSuchMethodException, IOException, InvocationTargetException, InstantiationException, NoSuchFieldException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 BaseDexClassLoader : pathList</span></span><br><span class="line">    Field pathListField = DexClassLoader.class.getSuperclass().getDeclaredField(<span class="string">"pathList"</span>);</span><br><span class="line">    pathListField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object pathListObj = pathListField.get(cl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 PathList: Element[] dexElements</span></span><br><span class="line">    Field dexElementArray = pathListObj.getClass().getDeclaredField(<span class="string">"dexElements"</span>);</span><br><span class="line">    dexElementArray.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object[] dexElements = (Object[]) dexElementArray.get(pathListObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Element 类型</span></span><br><span class="line">    Class&lt;?&gt; elementClass = dexElements.getClass().getComponentType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个数组, 用来替换原始的数组</span></span><br><span class="line">    Object[] newElements = (Object[]) Array.newInstance(elementClass, dexElements.length + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造插件Element(File file, boolean isDirectory, File zip, DexFile dexFile) 这个构造函数</span></span><br><span class="line">    Constructor&lt;?&gt; constructor = elementClass.getConstructor(File.class, <span class="keyword">boolean</span>.class, File.class, DexFile.class);</span><br><span class="line">    Object o = constructor.newInstance(apkFile, <span class="keyword">false</span>, apkFile, DexFile.loadDex(apkFile.getCanonicalPath(), optDexFile.getAbsolutePath(), <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    Object[] toAddElementArray = <span class="keyword">new</span> Object[] &#123; o &#125;;</span><br><span class="line">    <span class="comment">// 把原始的elements复制进去</span></span><br><span class="line">    System.arraycopy(dexElements, <span class="number">0</span>, newElements, <span class="number">0</span>, dexElements.length);</span><br><span class="line">    <span class="comment">// 插件的那个element复制进去</span></span><br><span class="line">    System.arraycopy(toAddElementArray, <span class="number">0</span>, newElements, dexElements.length, toAddElementArray.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换</span></span><br><span class="line">    dexElementArray.set(pathListObj, newElements);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>短短的二十几行代码，我们就完成了『委托宿主ClassLoader加载插件类』的任务；因此第二种方案也宣告完成！我们简要总结一下这种方式的原理：</p>
<ol>
<li>默认情况下performLacunchActivity会使用替身StubActivity的ApplicationInfo也就是宿主程序的CLassLoader加载所有的类；我们的思路是告诉宿主ClassLoader我们在哪，让其帮助完成类加载的过程。</li>
<li>宿主程序的ClassLoader最终继承自BaseDexClassLoader，BaseDexClassLoader通过DexPathList进行类的查找过程；而这个查找通过遍历一个dexElements的数组完成；<strong>我们通过把插件dex添加进这个数组</strong>就让宿主ClasLoader获取了加载插件类的能力。</li>
</ol>
<h2 id="小结">小结</h2><p>本文中我们采用两种方案成功完成了『启动没有在AndroidManifest.xml中显示声明，并且存在于外部插件中的Activity』的任务。</p>
<p>『激进方案』中我们自定义了插件的ClassLoader，并且绕开了Framework的检测；利用ActivityThread对于LoadedApk的缓存机制，我们把携带这个自定义的ClassLoader的插件信息添加进<code>mPackages</code>中，进而完成了类的加载过程。</p>
<p>『保守方案』中我们深入探究了系统使用ClassLoader findClass的过程，发现应用程序使用的非系统类都是通过同一个PathClassLoader加载的；而这个类的最终父类BaseDexClassLoader通过DexPathList完成类的查找过程；我们hack了这个查找过程，从而完成了插件类的加载。</p>
<p>这两种方案孰优孰劣呢？</p>
<p>很显然，『激进方案』比较麻烦，从代码量和分析过程就可以看出来，这种机制异常复杂；而且在解析apk的时候我们使用的PackageParser的兼容性非常差，我们不得不手动处理每一个版本的apk解析api；另外，它Hook的地方也有点多：不仅需要Hook AMS和<code>H</code>，还需要Hook ActivityThread的<code>mPackages</code>和PackageManager！</p>
<p>『保守方案』则简单得多（虽然原理也不简单），不仅代码很少，而且Hook的地方也不多；有一点正本清源的意思，从最最上层Hook住了整个类的加载过程。</p>
<p>但是，我们不能简单地说『保守方案』比『激进方案』好。从根本上说，这两种方案的差异在哪呢？</p>
<p>『激进方案』是<strong>多ClassLoader构架</strong>，每一个插件都有一个自己的ClassLoader，因此类的隔离性非常好——如果不同的插件使用了同一个库的不同版本，它们相安无事！『保守方案』是<strong>单ClassLoader方案</strong>，插件和宿主程序的类全部都通过宿主的ClasLoader加载，虽然代码简单，但是鲁棒性很差；一旦插件之间甚至插件与宿主之间使用的类库有冲突，那么直接GG。</p>
<p>多ClassLoader还有一个优点：可以真正完成代码的热加载！如果插件需要升级，直接重新创建一个自定的ClassLoader加载新的插件，然后替换掉原来的版本即可（Java中，不同ClassLoader加载的同一个类被认为是不同的类）；单ClassLoader的话实现非常麻烦，有可能需要重启进程。</p>
<p>在J2EE领域中广泛使用ClasLoader的地方均采用多ClassLoader架构，比如Tomcat服务器，Java模块化事实标准的OSGi技术；所以，我们有足够的理由认为<strong>选择多ClassLoader架构在大多数情况下是明智之举</strong>。</p>
<p>目前开源的插件方案中，DroidPlugin采用的『激进方案』，Small采用的『保守方案』那么，有没有两种优点兼顾的方案呢？？</p>
<p>答案自然是有的。</p>
<p>DroidPlugin和Small的共同点是<strong>两者都是非侵入式的插件框架</strong>；什么是『非侵入式』呢？打个比方，你启动一个插件Activity，直接使用<code>startActivity</code>即可，就跟开发普通的apk一样，开发插件和普通的程序对于开发者来说没有什么区别。</p>
<p>如果我们一定程度上放弃这种『侵入性』，那么我们就能实现一个两者优点兼而有之的插件框架！这里我先卖个关子～</p>
<p>OK，本文的内容就到这里了；关于『插件机制对于Activity的处理方式』也就此完结。要说明的是，在本文的『保守方案』其实只处理了代码的加载过程，它并不能加载有资源的apk！所以目前我这个实现基本没什么暖用；当然我这里只是就『代码加载』进行举例；至于资源，那牵扯到另外一个问题——<strong>插件系统的资源管理机制</strong>这个在后续文章的合适机会我会单独讲解。</p>
<p>接下来的文章，会讲述Android四大组件的另外三个<code>Service</code>，<code>BroadCastReceiver</code>, <code>ContentProvider</code>的处理方式。喜欢就点个赞吧～持续更新，请关注github项目 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>和我的 <a href="http://weishu.me">博客</a>! 这文章我前前后后准备了快两个星期，如果你看到了这里，还请支持一下 :) </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上文 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/">Activity生命周期管理</a> 中我们地完成了『启动没有在AndroidManifest.xml中显式声明的Activity』的任务；通过Hook <code>AMS</code>和拦截ActivityThread中<code>H</code>类对于组件调度我们成功地绕过了AndroidMAnifest.xml的限制。</p>
<p>但是我们启动的『没有在AndroidManifet.xml中显式声明』的Activity和宿主程序存在于同一个Apk中；通常情况下，插件均以独立的文件存在甚至通过网络获取，这时候插件中的Activity能否成功启动呢？</p>
<p>要启动Activity组件肯定先要创建对应的Activity类的对象，从上文 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/">Activity生命周期管理</a> 知道，创建Activity类对象的过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">activity = mInstrumentation.newActivity(</span><br><span class="line">        cl, component.getClassName(), r.intent);</span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure>
<p>也就是说，系统通过<code>ClassLoader</code>加载了需要的Activity类并通过反射调用构造函数创建出了Activity对象。如果Activity组件存在于独立于宿主程序的文件之中，系统的ClassLoader怎么知道去哪里加载呢？因此，如果不做额外的处理，插件中的Activity对象甚至都没有办法创建出来，谈何启动？</p>
<p>因此，要使存在于独立文件或者网络中的插件被成功启动，首先就需要解决这个<strong>插件类加载</strong>的问题。<br>下文将围绕此问题展开，完成『启动没有在AndroidManifest.xml中显示声明，并且存在于外部插件中的Activity』的任务。</p>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework">understand-plugin-framework</a>，参考此项目的<code>classloader-hook</code> 模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">索引</a>。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="binder" scheme="http://weishu.me/tags/binder/"/>
    
      <category term="classloader" scheme="http://weishu.me/tags/classloader/"/>
    
      <category term="droidplugin" scheme="http://weishu.me/tags/droidplugin/"/>
    
      <category term="plugin framework" scheme="http://weishu.me/tags/plugin-framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 插件化原理解析——Activity生命周期管理]]></title>
    <link href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/"/>
    <id>http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/</id>
    <published>2016-03-21T11:43:32.000Z</published>
    <updated>2019-01-30T04:06:02.851Z</updated>
    <content type="html"><![CDATA[<p>之前的 <a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">Android插件化原理解析</a> 系列文章揭开了Hook机制的神秘面纱，现在我们手握倚天屠龙，那么如何通过这种技术完成插件化方案呢？具体来说，插件中的Activity，Service等组件如何在Android系统上运行起来？</p>
<p>在Java平台要做到动态运行模块、热插拔可以使用<code>ClassLoader</code>技术进行动态类加载，比如广泛使用的<code>OSGi</code>技术。在Android上当然也可以使用动态加载技术，但是仅仅把类加载进来就足够了吗？<code>Activity</code>，<code>Service</code>等组件是有生命周期的，它们统一由系统服务<code>AMS</code>管理；使用<code>ClassLoader</code>可以从插件中创建Activity对象，但是，一个没有生命周期的Activity对象有什么用？所以在Android系统上，仅仅完成动态类加载是不够的；我们需要想办法把我们加载进来的Activity等组件交给系统管理，让<code>AMS</code>赋予组件生命周期；这样才算是一个有血有肉的完善的插件化方案。</p>
<p>接下来的系列文章会讲述 DroidPlugin对于Android四大组件的处理方式，我们且看它如何采用Hook技术坑蒙拐骗把系统玩弄于股掌之中，最终赋予Activity，Service等组件生命周期，完成借尸还魂的。</p>
<a id="more"></a>
<p>首先，我们来看看DroidPlugin对于<code>Activity</code>组件的处理方式。</p>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>，参考此项目的intercept-activity模块。另外，如果对于Hook技术不甚了解，请先查阅我之前的文章：</p>
<ol>
<li><a href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/">Hook机制之动态代理</a></li>
<li><a href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/">Hook机制之Binder Hook</a></li>
<li><a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/">Hook机制之AMS&amp;PMS</a></li>
</ol>
<h2 id="AndroidManifest-xml的限制">AndroidManifest.xml的限制</h2><p>读到这里，或许有部分读者觉得疑惑了，启动Activity不就是一个<code>startActivity</code>的事吗，有这么神秘兮兮的？</p>
<p>启动Activity确实非常简单，但是Android却有一个限制：<strong>必须在AndroidManifest.xml中显示声明使用的Activity</strong>；我相信读者肯定会遇到下面这种异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">03</span>-<span class="number">18</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">56.074</span>  <span class="number">20709</span>-<span class="number">20709</span>/com.weishu.intercept_activity.app E/AndroidRuntime﹕ FATAL EXCEPTION: main</span><br><span class="line">    Process: com.weishu.intercept_activity.app, PID: <span class="number">20709</span></span><br><span class="line">    android.content.ActivityNotFoundException: Unable to find explicit activity <span class="class"><span class="keyword">class</span> </span>&#123;com.weishu.intercept_activity.app/com.weishu.intercept_activity.app.TargetActivity&#125;; have you declared <span class="keyword">this</span> activity in your AndroidManifest.xml?</span><br></pre></td></tr></table></figure>
<p>『必须在AndroidManifest.xml中显示声明使用的Activity』这个硬性要求很大程度上限制了插件系统的发挥：假设我们需要启动一个插件的Activity，插件使用的Activity是无法预知的，这样肯定也不会在Manifest文件中声明；如果插件新添加一个Activity，主程序的AndroidManifest.xml就需要更新；既然双方都需要修改升级，何必要使用插件呢？这已经违背了动态加载的初衷：不修改插件框架而动态扩展功能。</p>
<p>能不能想办法绕过这个限制呢？</p>
<p>束手无策啊，怎么办？借刀杀人偷梁换柱无中生有以逸待劳乘火打劫瞒天过海…等等！偷梁换柱瞒天过海？貌似可以一试。</p>
<p>我们可以耍个障眼法：既然AndroidManifest文件中必须声明，那么我就声明一个（或者有限个）替身Activity好了，当需要启动插件的某个Activity的时候，先让系统以为启动的是AndroidManifest中声明的那个替身，暂时骗过系统；然后到合适的时候又替换回我们需要启动的真正的Activity；所谓瞒天过海，莫过如此！</p>
<p>现在有了方案了，但是该如何做呢？兵书又说，知己知彼百战不殆！如果连Activity的启动过程都不熟悉，怎么完成这个瞒天过海的过程？</p>
<h2 id="Activity启动过程">Activity启动过程</h2><p>启动Activity非常简单，一个<code>startActivity</code>就完事了；那么在这个简单调用的背后发生了什么呢？Look the fucking source code！</p>
<p>关于Activity 的启动过程，也不是三言两语能解释清楚的，如果按照源码一步一步走下来，插件化系列文章就不用写了；所以这里我就给出一个大致流程，只列出关键的调用点（以Android 6.0源码为例）；如果读者希望更详细的讲解，可以参考老罗的 <a href="http://blog.csdn.net/luoshengyang/article/details/6685853" target="_blank" rel="external"> Android应用程序的Activity启动过程简要介绍和学习计划</a></p>
<p>首先是Activity类的<code>startActivity</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    startActivity(intent, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟着这个方法一步一步跟踪，会发现它最后在<code>startActivityForResult</code>里面调用了Instrument对象的<code>execStartActivity</code>方法；接着在这个函数里面调用了ActivityManagerNative类的<code>startActivity</code>方法；这个过程在前文已经反复举例讲解了，我们知道接下来会通过Binder IPC到<code>AMS</code>所在进程调用<code>AMS</code>的<code>startActivity</code>方法；Android系统的组件生命周期管理就是在<code>AMS</code>里面完成的，那么在<code>AMS</code>里面到底做了什么呢？</p>
<p>ActivityManagerService的<code>startActivity</code>方法如下：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="built_in">int</span> startActivity(IApplicationThread caller, <span class="keyword">String</span> callingPackage,</span><br><span class="line">        Intent intent, <span class="keyword">String</span> resolvedType, IBinder resultTo,</span><br><span class="line">        <span class="keyword">String</span> resultWho, <span class="built_in">int</span> requestCode, <span class="built_in">int</span> startFlags,</span><br><span class="line">        <span class="keyword">String</span> profileFile, ParcelFileDescriptor profileFd, Bundle options) &#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode,</span><br><span class="line">            startFlags, profileFile, profileFd, options, UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，直接调用了<code>startActivityAsUser</code>这个方法；接着是<code>ActivityStackSupervisor</code>类的<code>startActivityMayWait</code>方法。这个ActivityStackSupervisor类到底是个啥？如果仔细查阅，低版本的Android源码上是没有这个类的；后来AMS的代码进行了部分重构，关于Activity栈管理的部分单独提取出来成为了<code>ActivityStackSupervisor</code>类；好了，继续看代码。</p>
<p>startActivityMayWait这个方法前面对参数进行了一系列处理，我们需要知道的是，在这个方法内部对传进来的Intent进行了解析，并尝试从中取出关于启动Activity的信息。</p>
<p>然后这个方法调用了startActivityLocked方法；在startActivityLocked方法内部进行了一系列重要的检查：比如权限检查，Activity的exported属性检查等等；我们上文所述的，启动没有在Manifestfest中显示声明的Activity抛异常也是这里发生的：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">err</span> == ActivityManager.START_SUCCESS &amp;&amp; aInfo == null) &#123;</span><br><span class="line">    <span class="comment">// We couldn't find the specific class specified in the Intent.</span></span><br><span class="line">    <span class="comment">// Also the end of the line.</span></span><br><span class="line">    <span class="keyword">err</span> = ActivityManager.START_CLASS_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里返回ActivityManager.START_CLASS_NOT_FOUND之后，在Instrument的execStartActivity返回之后会检查这个值，然后跑出异常：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ActivityManager.START_CLASS_NOT_FOUND:</span><br><span class="line">    <span class="keyword">if</span> (intent <span class="keyword">instanceof</span> Intent &amp;&amp; ((Intent)intent).getComponent() != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ActivityNotFoundException(</span><br><span class="line">                <span class="string">"Unable to find explicit activity class "</span></span><br><span class="line">                + ((Intent)intent).getComponent().toShortString()</span><br><span class="line">                + <span class="string">"; have you declared this activity in your AndroidManifest.xml?"</span>);</span><br></pre></td></tr></table></figure>
<p>源码看到这里，我们已经确认了『必须在AndroidManifest.xml中显示声明使用的Activity』的原因；然而这个校检过程发生在<code>AMS</code>所在的进程<code>system_server</code>，我们没有办法篡改，只能另寻他路。</p>
<p>OK，我们继续跟踪源码；在startActivityLocked之后处理的都是Activity任务栈相关内容，这一系列ActivityStack和ActivityStackSupervisor纠缠不清的调用看下图就明白了；不明白也没关系: D 目前用处不大。</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1458296458099.png" alt="调用流程图"></p>
<p>这一系列调用最终到达了ActivityStackSupervisor的realStartActivityLocked方法；人如其名，这个方法开始了真正的“启动Activity”：它调用了ApplicationThread的scheduleLaunchActivity方法，开始了真正的Activity对象创建以及启动过程。</p>
<p>这个ApplicationThread是什么，是一个线程吗？与ActivityThread有什么区别和联系？</p>
<p>不要被名字迷惑了，这个ApplicationThread实际上是一个Binder对象，是App所在的进程与AMS所在进程system_server通信的桥梁；在Activity启动的过程中，App进程会频繁地与AMS进程进行通信：</p>
<ol>
<li>App进程会委托AMS进程完成Activity生命周期的管理以及任务栈的管理；这个通信过程AMS是Server端，App进程通过持有AMS的client代理ActivityManagerNative完成通信过程；</li>
<li>AMS进程完成生命周期管理以及任务栈管理后，会把控制权交给App进程，让App进程完成Activity类对象的创建，以及生命周期回调；这个通信过程也是通过Binder完成的，App所在server端的Binder对象存在于ActivityThread的内部类ApplicationThread；AMS所在client通过持有IApplicationThread的代理对象完成对于App进程的通信。</li>
</ol>
<p>App进程与AMS进程的通信过程如图所示：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1458300329231.png" width="500"></p>
<p>App进程内部的ApplicationThread server端内部有自己的Binder线程池，它与App主线程的通信通过Handler完成，这个Handler存在于ActivityThread类，它的名字很简单就叫<code>H</code>，这一点我们接下来就会讲到。</p>
<p>现在我们明白了这个ApplicationThread到底是个什么东西，接上文继续跟踪Activity的启动过程；我们查看ApplicationThread的<code>scheduleLaunchActivity</code>方法，这个方法很简单，就是包装了参数最终使用Handler发了一个消息。</p>
<p>正如刚刚所说，ApplicationThread所在的Binder服务端使用Handler与主线程进行通信，这里的scheduleLaunchActivity方法直接把启动Activity的任务通过一个消息转发给了主线程；我们查看Handler类对于这个消息的处理：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart")<span class="comment">;</span></span><br><span class="line">ActivityClientRecord r = (ActivityClientRecord)msg.obj<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">        r.activityInfo.applicationInfo, r.compatInfo)<span class="comment">;</span></span><br><span class="line">handleLaunchActivity(r, null)<span class="comment">;</span></span><br><span class="line">Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里直接调用了ActivityThread的handleLaunchActivity方法，在这个方法内部有一句非常重要：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Activity a = performLaunchActivity<span class="list">(<span class="keyword">r</span>, customIntent)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>绕了这么多弯，我们的Activity终于被创建出来了！继续跟踪这个performLaunchActivity方法看看发生了什么；由于这个方法较长，我就不贴代码了，读者可以自行查阅；要指出的是，这个方法做了两件很重要的事情：</p>
<ol>
<li>使用ClassLoader加载并通过反射创建Activity对象</li>
</ol>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl = r.packageInfo.getClassLoader()<span class="comment">;</span></span><br><span class="line">activity = mInstrumentation.newActivity(</span><br><span class="line">        cl, component.getClassName(), r.intent)<span class="comment">;</span></span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass())<span class="comment">;</span></span><br><span class="line">r.intent.setExtrasClassLoader(cl)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>如果Application还没有创建，那么创建Application对象并回调相应的生命周期方法；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"><span class="comment">// ... 省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Activity的启动过程到这里就结束了，可能读者还是觉得迷惑：不就是调用了一系列方法吗？具体做了什么还是不太清楚，而且为什么Android要这么设计？</p>
<p>方法调用链再长也木有关系，有两点需要明白：</p>
<ol>
<li>平时我们所说的Application被创建了，onCreate方法被调用了，我们或许并没有意识到我们所说的<code>Application, Activity</code>除了代表Android应用层通常所代表的“组件”之外，它们其实都是普通的Java对象，也是需要被构造函数构造出来的对象的；在这个过程中，我们明白了这些对象到底是如何被创建的。</li>
<li>为什么需要一直与AMS进行通信？哪些操作是在AMS中进行的？其实<code>AMS</code>正如名字所说，管理所有的“活动”，整个系统的Activity堆栈，Activity生命周期回调都是由AMS所在的系统进程system_server帮开发者完成的；Android的Framework层帮忙完成了诸如生命周期管理等繁琐复杂的过程，简化了应用层的开发。</li>
</ol>
<h2 id="瞒天过海——启动不在AndroidManifest-xml中声明的Activity">瞒天过海——启动不在AndroidManifest.xml中声明的Activity</h2><h3 id="简要分析">简要分析</h3><p>通过上文的分析，我们已经对Activity的启动过程了如指掌了；就让我们干点坏事吧 :D</p>
<p>对与『必须在AndroidManifest.xml中显示声明使用的Activity』这个问题，上文给出了思路——瞒天过海；我们可以在AndroidManifest.xml里面声明一个替身Activity，然后<strong>在合适的时候</strong>把这个假的替换成我们真正需要启动的Activity就OK了。</p>
<p>那么问题来了，『合适的时候』到底是什么时候？在前文<a href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/">Hook机制之动态代理</a>中我们提到过Hook过程最重要的一步是<strong>寻找Hook点</strong>；如果是在同一个进程，<code>startActivity</code>到Activity真正启动起来这么长的调用链，我们随便找个地方Hook掉就完事儿了；但是问题木有这么简单。</p>
<p>Activity启动过程中很多重要的操作（正如上文分析的『必须在AndroidManifest.xml中显式声明要启动的Activity』)都不是在App进程里面执行的，而是在AMS所在的系统进程system_server完成，由于<strong>进程隔离</strong>的存在，我们对别的进程无能为力；所以这个Hook点就需要花点心思了。</p>
<p>这时候Activity启动过程的知识就派上用场了；虽然整个启动过程非常复杂，但其实一张图就能总结：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1458532084072.png" alt="简要启动过程"></p>
<p>先从App进程调用<code>startActivity</code>；然后通过IPC调用进入系统进程system_server，完成Activity管理以及一些校检工作，最后又回到了APP进程完成真正的Activioty对象创建。</p>
<p>由于这个检验过程是在AMS进程完成的，我们对system_server进程里面的操作无能为力，只有在我们APP进程里面执行的过程才是有可能被Hook掉的，也就是第一步和第三步；具体应该怎么办呢？</p>
<p>既然需要一个显式声明的Activity，那就声明一个！<strong>可以在第一步假装启动一个已经在AndroidManifest.xml里面声明过的替身Activity，让这个Activity进入AMS进程接受检验；最后在第三步的时候换成我们真正需要启动的Activity</strong>；这样就成功欺骗了AMS进程，瞒天过海！</p>
<p>说到这里，是不是有点小激动呢？我们写个demo验证一下：『启动一个并没有在AndroidManifest.xml中显示声明的Activity』</p>
<h3 id="实战过程">实战过程</h3><p>具体来说，我们打算实现如下功能：在MainActivity中启动一个并没有在AndroidManifest.xml中声明的TargetActivity；按照上文分析，我们需要声明一个替身Activity，我们叫它StubActivity；</p>
<p>那么，我们的AndroidManifest.xml如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">manifest</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">          <span class="attribute">package</span>=<span class="value">"com.weishu.intercept_activity.app"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">application</span></span><br><span class="line">            <span class="attribute">android:allowBackup</span>=<span class="value">"true"</span></span><br><span class="line">            <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span></span><br><span class="line">            <span class="attribute">android:icon</span>=<span class="value">"@mipmap/ic_launcher"</span></span><br><span class="line">            &gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".MainActivity"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 替身Activity, 用来欺骗AMS  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".StubActivity"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>OK，那么我们启动TargetActivity很简单，就是个<code>startActivity</code>调用的事：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, TargetActivity.class));</span><br></pre></td></tr></table></figure>
<p>如果你直接这么运行，肯定会直接抛出ActivityNotFoundException然后直接退出；我们接下来要做的就是让这个调用成功启动TargetActivity。</p>
<h4 id="狸猫换太子——使用替身Activity绕过AMS">狸猫换太子——使用替身Activity绕过AMS</h4><p>由于<code>AMS</code>进程会对Activity做显式声明验证，因此在<br>启动Activity的控制权转移到<code>AMS</code>进程之前，我们需要想办法<strong>临时</strong>把TargetActivity替换成替身StubActivity；在这之间有很长的一段调用链，我们可以轻松Hook掉；选择什么地方Hook是一个很自由的事情，但是Hook的步骤越后越可靠——Hook得越早，后面的调用就越复杂，越容易出错。</p>
<p>我们可以选择在进入<code>AMS</code>进程的入口进行Hook，具体来说也就是Hook <code>AMS</code>在本进程的代理对象ActivityManagerNative。如果你不知道如何Hook掉这个AMS的代理对象，请查阅我之前的文章 <a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/">Hook机制之AMS&amp;PMS</a> </p>
<p>我们Hook掉ActivityManagerNative对于startActivity方法的调用，替换掉交给AMS的intent对象，将里面的TargetActivity的暂时替换成已经声明好的替身StubActivity；这种Hook方式 <a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/">前文</a> 讲述的很详细，不赘述；替换的关键代码如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">"startActivity"</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="comment">// 只拦截这个方法</span></span><br><span class="line">    <span class="comment">// 替换参数, 任你所为;甚至替换原始Activity启动别的Activity偷梁换柱</span></span><br><span class="line">    <span class="comment">// API 23:</span></span><br><span class="line">    <span class="comment">// public final Activity startActivityNow(Activity parent, String id,</span></span><br><span class="line">    <span class="comment">// Intent intent, ActivityInfo activityInfo, IBinder token, Bundle state,</span></span><br><span class="line">    <span class="comment">// Activity.NonConfigurationInstances lastNonConfigurationInstances) &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到参数里面的第一个Intent 对象</span></span><br><span class="line"></span><br><span class="line">    Intent raw;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (args[i] <span class="keyword">instanceof</span> Intent) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    raw = (Intent) args[index];</span><br><span class="line"></span><br><span class="line">    Intent newIntent = <span class="keyword">new</span> Intent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里包名直接写死,如果再插件里,不同的插件有不同的包  传递插件的包名即可</span></span><br><span class="line">    String targetPackage = <span class="string">"com.weishu.intercept_activity.app"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里我们把启动的Activity临时替换为 StubActivity</span></span><br><span class="line">    ComponentName componentName = <span class="keyword">new</span> ComponentName(targetPackage, StubActivity.class.getCanonicalName());</span><br><span class="line">    newIntent.setComponent(componentName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把我们原始要启动的TargetActivity先存起来</span></span><br><span class="line">    newIntent.putExtra(HookHelper.EXTRA_TARGET_INTENT, raw);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换掉Intent, 达到欺骗AMS的目的</span></span><br><span class="line">    args[index] = newIntent;</span><br><span class="line"></span><br><span class="line">    Log.d(TAG, <span class="string">"hook success"</span>);</span><br><span class="line">    <span class="keyword">return</span> method.invoke(mBase, args);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> method.invoke(mBase, args);</span><br></pre></td></tr></table></figure>
<p>通过这个替换过程，在ActivityManagerNative的startActivity调用之后，system_server端收到Binder驱动的消息，开始执行ActivityManagerService里面真正的<code>startActivity</code>方法；这时候AMS看到的<code>intent</code>参数里面的组件已经是<code>StubActivity</code>了，因此可以成功绕过检查，这时候如果不做后面的Hook，直接调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, TargetActivity.class));</span><br></pre></td></tr></table></figure>
<p>也不会出现上文的ActivityNotFoundException</p>
<h4 id="借尸还魂——拦截Callback从恢复真身">借尸还魂——拦截Callback从恢复真身</h4><p>行百里者半九十。现在我们的<code>startActivity</code>启动一个没有显式声明的Activity已经不会抛异常了，但是要真正正确地把TargetActivity启动起来，还有一些事情要做。其中最重要的一点是，我们用替身StubActivity临时换了TargetActivity，肯定需要在『合适的』时候替换回来；接下来我们就完成这个过程。</p>
<p>在AMS进程里面我们是没有办法换回来的，因此我们要等AMS把控制权交给App所在进程，也就是上面那个『Activity启动过程简图』的第三步。AMS进程转移到App进程也是通过Binder调用完成的，承载这个功能的Binder对象是IApplicationThread；在App进程它是Server端，在Server端接受Binder远程调用的是Binder线程池，Binder线程池通过Handler将消息转发给App的主线程；（我这里不厌其烦地叙述Binder调用过程，希望读者不要反感，其一加深印象，其二懂Binder真的很重要）我们可以在这个<strong>Handler里面将替身恢复成真身</strong>。</p>
<p>这里不打算讲述Handler 的原理，我们简单看一下Handler是如何处理接收到的Message的，如果我们能拦截这个Message的接收过程，就有可能完成替身恢复工作；Handler类的<code>dispathMesage</code>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个方法可以看出来，Handler类消息分发的过程如下：</p>
<ol>
<li>如果传递的Message本身就有callback，那么直接使用Message对象的callback方法；</li>
<li>如果Handler类的成员变量<code>mCallback</code>存在，那么首先执行这个<code>mCallback</code>回调；</li>
<li>如果<code>mCallback</code>的回调返回<code>true</code>，那么表示消息已经成功处理；直接结束。</li>
<li>如果<code>mCallback</code>的回调返回<code>false</code>，那么表示消息没有处理完毕，会继续使用Handler类的<code>handleMessage</code>方法处理消息。</li>
</ol>
<p>那么，ActivityThread中的Handler类<code>H</code>是如何实现的呢？<code>H</code>的部分源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStart"</span>);</span><br><span class="line">            ActivityClientRecord r = (ActivityClientRecord)msg.obj;</span><br><span class="line"></span><br><span class="line">            r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                    r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">            handleLaunchActivity(r, <span class="keyword">null</span>);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RELAUNCH_ACTIVITY: &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityRestart"</span>);</span><br><span class="line">            ActivityClientRecord r = (ActivityClientRecord)msg.obj;</span><br><span class="line">            handleRelaunchActivity(r);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下略</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>H</code>类仅仅重载了<code>handleMessage</code>方法；通过dispathMessage的消息分发过程得知，我们可以拦截这一过程：<strong>把这个<code>H</code>类的<code>mCallback</code>替换为我们的自定义实现</strong>，这样<code>dispathMessage</code>就会首先使用这个自定义的<code>mCallback</code>，然后看情况使用<code>H</code>重载的<code>handleMessage</code>。</p>
<p>这个<code>Handler.Callback</code>是一个接口，我们可以使用动态代理或者普通代理完成Hook，这里我们使用普通的静态代理方式；创建一个自定义的Callback类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* package */</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThreadHandlerCallback</span> <span class="keyword">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Handler mBase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ActivityThreadHandlerCallback</span><span class="params">(Handler base)</span> </span>&#123;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="comment">// ActivityThread里面 "LAUNCH_ACTIVITY" 这个字段的值是100</span></span><br><span class="line">            <span class="comment">// 本来使用反射的方式获取最好, 这里为了简便直接使用硬编码</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">                handleLaunchActivity(msg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mBase.handleMessage(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里简单起见,直接取出TargetActivity;</span></span><br><span class="line"></span><br><span class="line">        Object obj = msg.obj;</span><br><span class="line">        <span class="comment">// 根据源码:</span></span><br><span class="line">        <span class="comment">// 这个对象是 ActivityClientRecord 类型</span></span><br><span class="line">        <span class="comment">// 我们修改它的intent字段为我们原来保存的即可.</span></span><br><span class="line"><span class="comment">/*        switch (msg.what) &#123;</span><br><span class="line">/             case LAUNCH_ACTIVITY: &#123;</span><br><span class="line">/                 Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart");</span><br><span class="line">/                 final ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line">/</span><br><span class="line">/                 r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">/                         r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">/                 handleLaunchActivity(r, null);</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 把替身恢复成真身</span></span><br><span class="line">            Field intent = obj.getClass().getDeclaredField(<span class="string">"intent"</span>);</span><br><span class="line">            intent.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Intent raw = (Intent) intent.get(obj);</span><br><span class="line"></span><br><span class="line">            Intent target = raw.getParcelableExtra(HookHelper.EXTRA_TARGET_INTENT);</span><br><span class="line">            raw.setComponent(target.getComponent());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个Callback类的使命很简单：<strong>把替身StubActivity恢复成真身TargetActivity</strong>；有了这个自定义的Callback之后我们需要把ActivityThread里面处理消息的Handler类<code>H</code>的的<code>mCallback</code>修改为自定义callback类的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先获取到当前的ActivityThread对象</span></span><br><span class="line">Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">Field currentActivityThreadField = activityThreadClass.getDeclaredField(<span class="string">"sCurrentActivityThread"</span>);</span><br><span class="line">currentActivityThreadField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object currentActivityThread = currentActivityThreadField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于ActivityThread一个进程只有一个,我们获取这个对象的mH</span></span><br><span class="line">Field mHField = activityThreadClass.getDeclaredField(<span class="string">"mH"</span>);</span><br><span class="line">mHField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Handler mH = (Handler) mHField.get(currentActivityThread);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置它的回调, 根据源码:</span></span><br><span class="line"><span class="comment">// 我们自己给他设置一个回调,就会替代之前的回调;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        public void dispatchMessage(Message msg) &#123;</span></span><br><span class="line"><span class="comment">//            if (msg.callback != null) &#123;</span></span><br><span class="line"><span class="comment">//                handleCallback(msg);</span></span><br><span class="line"><span class="comment">//            &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                if (mCallback != null) &#123;</span></span><br><span class="line"><span class="comment">//                    if (mCallback.handleMessage(msg)) &#123;</span></span><br><span class="line"><span class="comment">//                        return;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                handleMessage(msg);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">Field mCallBackField = Handler.class.getDeclaredField(<span class="string">"mCallback"</span>);</span><br><span class="line">mCallBackField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">mCallBackField.set(mH, <span class="keyword">new</span> ActivityThreadHandlerCallback(mH));</span><br></pre></td></tr></table></figure>
<p>到这里，我们已经成功地绕过<code>AMS</code>，完成了『启动没有在AndroidManifest.xml中显式声明的Activity』的过程；瞒天过海，这种玩弄系统与股掌之中的快感你们能体会到吗？</p>
<h4 id="僵尸or活人？——能正确收到生命周期回调吗">僵尸or活人？——能正确收到生命周期回调吗</h4><p>虽然我们完成了『启动没有在AndroidManifest.xml中显式声明的Activity 』，但是启动的TargetActivity是否有自己的生命周期呢，我们还需要额外的处理过程吗？</p>
<p>实际上TargetActivity已经是一个有血有肉的Activity了：它具有自己正常的生命周期；可以运行<a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">Demo代码</a>验证一下。</p>
<p>这个过程是如何完成的呢？我们以<code>onDestroy</code>为例简要分析一下：</p>
<blockquote>
<p>从Activity的<code>finish</code>方法开始跟踪，最终会通过ActivityManagerNative到<code>AMS</code>然后接着通过ApplicationThread到ActivityThread，然后通过<code>H</code>转发消息到ActivityThread的handleDestroyActivity，接着这个方法把任务交给performDestroyActivity完成。</p>
</blockquote>
<p>在真正分析这个方法之前，需要说明一点的是：不知读者是否感受得到，App进程与<code>AMS</code>交互几乎都是这么一种模式，几个角色 ActivityManagerNative, ApplicationThread, ActivityThread以及Handler类<code>H</code>分工明确，读者可以按照这几个角色的功能分析<code>AMS</code>的任何调用过程，屡试不爽；这也是我的初衷——希望分析插件框架的过程中能帮助深入理解Android Framework。</p>
<p>好了继续分析performDestroyActivity，关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ActivityClientRecord r = mActivities.get(token);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...略</span></span><br><span class="line"></span><br><span class="line">mInstrumentation.callActivityOnDestroy(r.activity);</span><br></pre></td></tr></table></figure>
<p>这里通过<code>mActivities</code>拿到了一个ActivityClientRecord，然后直接把这个record里面的Activity交给Instrument类完成了onDestroy的调用。</p>
<p>在我们这个demo的场景下，r.activity是TargetActivity还是StubActivity？按理说，由于我们欺骗了<code>AMS</code>，<code>AMS</code>应该只知道<code>StubActivity</code>的存在，它压根儿就不知道TargetActivity是什么，为什么它能正确完成对TargetActivity生命周期的回调呢？</p>
<p>一切的秘密在<code>token</code>里面。<code>AMS</code>与<code>ActivityThread</code>之间对于Activity的生命周期的交互，并没有直接使用Activity对象进行交互，而是使用一个token来标识，这个token是binder对象，因此可以方便地跨进程传递。Activity里面有一个成员变量<code>mToken</code>代表的就是它，token可以唯一地标识一个Activity对象，它在Activity的<code>attach</code>方法里面初始化；</p>
<p>在<code>AMS</code>处理Activity的任务栈的时候，使用这个token标记Activity，因此在我们的demo里面，<code>AMS</code>进程里面的token对应的是StubActivity，也就是<code>AMS</code>还在傻乎乎地操作StubActivity（关于这一点，你可以dump出任务栈的信息，可以观察到dump出的确实是StubActivity）。但是在我们App进程里面，token对应的却是TargetActivity！因此，在ActivityThread执行回调的时候，能正确地回调到TargetActivity相应的方法。</p>
<p>为什么App进程里面，token对应的是TargetActivity呢？</p>
<p>回到代码，ActivityClientRecord是在<code>mActivities</code>里面取出来的，确实是根据token取；那么这个token是什么时候添加进去的呢？我们看performLaunchActivity就完成明白了：它通过classloader加载了TargetActivity，然后完成一切操作之后把这个activity添加进了<code>mActivities</code>！另外，在这个方法里面我们还能看到对Ativity<code>attach</code>方法的调用，它传递给了新创建的Activity一个token对象，而这个token是在ActivityClientRecord构造函数里面初始化的。</p>
<p>至此我们已经可以确认，通过这种方式启动的Activity有它自己完整而独立的生命周期！</p>
<h2 id="小节">小节</h2><p>本文讲述了『启动一个并没有在AndroidManifest.xml中显示声明的Activity』的解决办法，我们成功地绕过了Android的这个限制，这个是插件Activity管理技术的基础；但是要做到启动一个插件Activity问题远没有这么简单。</p>
<p>首先，在Android中，Activity有不同的启动模式；我们声明了一个替身StubActivity，肯定没有满足所有的要求；因此，我们需要在AndroidManifest.xml中声明一系列的有不同launchMode的Activity，还需要完成替身与真正Activity launchMode的匹配过程；这样才能完成启动各种类型Activity的需求，关于这一点，在 DroidPlugin 的com.morgoo.droidplugin.stub包下面可以找到。</p>
<p>另外，每启动一个插件的Activity都需要一个StubActivity，但是AndroidManifest.xml中肯定只能声明有限个，如果一直<code>startActivity</code>而不finish的话，那么理论上就需要无限个StubActivity；这个问题该如何解决呢？事实上，这个问题在技术上没有好的解决办法。但是，如果你的App startActivity了十几次，而没有finish任何一个Activity，这样在Activity的回退栈里面有十几个Activity，用户难道按back十几次回到主页吗？有这种需求说明你的产品设计有问题；一个App一级页面，二级页面..到五六级的页面已经影响体验了，所以，每种LauchMode声明十个StubActivity绝对能满足需求了。</p>
<p>最后，在本文所述例子中，TargetActivity与StubActivity存在于同一个Apk，因此系统的ClassLoader能够成功加载并创建TargetActivity的实例。但是在实际的插件系统中，要启动的目标Activity肯定存在于一个单独的文件中，系统默认的ClassLoader无法加载插件中的Activity类——系统压根儿就不知道要加载的插件在哪，谈何加载？因此还有一个很重要的问题需要处理：</p>
<p><strong>我们要完成插件系统中类的加载</strong>，这可以通过自定义ClassLoader实现。解决了『启动没有在AndroidManifest.xml中显式声明的，并且存在于外部文件中的Activity』的问题，插件系统对于Activity的管理才算得上是一个完全体。篇幅所限，欲知后事如何，请听下回分解！</p>
<p>喜欢就点个赞吧～持续更新，请关注github项目 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>和我的 <a href="http://weishu.me">博客</a>!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前的 <a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">Android插件化原理解析</a> 系列文章揭开了Hook机制的神秘面纱，现在我们手握倚天屠龙，那么如何通过这种技术完成插件化方案呢？具体来说，插件中的Activity，Service等组件如何在Android系统上运行起来？</p>
<p>在Java平台要做到动态运行模块、热插拔可以使用<code>ClassLoader</code>技术进行动态类加载，比如广泛使用的<code>OSGi</code>技术。在Android上当然也可以使用动态加载技术，但是仅仅把类加载进来就足够了吗？<code>Activity</code>，<code>Service</code>等组件是有生命周期的，它们统一由系统服务<code>AMS</code>管理；使用<code>ClassLoader</code>可以从插件中创建Activity对象，但是，一个没有生命周期的Activity对象有什么用？所以在Android系统上，仅仅完成动态类加载是不够的；我们需要想办法把我们加载进来的Activity等组件交给系统管理，让<code>AMS</code>赋予组件生命周期；这样才算是一个有血有肉的完善的插件化方案。</p>
<p>接下来的系列文章会讲述 DroidPlugin对于Android四大组件的处理方式，我们且看它如何采用Hook技术坑蒙拐骗把系统玩弄于股掌之中，最终赋予Activity，Service等组件生命周期，完成借尸还魂的。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="droidplugin" scheme="http://weishu.me/tags/droidplugin/"/>
    
      <category term="plugin framework" scheme="http://weishu.me/tags/plugin-framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 插件化原理解析——Hook机制之AMS&PMS]]></title>
    <link href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/"/>
    <id>http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/</id>
    <published>2016-03-07T08:35:46.000Z</published>
    <updated>2019-01-30T04:06:02.852Z</updated>
    <content type="html"><![CDATA[<p>在前面的文章中我们介绍了DroidPlugin的Hook机制，也就是<strong>代理方式</strong>和<strong>Binder Hook</strong>；插件框架通过AOP实现了插件使用和开发的透明性。在讲述DroidPlugin如何实现四大组件的插件化之前，有必要说明一下它对ActivityManagerServiche以及PackageManagerService的Hook方式（以下简称AMS，PMS）。</p>
<p>ActivityManagerService对于FrameWork层的重要性不言而喻，Android的四大组件无一不与它打交道：</p>
<ol>
<li><code>startActivity</code>最终调用了AMS的<code>startActivity</code>系列方法，实现了Activity的启动；Activity的生命周期回调，也在AMS中完成；</li>
<li><code>startService,bindService</code>最终调用到AMS的startService和bindService方法；</li>
<li>动态广播的注册和接收在<code>AMS</code>中完成（静态广播在<code>PMS</code>中完成）</li>
<li><code>getContentResolver</code>最终从<code>AMS</code>的<code>getContentProvider</code>获取到ContentProvider</li>
</ol>
<p>而<code>PMS</code>则完成了诸如权限校捡(<code>checkPermission,checkUidPermission</code>)，Apk meta信息获取(<code>getApplicationInfo</code>等)，四大组件信息获取(<code>query</code>系列方法)等重要功能。</p>
<p>在上文<a href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/">Android插件化原理解析——Hook机制之Binder Hook</a>中讲述了DroidPlugin的Binder Hook机制；我们知道<code>AMS</code>和<code>PMS</code>就是以Binder方式提供给应用程序使用的系统服务，理论上我们也可以采用这种方式Hook掉它们。但是由于这两者使用得如此频繁，Framework给他们了一些“特别优待”，这也给了我们相对于Binder Hook更加稳定可靠的hook方式。</p>
<a id="more"></a>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>，参考此项目的<code>ams-pms-hook</code>模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">索引</a>。</p>
<h2 id="AMS获取过程">AMS获取过程</h2><p>前文提到Android的四大组件无一不与<code>AMS</code>相关，也许读者还有些许疑惑；这里我就挑一个例子，依据Android源码来说明，一个简单的<code>startActivity</code>是如何调用<code>AMS</code>最终通过IPC到system_server的。</p>
<p>不论读者是否知道，我们使用<code>startActivity</code>有两种形式：</p>
<ol>
<li>直接调用<code>Context</code>类的<code>startActivity</code>方法；这种方式启动的Activity没有Activity栈，因此不能以standard方式启动，必须加上<code>FLAG_ACTIVITY_NEW_TASK</code>这个Flag。</li>
<li>调用被<code>Activity</code>类重载过的<code>startActivity</code>方法，通常在我们的Activity中直接调用这个方法就是这种形式；</li>
</ol>
<h3 id="Context-startActivity">Context.startActivity</h3><p>我们查看<code>Context</code>类的<code>startActivity</code>方法，发现这竟然是一个抽象类；查看<code>Context</code>的类继承关系图如下：</p>
<p><img src="http://weishu.dimensionalzone.com/201601/1457322345547.png" width="329"></p>
<p>我们看到诸如<code>Activity</code>，<code>Service</code>等并没有直接继承<code>Context</code>，而是继承了<code>ContextWrapper</code>；继续查看<code>ContextWrapper</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    mBase.startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WTF!! 果然人如其名，只是一个wrapper而已；这个<code>mBase</code>是什么呢？这里我先直接告诉你，它的真正实现是<code>ContextImpl</code>类；至于为什么，有一条思路：<em>mBase是在ContextWrapper构造的时候传递进来的，那么在ContextWrapper构造的时候可以找到答案</em><br>什么时候会构造ContextWrapper呢？它的子类<code>Application</code>，<code>Service</code>等被创建的时候。</p>
<p>可以在App的主线程<code>AcitivityThread</code>的<code>performLaunchActivit</code>方法里面找到答案；更详细的解析可以参考老罗的<a href="http://blog.csdn.net/luoshengyang/article/details/6689748" target="_blank" rel="external"> Android应用程序启动过程源代码分析</a></p>
<p>好了，我们姑且当作已经知道Context.startActivity最终使用了ContextImpl里面的方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(</span><br><span class="line">                <span class="string">"Calling startActivity() from outside of an Activity "</span></span><br><span class="line">                + <span class="string">" context requires the FLAG_ACTIVITY_NEW_TASK flag."</span></span><br><span class="line">                + <span class="string">" Is this really what you want?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mMainThread.getInstrumentation().execStartActivity(</span><br><span class="line">        getOuterContext(), mMainThread.getApplicationThread(), <span class="keyword">null</span>,</span><br><span class="line">        (Activity)<span class="keyword">null</span>, intent, -<span class="number">1</span>, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码相当简单；我们知道了两件事：</p>
<ol>
<li>其一，我们知道了在Service等非Activity的Context里面启动Activity为什么需要添加<code>FLAG_ACTIVITY_NEW_TASK</code>；</li>
<li>其二，真正的<code>startActivity</code>使用了<code>Instrumentation</code>类的<code>execStartActivity</code>方法；继续跟踪：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span><br><span class="line">        Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">        Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ... 省略无关代码</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData();</span><br><span class="line">        intent.prepareToLeaveProcess();</span><br><span class="line">        <span class="comment">// ----------------look here!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line">        <span class="keyword">int</span> result = ActivityManagerNative.getDefault()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                    requestCode, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, options);</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里我们发现真正调用的是<code>ActivityManagerNative</code>的<code>startActivity</code>方法；如果你不清楚<code>ActivityManager</code>，<code>ActivityManagerService</code>以及<code>ActivityManagerNative</code>之间的关系；建议先仔细阅读我之前关于Binder的文章 <a href="http://weishu.me/2016/01/12/binder-index-for-newer/">Binder学习指南</a>。</p>
<h3 id="Activity-startActivity">Activity.startActivity</h3><p>Activity类的<code>startActivity</code>方法相比Context而言直观了很多；这个<code>startActivity</code>通过若干次调用辗转到达<code>startActivityForResult</code>这个方法，在这个方法内部有如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Instrumentation.ActivityResult ar =</span><br><span class="line">    mInstrumentation.execStartActivity(</span><br><span class="line">        <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">        intent, requestCode, options);</span><br></pre></td></tr></table></figure>
<p>可以看到，其实通过Activity和ContextImpl类启动Activity并无本质不同，他们都通过<code>Instrumentation</code>这个辅助类调用到了<code>ActivityManagerNative</code>的方法。</p>
<h2 id="Hook_AMS">Hook AMS</h2><p>OK，我们到现在知道；其实<code>startActivity</code>最终通过<code>ActivityManagerNative</code>这个方法远程调用了<code>AMS</code>的<code>startActivity</code>方法。那么这个<code>ActivityManagerNative</code>是什么呢？</p>
<p>ActivityManagerNative实际上就是<code>ActivityManagerService</code>这个远程对象的Binder代理对象；每次需要与AMS打交道的时候，需要借助这个代理对象通过驱动进而完成IPC调用。</p>
<p>我们继续看<code>ActivityManagerNative</code>的<code>getDefault()</code>方法做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gDefault.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>gDefault</code>这个静态变量的定义如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">    protected IActivityManager create() &#123;</span><br><span class="line">        IBinder b = ServiceManager.getService("activity</span><br><span class="line">        IActivityManager am = asInterface(</span><br><span class="line">        return am;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于整个Framework与AMS打交道是如此频繁，framework使用了一个单例把这个<code>AMS</code>的代理对象保存了起来；这样只要需要与<code>AMS</code>进行IPC调用，获取这个单例即可。这是<code>AMS</code>这个系统服务与其他普通服务的不同之处，也是我们不通过Binder Hook的原因——我们只需要简单地Hook掉这个单例即可。</p>
<p>这里还有一点小麻烦：Android不同版本之间对于如何保存这个单例的代理对象是不同的；Android 2.x系统直接使用了一个简单的静态变量存储，Android 4.x以上抽象出了一个Singleton类；具体的差异可以使用<code>grepcode</code>进行比较：<a href="http://grepcode.com/file_/repository.grepcode.com/java/ext/com.google.android/android/4.0.1_r1/android/app/ActivityManagerNative.java/?v=diff&amp;id2=2.3.3_r1" target="_blank" rel="external">差异</a></p>
<p>我们以4.x以上的代码为例说明如何Hook掉<code>AMS</code>；方法使用的动态代理，如果有不理解的，可以参考之前的系列文章<a href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/">Android插件化原理解析——Hook机制之动态代理</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; activityManagerNativeClass = Class.forName(<span class="string">"android.app.ActivityManagerNative"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 gDefault 这个字段, 想办法替换它</span></span><br><span class="line">Field gDefaultField = activityManagerNativeClass.getDeclaredField(<span class="string">"gDefault"</span>);</span><br><span class="line">gDefaultField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object gDefault = gDefaultField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.x以上的gDefault是一个 android.util.Singleton对象; 我们取出这个单例里面的字段</span></span><br><span class="line">Class&lt;?&gt; singleton = Class.forName(<span class="string">"android.util.Singleton"</span>);</span><br><span class="line">Field mInstanceField = singleton.getDeclaredField(<span class="string">"mInstance"</span>);</span><br><span class="line">mInstanceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActivityManagerNative 的gDefault对象里面原始的 IActivityManager对象</span></span><br><span class="line">Object rawIActivityManager = mInstanceField.get(gDefault);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个这个对象的代理对象, 然后替换这个字段, 让我们的代理对象帮忙干活</span></span><br><span class="line">Class&lt;?&gt; iActivityManagerInterface = Class.forName(<span class="string">"android.app.IActivityManager"</span>);</span><br><span class="line">Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class&lt;?&gt;[] &#123; iActivityManagerInterface &#125;, <span class="keyword">new</span> IActivityManagerHandler(rawIActivityManager));</span><br><span class="line">mInstanceField.set(gDefault, proxy);</span><br></pre></td></tr></table></figure>
<p>好了，我们hook成功之后启动Activity看看会发生什么：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D/HookHelper﹕ hey, baby; you are hook!!</span><br><span class="line">D/HookHelper﹕ <span class="function"><span class="keyword">method</span>:</span>activityResumed called <span class="keyword">with</span> args:[android.os.BinderProxy@<span class="number">9</span>bc71b2]</span><br><span class="line">D/HookHelper﹕ hey, baby; you are hook!!</span><br><span class="line">D/HookHelper﹕ <span class="function"><span class="keyword">method</span>:</span>activityIdle called <span class="keyword">with</span> args:[android.os.BinderProxy@<span class="number">9</span>bc71b2, null, <span class="keyword">false</span>]</span><br><span class="line">D/HookHelper﹕ hey, baby; you are hook!!</span><br><span class="line">D/HookHelper﹕ <span class="function"><span class="keyword">method</span>:</span>startActivity called <span class="keyword">with</span> args:[android.app.ActivityThread$ApplicationThread@<span class="number">17</span>e750c, com.weishu.upf.ams_pms_hook.app, Intent <span class="comment">&#123; act=android.intent.action.VIEW dat=http://wwww.baidu.com/... &#125;</span>, null, android.os.BinderProxy@<span class="number">9</span>bc71b2, null, -<span class="number">1</span>, <span class="number">0</span>, null, null]</span><br><span class="line">D/HookHelper﹕ hey, baby; you are hook!!</span><br><span class="line">D/HookHelper﹕ <span class="function"><span class="keyword">method</span>:</span>activityPaused called <span class="keyword">with</span> args:[android.os.BinderProxy@<span class="number">9</span>bc71b2]</span><br></pre></td></tr></table></figure>
<p>可以看到，简单的几行代码，<code>AMS</code>已经被我们完全劫持了!! 至于劫持了能干什么，自己发挥想象吧~ </p>
<p>DroidPlugin关于<code>AMS</code>的Hook，可以查看<code>IActivityManagerHook</code>这个类，它处理了我上述所说的兼容性问题，其他原理相同。另外，也许有童鞋有疑问了，你用<code>startActivity</code>为例怎么能确保Hook掉这个静态变量之后就能保证所有使用<code>AMS</code>的入口都被Hook了呢？</p>
<p>答曰：无他，唯手熟尔。</p>
<p>Android Framewrok层对于四大组件的处理，调用<code>AMS</code>服务的时候，全部都是通过使用这种方式；若有疑问可以自行查看源码。你可以从<code>Context</code>类的startActivity, startService,bindService, registerBroadcastReceiver, getContentResolver 等等入口进行跟踪，最终都会发现它们都会使用ActivityManagerNative的这个<code>AMS</code>代理对象来完成对远程AMS的访问。</p>
<h2 id="PMS获取过程">PMS获取过程</h2><p><code>PMS</code>的获取也是通过Context完成的，具体就是<code>getPackageManager</code>这个方法；我们姑且当作已经知道了Context的实现在ContextImpl类里面，直奔<code>ContextImpl</code>类的<code>getPackageManager</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PackageManager <span class="title">getPackageManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPackageManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IPackageManager pm = ActivityThread.getPackageManager();</span><br><span class="line">    <span class="keyword">if</span> (pm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Doesn't matter if we make more than one instance.</span></span><br><span class="line">        <span class="keyword">return</span> (mPackageManager = <span class="keyword">new</span> ApplicationPackageManager(<span class="keyword">this</span>, pm));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里干了两件事：</p>
<ol>
<li>真正的<code>PMS</code>的代理对象在<code>ActivityThread</code>类里面</li>
<li><code>ContextImpl</code>通过<code>ApplicationPackageManager</code>对它还进行了一层包装</li>
</ol>
<p>我们继续查看<code>ActivityThread</code>类的<code>getPackageManager</code>方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IPackageManager <span class="title">getPackageManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sPackageManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line">    IBinder b = ServiceManager.getService(<span class="string">"package"</span>);</span><br><span class="line">    sPackageManager = IPackageManager.Stub.asInterface(b);</span><br><span class="line">    <span class="keyword">return</span> sPackageManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，和<code>AMS</code>一样，<code>PMS</code>的Binder代理对象也是一个全局变量存放在一个静态字段中；我们可以如法炮制，Hook掉PMS。</p>
<p>现在我们的目的很明切，如果需要Hook <code>PMS</code>有两个地方需要Hook掉：</p>
<ol>
<li><code>ActivityThread</code>的静态字段<code>sPackageManager</code></li>
<li>通过Context类的<code>getPackageManager</code>方法获取到的<code>ApplicationPackageManager</code>对象里面的<code>mPM</code>字段。</li>
</ol>
<h2 id="Hook_PMS">Hook PMS</h2><p>现在使用代理Hook应该是轻车熟路了吧，通过上面的分析，我们Hook两个地方；代码信手拈来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取全局的ActivityThread对象</span></span><br><span class="line">Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取ActivityThread里面原始的 sPackageManager</span></span><br><span class="line">Field sPackageManagerField = activityThreadClass.getDeclaredField(<span class="string">"sPackageManager"</span>);</span><br><span class="line">sPackageManagerField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object sPackageManager = sPackageManagerField.get(currentActivityThread);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备好代理对象, 用来替换原始的对象</span></span><br><span class="line">Class&lt;?&gt; iPackageManagerInterface = Class.forName(<span class="string">"android.content.pm.IPackageManager"</span>);</span><br><span class="line">Object proxy = Proxy.newProxyInstance(iPackageManagerInterface.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class&lt;?&gt;[] &#123; iPackageManagerInterface &#125;,</span><br><span class="line">        <span class="keyword">new</span> HookHandler(sPackageManager));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 替换掉ActivityThread里面的 sPackageManager 字段</span></span><br><span class="line">sPackageManagerField.set(currentActivityThread, proxy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 替换 ApplicationPackageManager里面的 mPM对象</span></span><br><span class="line">PackageManager pm = context.getPackageManager();</span><br><span class="line">Field mPmField = pm.getClass().getDeclaredField(<span class="string">"mPM"</span>);</span><br><span class="line">mPmField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">mPmField.set(pm, proxy);</span><br></pre></td></tr></table></figure>
<p>好了，Hook完毕我们验证以下结论；调用一下<code>PMS</code>的<code>getInstalledApplications</code>方法，打印日志如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">03</span>-<span class="number">07</span> <span class="number">15</span>:<span class="number">07</span>:<span class="number">27.187</span>    <span class="number">8306</span>-<span class="number">8306</span>/com.weishu.upf.ams_pms_hook.app D/IActivityManagerHandler﹕ hey, baby; you are hook!!</span><br><span class="line"><span class="number">03</span>-<span class="number">07</span> <span class="number">15</span>:<span class="number">07</span>:<span class="number">27.187</span>    <span class="number">8306</span>-<span class="number">8306</span>/com.weishu.upf.ams_pms_hook.app D/IActivityManagerHandler﹕ method:getInstalledApplications called with args:[<span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>OK，我们又成功劫持了<code>PackageManager</code>！！DroidPlugin 处理PMS的代码可以在<code>IPackageManagerHook</code>查看。</p>
<p>在结束讲解PackageManager的Hook之前，我们需要说明一点；那就是<code>Context</code>的实现类里面没有使用静态全局变量来保存<code>PMS</code>的代理对象，而是每拥有一个<code>Context</code>的实例就持有了一个<code>PMS</code>代理对象的引用；所以这里有个很蛋疼的事情，那就是我们如果想要完全Hook住<code>PMS</code>，需要精确控制整个进程内部创建的<code>Context</code>对象；所幸，插件框架中，插件的Activity，Service，ContentProvider，Broadcast等所有使用到Context的地方，都是由框架控制创建的；因此我们要小心翼翼地替换掉所有这些对象持有的<code>PMS</code>代理对象。</p>
<p>我前面也提到过，<strong>静态变量和单例</strong>都是良好的Hook点，这里很好地反证了这句话：想要Hook掉一个实例变量该是多么麻烦!</p>
<h2 id="小结">小结</h2><p>写到这里，关于DroidPlugin的Hook技术的讲解已经完结了；我相信读者或多或少地认识到，其实Hook并不是一项神秘的技术；一个干净，透明的框架少不了AOP，而AOP也少不了Hook。</p>
<p>我所讲解的Hook仅仅使用反射和动态代理技术，更加强大的Hook机制可以进行<strong>字节码编织</strong>，比如J2EE广泛使用了cglib和asm进行AOP编程；而Android上现有的插件框架还是加载编译时代码，采用动态生成类的技术理论上也是可行的；之前有一篇文章<a href="https://segmentfault.com/a/1190000004077469" target="_blank" rel="external">Android动态加载黑科技 动态创建Activity模式</a>，就讲述了这种方式；现在全球的互联网公司不排除有用这种技术实现插件框架的可能 ；我相信不远的未来，这种技术也会在Android上大放异彩。</p>
<p>了解完Hook技术之后，接下来的系列文章会讲述DroidPlugin对Android四大组件在插件系统上的处理，插件框架对于这一部分的实现是DroidPlugin的精髓，Hook只不过是工具而已。学习这部分内容需要对于Activity，Service，Broadcast以及ContentProvider的工作机制有一定的了解，因此我也会在必要的时候穿插讲解一些Android Framework的知识；我相信这一定会对读者大有裨益。</p>
<p>喜欢就点个赞吧～持续更新，请关注github项目 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>和我的 <a href="http://weishu.me">博客</a>!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在前面的文章中我们介绍了DroidPlugin的Hook机制，也就是<strong>代理方式</strong>和<strong>Binder Hook</strong>；插件框架通过AOP实现了插件使用和开发的透明性。在讲述DroidPlugin如何实现四大组件的插件化之前，有必要说明一下它对ActivityManagerServiche以及PackageManagerService的Hook方式（以下简称AMS，PMS）。</p>
<p>ActivityManagerService对于FrameWork层的重要性不言而喻，Android的四大组件无一不与它打交道：</p>
<ol>
<li><code>startActivity</code>最终调用了AMS的<code>startActivity</code>系列方法，实现了Activity的启动；Activity的生命周期回调，也在AMS中完成；</li>
<li><code>startService,bindService</code>最终调用到AMS的startService和bindService方法；</li>
<li>动态广播的注册和接收在<code>AMS</code>中完成（静态广播在<code>PMS</code>中完成）</li>
<li><code>getContentResolver</code>最终从<code>AMS</code>的<code>getContentProvider</code>获取到ContentProvider</li>
</ol>
<p>而<code>PMS</code>则完成了诸如权限校捡(<code>checkPermission,checkUidPermission</code>)，Apk meta信息获取(<code>getApplicationInfo</code>等)，四大组件信息获取(<code>query</code>系列方法)等重要功能。</p>
<p>在上文<a href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/">Android插件化原理解析——Hook机制之Binder Hook</a>中讲述了DroidPlugin的Binder Hook机制；我们知道<code>AMS</code>和<code>PMS</code>就是以Binder方式提供给应用程序使用的系统服务，理论上我们也可以采用这种方式Hook掉它们。但是由于这两者使用得如此频繁，Framework给他们了一些“特别优待”，这也给了我们相对于Binder Hook更加稳定可靠的hook方式。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="droidplugin" scheme="http://weishu.me/tags/droidplugin/"/>
    
      <category term="plugin framework" scheme="http://weishu.me/tags/plugin-framework/"/>
    
  </entry>
  
</feed>
